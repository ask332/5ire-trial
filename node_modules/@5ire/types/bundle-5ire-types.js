const f5ireTypes = (function (exports, typesKnown, require$$0$1) {
  'use strict';

  const global = window;

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  const require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);

  function evaluateThis$2(fn) {
    return fn('return this');
  }
  const xglobal$2 = typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : evaluateThis$2(Function);

  class TextDecoder$3 {
    constructor(_) {
    }
    decode(value) {
      let result = '';
      for (let i = 0; i < value.length; i++) {
        result += String.fromCharCode(value[i]);
      }
      return result;
    }
  }

  const TextDecoder$2 = typeof xglobal$2.TextDecoder === 'undefined' ? TextDecoder$3 : xglobal$2.TextDecoder;

  function evaluateThis$1(fn) {
    return fn('return this');
  }
  const xglobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : evaluateThis$1(Function);

  class TextEncoder$3 {
    encode(value) {
      const u8a = new Uint8Array(value.length);
      for (let i = 0; i < value.length; i++) {
        u8a[i] = value.charCodeAt(i);
      }
      return u8a;
    }
  }

  const TextEncoder$2 = typeof xglobal$1.TextEncoder === 'undefined' ? TextEncoder$3 : xglobal$1.TextEncoder;

  function evaluateThis(fn) {
    return fn('return this');
  }
  const xglobal = typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : evaluateThis(Function);

  function isFunction$1(value) {
    return typeof value === 'function';
  }

  function isString$1(value) {
    return typeof value === 'string' || value instanceof String;
  }

  function isUndefined(value) {
    return typeof value === 'undefined';
  }

  function assert$h(condition, message) {
    if (!condition) {
      throw new Error(isFunction$1(message) ? message() : message);
    }
  }
  function assertReturn(value, message) {
    assert$h(!isUndefined(value), message);
    return value;
  }

  function isNull(value) {
    return value === null;
  }

  function arrayRange$1(size, startAt = 0) {
    assert$h(size > 0, 'Expected non-zero, positive number as a range size');
    const result = new Array(size).fill(0);
    for (let i = 0; i < result.length; i++) {
      result[i] = i + startAt;
    }
    return result;
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var bn = {exports: {}};

  (function (module) {
  (function (module, exports) {
    function assert (val, msg) {
      if (!val) throw new Error(msg || 'Assertion failed');
    }
    function inherits (ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN (number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base === 'le' || base === 'be') {
          endian = base;
          base = 10;
        }
        this._init(number || 0, base || 10, endian || 'be');
      }
    }
    if (typeof module === 'object') {
      module.exports = BN;
    } else {
      exports.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
      if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
        Buffer = window.Buffer;
      } else {
        Buffer = require('buffer').Buffer;
      }
    } catch (e) {
    }
    BN.isBN = function isBN (num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === 'object' &&
        num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max (left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };
    BN.min = function min (left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };
    BN.prototype._init = function init (number, base, endian) {
      if (typeof number === 'number') {
        return this._initNumber(number, base, endian);
      }
      if (typeof number === 'object') {
        return this._initArray(number, base, endian);
      }
      if (base === 'hex') {
        base = 16;
      }
      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, '');
      var start = 0;
      if (number[0] === '-') {
        start++;
        this.negative = 1;
      }
      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);
          if (endian === 'le') {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };
    BN.prototype._initNumber = function _initNumber (number, base, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 0x4000000) {
        this.words = [ number & 0x3ffffff ];
        this.length = 1;
      } else if (number < 0x10000000000000) {
        this.words = [
          number & 0x3ffffff,
          (number / 0x4000000) & 0x3ffffff
        ];
        this.length = 2;
      } else {
        assert(number < 0x20000000000000);
        this.words = [
          number & 0x3ffffff,
          (number / 0x4000000) & 0x3ffffff,
          1
        ];
        this.length = 3;
      }
      if (endian !== 'le') return;
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray (number, base, endian) {
      assert(typeof number.length === 'number');
      if (number.length <= 0) {
        this.words = [ 0 ];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === 'be') {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === 'le') {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
          this.words[j] |= (w << off) & 0x3ffffff;
          this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    function parseHex4Bits (string, index) {
      var c = string.charCodeAt(index);
      if (c >= 65 && c <= 70) {
        return c - 55;
      } else if (c >= 97 && c <= 102) {
        return c - 87;
      } else {
        return (c - 48) & 0xf;
      }
    }
    function parseHexByte (string, lowerBound, index) {
      var r = parseHex4Bits(string, index);
      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex (number, start, endian) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var off = 0;
      var j = 0;
      var w;
      if (endian === 'be') {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 0x3ffffff;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;
        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          this.words[j] |= w & 0x3ffffff;
          if (off >= 18) {
            off -= 18;
            j += 1;
            this.words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }
      this.strip();
    };
    function parseBase (str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
          r += c - 49 + 0xa;
        } else if (c >= 17) {
          r += c - 17 + 0xa;
        } else {
          r += c;
        }
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase (number, base, start) {
      this.words = [ 0 ];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = (limbPow / base) | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 0x4000000) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for (i = 0; i < mod; i++) {
          pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 0x4000000) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      this.strip();
    };
    BN.prototype.copy = function copy (dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN.prototype.clone = function clone () {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand (size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype.strip = function strip () {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign () {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN.prototype.inspect = function inspect () {
      return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    };
    var zeros = [
      '',
      '0',
      '00',
      '000',
      '0000',
      '00000',
      '000000',
      '0000000',
      '00000000',
      '000000000',
      '0000000000',
      '00000000000',
      '000000000000',
      '0000000000000',
      '00000000000000',
      '000000000000000',
      '0000000000000000',
      '00000000000000000',
      '000000000000000000',
      '0000000000000000000',
      '00000000000000000000',
      '000000000000000000000',
      '0000000000000000000000',
      '00000000000000000000000',
      '000000000000000000000000',
      '0000000000000000000000000'
    ];
    var groupSizes = [
      0, 0,
      25, 16, 12, 11, 10, 9, 8,
      8, 7, 7, 7, 7, 6, 6,
      6, 6, 6, 6, 6, 5, 5,
      5, 5, 5, 5, 5, 5, 5,
      5, 5, 5, 5, 5, 5, 5
    ];
    var groupBases = [
      0, 0,
      33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
      43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
      16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
      6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
      24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
    ];
    BN.prototype.toString = function toString (base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;
      if (base === 16 || base === 'hex') {
        out = '';
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = (((w << off) | carry) & 0xffffff).toString(16);
          carry = (w >>> (24 - off)) & 0xffffff;
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = '0' + out;
        }
        if (this.negative !== 0) {
          out = '-' + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = '';
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = '0' + out;
        }
        while (out.length % padding !== 0) {
          out = '0' + out;
        }
        if (this.negative !== 0) {
          out = '-' + out;
        }
        return out;
      }
      assert(false, 'Base should be between 2 and 36');
    };
    BN.prototype.toNumber = function toNumber () {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 0x4000000;
      } else if (this.length === 3 && this.words[2] === 0x01) {
        ret += 0x10000000000000 + (this.words[1] * 0x4000000);
      } else if (this.length > 2) {
        assert(false, 'Number can only safely store up to 53 bits');
      }
      return (this.negative !== 0) ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON () {
      return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      assert(typeof Buffer !== 'undefined');
      return this.toArrayLike(Buffer, endian, length);
    };
    BN.prototype.toArray = function toArray (endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, 'byte array longer than desired length');
      assert(reqLength > 0, 'Requested array length <= 0');
      this.strip();
      var littleEndian = endian === 'le';
      var res = new ArrayType(reqLength);
      var b, i;
      var q = this.clone();
      if (!littleEndian) {
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(0xff);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(0xff);
          q.iushrn(8);
          res[i] = b;
        }
        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits (w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits (w) {
        var t = w;
        var r = 0;
        if (t >= 0x1000) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 0x40) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 0x8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 0x02) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits (w) {
      if (w === 0) return 26;
      var t = w;
      var r = 0;
      if ((t & 0x1fff) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 0x7f) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 0xf) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 0x3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 0x1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength () {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray (num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = (bit / 26) | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits () {
      if (this.isZero()) return 0;
      var r = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26) break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength () {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos (width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos (width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg () {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg () {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg () {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor (num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this.strip();
    };
    BN.prototype.ior = function ior (num) {
      assert((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or (num) {
      if (this.length > num.length) return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor (num) {
      if (this.length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand (num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this.strip();
    };
    BN.prototype.iand = function iand (num) {
      assert((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and (num) {
      if (this.length > num.length) return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand (num) {
      if (this.length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor (num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this.strip();
    };
    BN.prototype.ixor = function ixor (num) {
      assert((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor (num) {
      if (this.length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor (num) {
      if (this.length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn (width) {
      assert(typeof width === 'number' && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 0x3ffffff;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
      }
      return this.strip();
    };
    BN.prototype.notn = function notn (width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn (bit, val) {
      assert(typeof bit === 'number' && bit >= 0);
      var off = (bit / 26) | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | (1 << wbit);
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN.prototype.iadd = function iadd (num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 0x3ffffff;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN.prototype.add = function add (num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub (num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 0x3ffffff;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN.prototype.sub = function sub (num) {
      return this.clone().isub(num);
    };
    function smallMulTo (self, num, out) {
      out.negative = num.negative ^ self.negative;
      var len = (self.length + num.length) | 0;
      out.length = len;
      len = (len - 1) | 0;
      var a = self.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 0x3ffffff;
      var carry = (r / 0x4000000) | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = (k - j) | 0;
          a = self.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += (r / 0x4000000) | 0;
          rword = r & 0x3ffffff;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo (self, num, out) {
      var a = self.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 0x1fff;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 0x1fff;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 0x1fff;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 0x1fff;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 0x1fff;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 0x1fff;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 0x1fff;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 0x1fff;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 0x1fff;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 0x1fff;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 0x1fff;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 0x1fff;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 0x1fff;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 0x1fff;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 0x1fff;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 0x1fff;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 0x1fff;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 0x1fff;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 0x1fff;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 0x1fff;
      var bh9 = b9 >>> 13;
      out.negative = self.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = (mid + Math.imul(ah0, bl0)) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
      w0 &= 0x3ffffff;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = (mid + Math.imul(ah1, bl0)) | 0;
      hi = Math.imul(ah1, bh0);
      lo = (lo + Math.imul(al0, bl1)) | 0;
      mid = (mid + Math.imul(al0, bh1)) | 0;
      mid = (mid + Math.imul(ah0, bl1)) | 0;
      hi = (hi + Math.imul(ah0, bh1)) | 0;
      var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
      w1 &= 0x3ffffff;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = (mid + Math.imul(ah2, bl0)) | 0;
      hi = Math.imul(ah2, bh0);
      lo = (lo + Math.imul(al1, bl1)) | 0;
      mid = (mid + Math.imul(al1, bh1)) | 0;
      mid = (mid + Math.imul(ah1, bl1)) | 0;
      hi = (hi + Math.imul(ah1, bh1)) | 0;
      lo = (lo + Math.imul(al0, bl2)) | 0;
      mid = (mid + Math.imul(al0, bh2)) | 0;
      mid = (mid + Math.imul(ah0, bl2)) | 0;
      hi = (hi + Math.imul(ah0, bh2)) | 0;
      var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
      w2 &= 0x3ffffff;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = (mid + Math.imul(ah3, bl0)) | 0;
      hi = Math.imul(ah3, bh0);
      lo = (lo + Math.imul(al2, bl1)) | 0;
      mid = (mid + Math.imul(al2, bh1)) | 0;
      mid = (mid + Math.imul(ah2, bl1)) | 0;
      hi = (hi + Math.imul(ah2, bh1)) | 0;
      lo = (lo + Math.imul(al1, bl2)) | 0;
      mid = (mid + Math.imul(al1, bh2)) | 0;
      mid = (mid + Math.imul(ah1, bl2)) | 0;
      hi = (hi + Math.imul(ah1, bh2)) | 0;
      lo = (lo + Math.imul(al0, bl3)) | 0;
      mid = (mid + Math.imul(al0, bh3)) | 0;
      mid = (mid + Math.imul(ah0, bl3)) | 0;
      hi = (hi + Math.imul(ah0, bh3)) | 0;
      var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
      w3 &= 0x3ffffff;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = (mid + Math.imul(ah4, bl0)) | 0;
      hi = Math.imul(ah4, bh0);
      lo = (lo + Math.imul(al3, bl1)) | 0;
      mid = (mid + Math.imul(al3, bh1)) | 0;
      mid = (mid + Math.imul(ah3, bl1)) | 0;
      hi = (hi + Math.imul(ah3, bh1)) | 0;
      lo = (lo + Math.imul(al2, bl2)) | 0;
      mid = (mid + Math.imul(al2, bh2)) | 0;
      mid = (mid + Math.imul(ah2, bl2)) | 0;
      hi = (hi + Math.imul(ah2, bh2)) | 0;
      lo = (lo + Math.imul(al1, bl3)) | 0;
      mid = (mid + Math.imul(al1, bh3)) | 0;
      mid = (mid + Math.imul(ah1, bl3)) | 0;
      hi = (hi + Math.imul(ah1, bh3)) | 0;
      lo = (lo + Math.imul(al0, bl4)) | 0;
      mid = (mid + Math.imul(al0, bh4)) | 0;
      mid = (mid + Math.imul(ah0, bl4)) | 0;
      hi = (hi + Math.imul(ah0, bh4)) | 0;
      var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
      w4 &= 0x3ffffff;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = (mid + Math.imul(ah5, bl0)) | 0;
      hi = Math.imul(ah5, bh0);
      lo = (lo + Math.imul(al4, bl1)) | 0;
      mid = (mid + Math.imul(al4, bh1)) | 0;
      mid = (mid + Math.imul(ah4, bl1)) | 0;
      hi = (hi + Math.imul(ah4, bh1)) | 0;
      lo = (lo + Math.imul(al3, bl2)) | 0;
      mid = (mid + Math.imul(al3, bh2)) | 0;
      mid = (mid + Math.imul(ah3, bl2)) | 0;
      hi = (hi + Math.imul(ah3, bh2)) | 0;
      lo = (lo + Math.imul(al2, bl3)) | 0;
      mid = (mid + Math.imul(al2, bh3)) | 0;
      mid = (mid + Math.imul(ah2, bl3)) | 0;
      hi = (hi + Math.imul(ah2, bh3)) | 0;
      lo = (lo + Math.imul(al1, bl4)) | 0;
      mid = (mid + Math.imul(al1, bh4)) | 0;
      mid = (mid + Math.imul(ah1, bl4)) | 0;
      hi = (hi + Math.imul(ah1, bh4)) | 0;
      lo = (lo + Math.imul(al0, bl5)) | 0;
      mid = (mid + Math.imul(al0, bh5)) | 0;
      mid = (mid + Math.imul(ah0, bl5)) | 0;
      hi = (hi + Math.imul(ah0, bh5)) | 0;
      var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
      w5 &= 0x3ffffff;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = (mid + Math.imul(ah6, bl0)) | 0;
      hi = Math.imul(ah6, bh0);
      lo = (lo + Math.imul(al5, bl1)) | 0;
      mid = (mid + Math.imul(al5, bh1)) | 0;
      mid = (mid + Math.imul(ah5, bl1)) | 0;
      hi = (hi + Math.imul(ah5, bh1)) | 0;
      lo = (lo + Math.imul(al4, bl2)) | 0;
      mid = (mid + Math.imul(al4, bh2)) | 0;
      mid = (mid + Math.imul(ah4, bl2)) | 0;
      hi = (hi + Math.imul(ah4, bh2)) | 0;
      lo = (lo + Math.imul(al3, bl3)) | 0;
      mid = (mid + Math.imul(al3, bh3)) | 0;
      mid = (mid + Math.imul(ah3, bl3)) | 0;
      hi = (hi + Math.imul(ah3, bh3)) | 0;
      lo = (lo + Math.imul(al2, bl4)) | 0;
      mid = (mid + Math.imul(al2, bh4)) | 0;
      mid = (mid + Math.imul(ah2, bl4)) | 0;
      hi = (hi + Math.imul(ah2, bh4)) | 0;
      lo = (lo + Math.imul(al1, bl5)) | 0;
      mid = (mid + Math.imul(al1, bh5)) | 0;
      mid = (mid + Math.imul(ah1, bl5)) | 0;
      hi = (hi + Math.imul(ah1, bh5)) | 0;
      lo = (lo + Math.imul(al0, bl6)) | 0;
      mid = (mid + Math.imul(al0, bh6)) | 0;
      mid = (mid + Math.imul(ah0, bl6)) | 0;
      hi = (hi + Math.imul(ah0, bh6)) | 0;
      var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
      w6 &= 0x3ffffff;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = (mid + Math.imul(ah7, bl0)) | 0;
      hi = Math.imul(ah7, bh0);
      lo = (lo + Math.imul(al6, bl1)) | 0;
      mid = (mid + Math.imul(al6, bh1)) | 0;
      mid = (mid + Math.imul(ah6, bl1)) | 0;
      hi = (hi + Math.imul(ah6, bh1)) | 0;
      lo = (lo + Math.imul(al5, bl2)) | 0;
      mid = (mid + Math.imul(al5, bh2)) | 0;
      mid = (mid + Math.imul(ah5, bl2)) | 0;
      hi = (hi + Math.imul(ah5, bh2)) | 0;
      lo = (lo + Math.imul(al4, bl3)) | 0;
      mid = (mid + Math.imul(al4, bh3)) | 0;
      mid = (mid + Math.imul(ah4, bl3)) | 0;
      hi = (hi + Math.imul(ah4, bh3)) | 0;
      lo = (lo + Math.imul(al3, bl4)) | 0;
      mid = (mid + Math.imul(al3, bh4)) | 0;
      mid = (mid + Math.imul(ah3, bl4)) | 0;
      hi = (hi + Math.imul(ah3, bh4)) | 0;
      lo = (lo + Math.imul(al2, bl5)) | 0;
      mid = (mid + Math.imul(al2, bh5)) | 0;
      mid = (mid + Math.imul(ah2, bl5)) | 0;
      hi = (hi + Math.imul(ah2, bh5)) | 0;
      lo = (lo + Math.imul(al1, bl6)) | 0;
      mid = (mid + Math.imul(al1, bh6)) | 0;
      mid = (mid + Math.imul(ah1, bl6)) | 0;
      hi = (hi + Math.imul(ah1, bh6)) | 0;
      lo = (lo + Math.imul(al0, bl7)) | 0;
      mid = (mid + Math.imul(al0, bh7)) | 0;
      mid = (mid + Math.imul(ah0, bl7)) | 0;
      hi = (hi + Math.imul(ah0, bh7)) | 0;
      var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
      w7 &= 0x3ffffff;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = (mid + Math.imul(ah8, bl0)) | 0;
      hi = Math.imul(ah8, bh0);
      lo = (lo + Math.imul(al7, bl1)) | 0;
      mid = (mid + Math.imul(al7, bh1)) | 0;
      mid = (mid + Math.imul(ah7, bl1)) | 0;
      hi = (hi + Math.imul(ah7, bh1)) | 0;
      lo = (lo + Math.imul(al6, bl2)) | 0;
      mid = (mid + Math.imul(al6, bh2)) | 0;
      mid = (mid + Math.imul(ah6, bl2)) | 0;
      hi = (hi + Math.imul(ah6, bh2)) | 0;
      lo = (lo + Math.imul(al5, bl3)) | 0;
      mid = (mid + Math.imul(al5, bh3)) | 0;
      mid = (mid + Math.imul(ah5, bl3)) | 0;
      hi = (hi + Math.imul(ah5, bh3)) | 0;
      lo = (lo + Math.imul(al4, bl4)) | 0;
      mid = (mid + Math.imul(al4, bh4)) | 0;
      mid = (mid + Math.imul(ah4, bl4)) | 0;
      hi = (hi + Math.imul(ah4, bh4)) | 0;
      lo = (lo + Math.imul(al3, bl5)) | 0;
      mid = (mid + Math.imul(al3, bh5)) | 0;
      mid = (mid + Math.imul(ah3, bl5)) | 0;
      hi = (hi + Math.imul(ah3, bh5)) | 0;
      lo = (lo + Math.imul(al2, bl6)) | 0;
      mid = (mid + Math.imul(al2, bh6)) | 0;
      mid = (mid + Math.imul(ah2, bl6)) | 0;
      hi = (hi + Math.imul(ah2, bh6)) | 0;
      lo = (lo + Math.imul(al1, bl7)) | 0;
      mid = (mid + Math.imul(al1, bh7)) | 0;
      mid = (mid + Math.imul(ah1, bl7)) | 0;
      hi = (hi + Math.imul(ah1, bh7)) | 0;
      lo = (lo + Math.imul(al0, bl8)) | 0;
      mid = (mid + Math.imul(al0, bh8)) | 0;
      mid = (mid + Math.imul(ah0, bl8)) | 0;
      hi = (hi + Math.imul(ah0, bh8)) | 0;
      var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
      w8 &= 0x3ffffff;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = (mid + Math.imul(ah9, bl0)) | 0;
      hi = Math.imul(ah9, bh0);
      lo = (lo + Math.imul(al8, bl1)) | 0;
      mid = (mid + Math.imul(al8, bh1)) | 0;
      mid = (mid + Math.imul(ah8, bl1)) | 0;
      hi = (hi + Math.imul(ah8, bh1)) | 0;
      lo = (lo + Math.imul(al7, bl2)) | 0;
      mid = (mid + Math.imul(al7, bh2)) | 0;
      mid = (mid + Math.imul(ah7, bl2)) | 0;
      hi = (hi + Math.imul(ah7, bh2)) | 0;
      lo = (lo + Math.imul(al6, bl3)) | 0;
      mid = (mid + Math.imul(al6, bh3)) | 0;
      mid = (mid + Math.imul(ah6, bl3)) | 0;
      hi = (hi + Math.imul(ah6, bh3)) | 0;
      lo = (lo + Math.imul(al5, bl4)) | 0;
      mid = (mid + Math.imul(al5, bh4)) | 0;
      mid = (mid + Math.imul(ah5, bl4)) | 0;
      hi = (hi + Math.imul(ah5, bh4)) | 0;
      lo = (lo + Math.imul(al4, bl5)) | 0;
      mid = (mid + Math.imul(al4, bh5)) | 0;
      mid = (mid + Math.imul(ah4, bl5)) | 0;
      hi = (hi + Math.imul(ah4, bh5)) | 0;
      lo = (lo + Math.imul(al3, bl6)) | 0;
      mid = (mid + Math.imul(al3, bh6)) | 0;
      mid = (mid + Math.imul(ah3, bl6)) | 0;
      hi = (hi + Math.imul(ah3, bh6)) | 0;
      lo = (lo + Math.imul(al2, bl7)) | 0;
      mid = (mid + Math.imul(al2, bh7)) | 0;
      mid = (mid + Math.imul(ah2, bl7)) | 0;
      hi = (hi + Math.imul(ah2, bh7)) | 0;
      lo = (lo + Math.imul(al1, bl8)) | 0;
      mid = (mid + Math.imul(al1, bh8)) | 0;
      mid = (mid + Math.imul(ah1, bl8)) | 0;
      hi = (hi + Math.imul(ah1, bh8)) | 0;
      lo = (lo + Math.imul(al0, bl9)) | 0;
      mid = (mid + Math.imul(al0, bh9)) | 0;
      mid = (mid + Math.imul(ah0, bl9)) | 0;
      hi = (hi + Math.imul(ah0, bh9)) | 0;
      var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
      w9 &= 0x3ffffff;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = (mid + Math.imul(ah9, bl1)) | 0;
      hi = Math.imul(ah9, bh1);
      lo = (lo + Math.imul(al8, bl2)) | 0;
      mid = (mid + Math.imul(al8, bh2)) | 0;
      mid = (mid + Math.imul(ah8, bl2)) | 0;
      hi = (hi + Math.imul(ah8, bh2)) | 0;
      lo = (lo + Math.imul(al7, bl3)) | 0;
      mid = (mid + Math.imul(al7, bh3)) | 0;
      mid = (mid + Math.imul(ah7, bl3)) | 0;
      hi = (hi + Math.imul(ah7, bh3)) | 0;
      lo = (lo + Math.imul(al6, bl4)) | 0;
      mid = (mid + Math.imul(al6, bh4)) | 0;
      mid = (mid + Math.imul(ah6, bl4)) | 0;
      hi = (hi + Math.imul(ah6, bh4)) | 0;
      lo = (lo + Math.imul(al5, bl5)) | 0;
      mid = (mid + Math.imul(al5, bh5)) | 0;
      mid = (mid + Math.imul(ah5, bl5)) | 0;
      hi = (hi + Math.imul(ah5, bh5)) | 0;
      lo = (lo + Math.imul(al4, bl6)) | 0;
      mid = (mid + Math.imul(al4, bh6)) | 0;
      mid = (mid + Math.imul(ah4, bl6)) | 0;
      hi = (hi + Math.imul(ah4, bh6)) | 0;
      lo = (lo + Math.imul(al3, bl7)) | 0;
      mid = (mid + Math.imul(al3, bh7)) | 0;
      mid = (mid + Math.imul(ah3, bl7)) | 0;
      hi = (hi + Math.imul(ah3, bh7)) | 0;
      lo = (lo + Math.imul(al2, bl8)) | 0;
      mid = (mid + Math.imul(al2, bh8)) | 0;
      mid = (mid + Math.imul(ah2, bl8)) | 0;
      hi = (hi + Math.imul(ah2, bh8)) | 0;
      lo = (lo + Math.imul(al1, bl9)) | 0;
      mid = (mid + Math.imul(al1, bh9)) | 0;
      mid = (mid + Math.imul(ah1, bl9)) | 0;
      hi = (hi + Math.imul(ah1, bh9)) | 0;
      var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
      w10 &= 0x3ffffff;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = (mid + Math.imul(ah9, bl2)) | 0;
      hi = Math.imul(ah9, bh2);
      lo = (lo + Math.imul(al8, bl3)) | 0;
      mid = (mid + Math.imul(al8, bh3)) | 0;
      mid = (mid + Math.imul(ah8, bl3)) | 0;
      hi = (hi + Math.imul(ah8, bh3)) | 0;
      lo = (lo + Math.imul(al7, bl4)) | 0;
      mid = (mid + Math.imul(al7, bh4)) | 0;
      mid = (mid + Math.imul(ah7, bl4)) | 0;
      hi = (hi + Math.imul(ah7, bh4)) | 0;
      lo = (lo + Math.imul(al6, bl5)) | 0;
      mid = (mid + Math.imul(al6, bh5)) | 0;
      mid = (mid + Math.imul(ah6, bl5)) | 0;
      hi = (hi + Math.imul(ah6, bh5)) | 0;
      lo = (lo + Math.imul(al5, bl6)) | 0;
      mid = (mid + Math.imul(al5, bh6)) | 0;
      mid = (mid + Math.imul(ah5, bl6)) | 0;
      hi = (hi + Math.imul(ah5, bh6)) | 0;
      lo = (lo + Math.imul(al4, bl7)) | 0;
      mid = (mid + Math.imul(al4, bh7)) | 0;
      mid = (mid + Math.imul(ah4, bl7)) | 0;
      hi = (hi + Math.imul(ah4, bh7)) | 0;
      lo = (lo + Math.imul(al3, bl8)) | 0;
      mid = (mid + Math.imul(al3, bh8)) | 0;
      mid = (mid + Math.imul(ah3, bl8)) | 0;
      hi = (hi + Math.imul(ah3, bh8)) | 0;
      lo = (lo + Math.imul(al2, bl9)) | 0;
      mid = (mid + Math.imul(al2, bh9)) | 0;
      mid = (mid + Math.imul(ah2, bl9)) | 0;
      hi = (hi + Math.imul(ah2, bh9)) | 0;
      var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
      w11 &= 0x3ffffff;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = (mid + Math.imul(ah9, bl3)) | 0;
      hi = Math.imul(ah9, bh3);
      lo = (lo + Math.imul(al8, bl4)) | 0;
      mid = (mid + Math.imul(al8, bh4)) | 0;
      mid = (mid + Math.imul(ah8, bl4)) | 0;
      hi = (hi + Math.imul(ah8, bh4)) | 0;
      lo = (lo + Math.imul(al7, bl5)) | 0;
      mid = (mid + Math.imul(al7, bh5)) | 0;
      mid = (mid + Math.imul(ah7, bl5)) | 0;
      hi = (hi + Math.imul(ah7, bh5)) | 0;
      lo = (lo + Math.imul(al6, bl6)) | 0;
      mid = (mid + Math.imul(al6, bh6)) | 0;
      mid = (mid + Math.imul(ah6, bl6)) | 0;
      hi = (hi + Math.imul(ah6, bh6)) | 0;
      lo = (lo + Math.imul(al5, bl7)) | 0;
      mid = (mid + Math.imul(al5, bh7)) | 0;
      mid = (mid + Math.imul(ah5, bl7)) | 0;
      hi = (hi + Math.imul(ah5, bh7)) | 0;
      lo = (lo + Math.imul(al4, bl8)) | 0;
      mid = (mid + Math.imul(al4, bh8)) | 0;
      mid = (mid + Math.imul(ah4, bl8)) | 0;
      hi = (hi + Math.imul(ah4, bh8)) | 0;
      lo = (lo + Math.imul(al3, bl9)) | 0;
      mid = (mid + Math.imul(al3, bh9)) | 0;
      mid = (mid + Math.imul(ah3, bl9)) | 0;
      hi = (hi + Math.imul(ah3, bh9)) | 0;
      var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
      w12 &= 0x3ffffff;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = (mid + Math.imul(ah9, bl4)) | 0;
      hi = Math.imul(ah9, bh4);
      lo = (lo + Math.imul(al8, bl5)) | 0;
      mid = (mid + Math.imul(al8, bh5)) | 0;
      mid = (mid + Math.imul(ah8, bl5)) | 0;
      hi = (hi + Math.imul(ah8, bh5)) | 0;
      lo = (lo + Math.imul(al7, bl6)) | 0;
      mid = (mid + Math.imul(al7, bh6)) | 0;
      mid = (mid + Math.imul(ah7, bl6)) | 0;
      hi = (hi + Math.imul(ah7, bh6)) | 0;
      lo = (lo + Math.imul(al6, bl7)) | 0;
      mid = (mid + Math.imul(al6, bh7)) | 0;
      mid = (mid + Math.imul(ah6, bl7)) | 0;
      hi = (hi + Math.imul(ah6, bh7)) | 0;
      lo = (lo + Math.imul(al5, bl8)) | 0;
      mid = (mid + Math.imul(al5, bh8)) | 0;
      mid = (mid + Math.imul(ah5, bl8)) | 0;
      hi = (hi + Math.imul(ah5, bh8)) | 0;
      lo = (lo + Math.imul(al4, bl9)) | 0;
      mid = (mid + Math.imul(al4, bh9)) | 0;
      mid = (mid + Math.imul(ah4, bl9)) | 0;
      hi = (hi + Math.imul(ah4, bh9)) | 0;
      var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
      w13 &= 0x3ffffff;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = (mid + Math.imul(ah9, bl5)) | 0;
      hi = Math.imul(ah9, bh5);
      lo = (lo + Math.imul(al8, bl6)) | 0;
      mid = (mid + Math.imul(al8, bh6)) | 0;
      mid = (mid + Math.imul(ah8, bl6)) | 0;
      hi = (hi + Math.imul(ah8, bh6)) | 0;
      lo = (lo + Math.imul(al7, bl7)) | 0;
      mid = (mid + Math.imul(al7, bh7)) | 0;
      mid = (mid + Math.imul(ah7, bl7)) | 0;
      hi = (hi + Math.imul(ah7, bh7)) | 0;
      lo = (lo + Math.imul(al6, bl8)) | 0;
      mid = (mid + Math.imul(al6, bh8)) | 0;
      mid = (mid + Math.imul(ah6, bl8)) | 0;
      hi = (hi + Math.imul(ah6, bh8)) | 0;
      lo = (lo + Math.imul(al5, bl9)) | 0;
      mid = (mid + Math.imul(al5, bh9)) | 0;
      mid = (mid + Math.imul(ah5, bl9)) | 0;
      hi = (hi + Math.imul(ah5, bh9)) | 0;
      var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
      w14 &= 0x3ffffff;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = (mid + Math.imul(ah9, bl6)) | 0;
      hi = Math.imul(ah9, bh6);
      lo = (lo + Math.imul(al8, bl7)) | 0;
      mid = (mid + Math.imul(al8, bh7)) | 0;
      mid = (mid + Math.imul(ah8, bl7)) | 0;
      hi = (hi + Math.imul(ah8, bh7)) | 0;
      lo = (lo + Math.imul(al7, bl8)) | 0;
      mid = (mid + Math.imul(al7, bh8)) | 0;
      mid = (mid + Math.imul(ah7, bl8)) | 0;
      hi = (hi + Math.imul(ah7, bh8)) | 0;
      lo = (lo + Math.imul(al6, bl9)) | 0;
      mid = (mid + Math.imul(al6, bh9)) | 0;
      mid = (mid + Math.imul(ah6, bl9)) | 0;
      hi = (hi + Math.imul(ah6, bh9)) | 0;
      var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
      w15 &= 0x3ffffff;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = (mid + Math.imul(ah9, bl7)) | 0;
      hi = Math.imul(ah9, bh7);
      lo = (lo + Math.imul(al8, bl8)) | 0;
      mid = (mid + Math.imul(al8, bh8)) | 0;
      mid = (mid + Math.imul(ah8, bl8)) | 0;
      hi = (hi + Math.imul(ah8, bh8)) | 0;
      lo = (lo + Math.imul(al7, bl9)) | 0;
      mid = (mid + Math.imul(al7, bh9)) | 0;
      mid = (mid + Math.imul(ah7, bl9)) | 0;
      hi = (hi + Math.imul(ah7, bh9)) | 0;
      var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
      w16 &= 0x3ffffff;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = (mid + Math.imul(ah9, bl8)) | 0;
      hi = Math.imul(ah9, bh8);
      lo = (lo + Math.imul(al8, bl9)) | 0;
      mid = (mid + Math.imul(al8, bh9)) | 0;
      mid = (mid + Math.imul(ah8, bl9)) | 0;
      hi = (hi + Math.imul(ah8, bh9)) | 0;
      var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
      w17 &= 0x3ffffff;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = (mid + Math.imul(ah9, bl9)) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
      c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
      w18 &= 0x3ffffff;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo (self, num, out) {
      out.negative = num.negative ^ self.negative;
      out.length = self.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 0x3ffffff;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 0x3ffffff;
          ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
          lo = (lo + rword) | 0;
          rword = lo & 0x3ffffff;
          ncarry = (ncarry + (lo >>> 26)) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 0x3ffffff;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo (self, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self, num, out);
    }
    BN.prototype.mulTo = function mulTo (num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM (x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT (N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin (x, l, N) {
      if (x === 0 || x === N - 1) return x;
      var rb = 0;
      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << (l - i - 1);
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
      if (N <= 1) return;
      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b (ws, N) {
      var carry = 0;
      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
          Math.round(ws[2 * i] / N) +
          carry;
        ws[i] = w & 0x3ffffff;
        if (w < 0x4000000) {
          carry = 0;
        } else {
          carry = w / 0x4000000 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
      var carry = 0;
      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
        rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
      }
      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }
      assert(carry === 0);
      assert((carry & ~0x1fff) === 0);
    };
    FFTM.prototype.stub = function stub (N) {
      var ph = new Array(N);
      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp (x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _ = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);
      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    };
    BN.prototype.mul = function mul (num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf (num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul (num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln (num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
        carry >>= 26;
        carry += (w / 0x4000000) | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 0x3ffffff;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.muln = function muln (num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr () {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr () {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow (num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN(1);
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln (bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = ((this.words[i] | 0) - newCarry) << r;
          this.words[i] = c | carry;
          carry = newCarry >>> (26 - r);
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0; i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this.strip();
    };
    BN.prototype.ishln = function ishln (bits) {
      assert(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn (bits, hint, extended) {
      assert(typeof bits === 'number' && bits >= 0);
      var h;
      if (hint) {
        h = (hint - (hint % 26)) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) ; else if (this.length > s) {
        this.length -= s;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = (carry << (26 - r)) | (word >>> r);
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN.prototype.ishrn = function ishrn (bits, hint, extended) {
      assert(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln (bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln (bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn (bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn (bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn (bit) {
      assert(typeof bit === 'number' && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn (bits) {
      assert(typeof bits === 'number' && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert(this.negative === 0, 'imaskn works only with positive numbers');
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN.prototype.maskn = function maskn (bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn (num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      if (num < 0) return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn (num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
        this.words[i] -= 0x4000000;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn (num) {
      assert(typeof num === 'number');
      assert(num < 0x4000000);
      if (num < 0) return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 0x4000000;
          this.words[i + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN.prototype.addn = function addn (num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn (num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs () {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs () {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 0x3ffffff;
        carry = (w >> 26) - ((right / 0x4000000) | 0);
        this.words[i + shift] = w & 0x3ffffff;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 0x3ffffff;
      }
      if (carry === 0) return this.strip();
      assert(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 0x3ffffff;
      }
      this.negative = 1;
      return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv (num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== 'mod') {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 0x4000000 +
          (a.words[b.length + j - 1] | 0);
        qj = Math.min((qj / bhi) | 0, 0x3ffffff);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a.strip();
      if (mode !== 'div' && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod (num, mode, positive) {
      assert(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== 'mod') {
          div = res.div.neg();
        }
        if (mode !== 'div') {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div: div,
          mod: mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== 'mod') {
          div = res.div.neg();
        }
        return {
          div: div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== 'div') {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod: mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === 'div') {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === 'mod') {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div (num) {
      return this.divmod(num, 'div', false).div;
    };
    BN.prototype.mod = function mod (num) {
      return this.divmod(num, 'mod', false).mod;
    };
    BN.prototype.umod = function umod (num) {
      return this.divmod(num, 'mod', true).mod;
    };
    BN.prototype.divRound = function divRound (num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero()) return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn (num) {
      assert(num <= 0x3ffffff);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return acc;
    };
    BN.prototype.idivn = function idivn (num) {
      assert(num <= 0x3ffffff);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 0x4000000;
        this.words[i] = (w / num) | 0;
        carry = w % num;
      }
      return this.strip();
    };
    BN.prototype.divn = function divn (num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd (p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN.prototype._invmp = function _invmp (p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd (num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN.prototype.invm = function invm (num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven () {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd () {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln (num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn (bit) {
      assert(typeof bit === 'number');
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 0x3ffffff;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero () {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn (num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative) return -1;
      if (this.negative === 0 && negative) return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert(num <= 0x3ffffff, 'Number is too big');
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp (num) {
      if (this.negative !== 0 && num.negative === 0) return -1;
      if (this.negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0) return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp (num) {
      if (this.length > num.length) return 1;
      if (this.length < num.length) return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn (num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt (num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten (num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte (num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn (num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt (num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten (num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte (num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn (num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq (num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red (num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed (ctx) {
      assert(!this.red, 'Already a number in reduction context');
      assert(this.negative === 0, 'red works only with positives');
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed () {
      assert(this.red, 'fromRed works only with numbers in reduction context');
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed (ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed (ctx) {
      assert(!this.red, 'Already a number in reduction context');
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd (num) {
      assert(this.red, 'redAdd works only with red numbers');
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd (num) {
      assert(this.red, 'redIAdd works only with red numbers');
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub (num) {
      assert(this.red, 'redSub works only with red numbers');
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub (num) {
      assert(this.red, 'redISub works only with red numbers');
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl (num) {
      assert(this.red, 'redShl works only with red numbers');
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul (num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul (num) {
      assert(this.red, 'redMul works only with red numbers');
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr () {
      assert(this.red, 'redSqr works only with red numbers');
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr () {
      assert(this.red, 'redISqr works only with red numbers');
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt () {
      assert(this.red, 'redSqrt works only with red numbers');
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm () {
      assert(this.red, 'redInvm works only with red numbers');
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg () {
      assert(this.red, 'redNeg works only with red numbers');
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow (num) {
      assert(this.red && !num.red, 'redPow(normalNum)');
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime (name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp () {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce (num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== undefined) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split (input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK (num) {
      return num.imul(this.k);
    };
    function K256 () {
      MPrime.call(
        this,
        'k256',
        'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split (input, output) {
      var mask = 0x3fffff;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK (num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 0x3d1;
        num.words[i] = lo & 0x3ffffff;
        lo = w * 0x40 + ((lo / 0x4000000) | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224 () {
      MPrime.call(
        this,
        'p224',
        'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);
    function P192 () {
      MPrime.call(
        this,
        'p192',
        'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);
    function P25519 () {
      MPrime.call(
        this,
        '25519',
        '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK (num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 0x13 + carry;
        var lo = hi & 0x3ffffff;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime (name) {
      if (primes[name]) return primes[name];
      var prime;
      if (name === 'k256') {
        prime = new K256();
      } else if (name === 'p224') {
        prime = new P224();
      } else if (name === 'p192') {
        prime = new P192();
      } else if (name === 'p25519') {
        prime = new P25519();
      } else {
        throw new Error('Unknown prime ' + name);
      }
      primes[name] = prime;
      return prime;
    };
    function Red (m) {
      if (typeof m === 'string') {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert(m.gtn(1), 'modulus must be greater than 1');
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1 (a) {
      assert(a.negative === 0, 'red works only with positives');
      assert(a.red, 'red works only with red numbers');
    };
    Red.prototype._verify2 = function _verify2 (a, b) {
      assert((a.negative | b.negative) === 0, 'red works only with positives');
      assert(a.red && a.red === b.red,
        'red works only with red numbers');
    };
    Red.prototype.imod = function imod (a) {
      if (this.prime) return this.prime.ireduce(a)._forceRed(this);
      return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg (a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add (a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd (a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub (a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub (a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl (a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul (a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul (a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr (a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr (a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt (a) {
      if (a.isZero()) return a.clone();
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm (a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow (a, num) {
      if (num.isZero()) return new BN(1).toRed(this);
      if (num.cmpn(1) === 0) return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = (word >> j) & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo (num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom (num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont (num) {
      return new Mont(num);
    };
    function Mont (m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - (this.shift % 26);
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo (num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom (num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul (a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul (a, b) {
      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm (a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(module, commonjsGlobal);
  }(bn));
  const BN$8 = bn.exports;

  const BN_ZERO = new BN$8(0);
  const BN_ONE = new BN$8(1);
  const BN_TWO = new BN$8(2);
  new BN$8(3);
  const BN_FOUR = new BN$8(4);
  new BN$8(5);
  new BN$8(6);
  new BN$8(7);
  new BN$8(8);
  new BN$8(9);
  new BN$8(10);
  const BN_HUNDRED = new BN$8(100);
  new BN$8(1000);
  const BN_MILLION = new BN$8(1000000);
  const BN_BILLION = new BN$8(1000000000);
  const BN_QUINTILL = BN_BILLION.mul(BN_BILLION);
  new BN$8(Number.MAX_SAFE_INTEGER);

  function isBoolean$1(value) {
    return typeof value === 'boolean';
  }

  function objectSpread$1(dest, ...sources) {
    for (let i = 0; i < sources.length; i++) {
      const src = sources[i];
      if (src) {
        const keys = Object.keys(src);
        for (let j = 0; j < keys.length; j++) {
          const key = keys[j];
          dest[key] = src[key];
        }
      }
    }
    return dest;
  }

  const HEX_REGEX$1 = /^0x[a-fA-F0-9]+$/;
  function isHex$1(value, bitLength = -1, ignoreLength = false) {
    return typeof value === 'string' && (value === '0x' || HEX_REGEX$1.test(value)) ? bitLength === -1 ? value.length % 2 === 0 || ignoreLength : value.length === 2 + Math.ceil(bitLength / 4) : false;
  }

  function hexHasPrefix$1(value) {
    return !!(value && isHex$1(value, -1, true) && value.substr(0, 2) === '0x');
  }

  const UNPREFIX_HEX_REGEX$1 = /^[a-fA-F0-9]+$/;
  function hexStripPrefix$1(value) {
    if (!value) {
      return '';
    } else if (hexHasPrefix$1(value)) {
      return value.substr(2);
    } else if (UNPREFIX_HEX_REGEX$1.test(value)) {
      return value;
    }
    throw new Error(`Invalid hex ${value} passed to hexStripPrefix`);
  }

  function reverse$1(value) {
    return (value.match(/.{1,2}/g) || []).reverse().join('');
  }
  function hexToBn$1(value, options = {
    isLe: false,
    isNegative: false
  }) {
    if (!value) {
      return new BN$8(0);
    }
    const _options = objectSpread$1({
      isLe: false,
      isNegative: false
    }, isBoolean$1(options) ? {
      isLe: options
    } : options);
    const _value = hexStripPrefix$1(value);
    const bn = new BN$8((_options.isLe ? reverse$1(_value) : _value) || '00', 16);
    return _options.isNegative ? bn.fromTwos(_value.length * 4) : bn;
  }

  function isBigInt$1(value) {
    return typeof value === 'bigint';
  }

  function isToBn$1(value) {
    return !!value && isFunction$1(value.toBn);
  }

  function bnToBn$1(value) {
    if (!value) {
      return new BN$8(0);
    } else if (isHex$1(value)) {
      return hexToBn$1(value.toString());
    } else if (isBigInt$1(value)) {
      return new BN$8(value.toString());
    }
    return BN$8.isBN(value) ? value : isToBn$1(value) ? value.toBn() : new BN$8(value);
  }

  function isNumber$1(value) {
    return typeof value === 'number';
  }

  function hexToU8a$1(_value, bitLength = -1) {
    if (!_value) {
      return new Uint8Array();
    }
    assert$h(isHex$1(_value), () => `Expected hex value to convert, found '${_value}'`);
    const value = hexStripPrefix$1(_value);
    const valLength = value.length / 2;
    const bufLength = Math.ceil(bitLength === -1 ? valLength : bitLength / 8);
    const result = new Uint8Array(bufLength);
    const offset = Math.max(0, bufLength - valLength);
    for (let index = 0; index < bufLength; index++) {
      result[index + offset] = parseInt(value.substr(index * 2, 2), 16);
    }
    return result;
  }

  function isBuffer$1(value) {
    return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);
  }

  function isU8a$1(value) {
    return value instanceof Uint8Array;
  }

  const encoder$1 = new TextEncoder$2();
  function stringToU8a$1(value) {
    return value ? encoder$1.encode(value.toString()) : new Uint8Array();
  }

  function u8aToU8a$1(value) {
    if (!value) {
      return new Uint8Array();
    } else if (isHex$1(value)) {
      return hexToU8a$1(value);
    } else if (isString$1(value)) {
      return stringToU8a$1(value);
    } else if (Array.isArray(value) || isBuffer$1(value)) {
      return new Uint8Array(value);
    }
    assert$h(isU8a$1(value), () => `Unable to convert ${value.toString()} (typeof ${typeof value}) to a Uint8Array`);
    return value;
  }

  function compare(a, b) {
    let i = 0;
    while (true) {
      const overA = i >= a.length;
      const overB = i >= b.length;
      if (overA && overB) {
        return 0;
      } else if (overA) {
        return -1;
      } else if (overB) {
        return 1;
      } else if (a[i] !== b[i]) {
        return a[i] > b[i] ? 1 : -1;
      }
      i++;
    }
  }
  function u8aCmp(a, b) {
    return compare(u8aToU8a$1(a), u8aToU8a$1(b));
  }

  function u8aConcat$1(...list) {
    let length = 0;
    let offset = 0;
    const u8as = new Array(list.length);
    for (let i = 0; i < list.length; i++) {
      u8as[i] = u8aToU8a$1(list[i]);
      length += u8as[i].length;
    }
    const result = new Uint8Array(length);
    for (let i = 0; i < u8as.length; i++) {
      result.set(u8as[i], offset);
      offset += u8as[i].length;
    }
    return result;
  }

  function equals(a, b) {
    return a.length === b.length && u8aCmp(a, b) === 0;
  }
  function u8aEq(a, b) {
    return equals(u8aToU8a$1(a), u8aToU8a$1(b));
  }

  const ALPHABET$1 = arrayRange$1(256).map(n => n.toString(16).padStart(2, '0'));
  function extract$1(value) {
    const result = new Array(value.length);
    for (let i = 0; i < value.length; i++) {
      result[i] = ALPHABET$1[value[i]];
    }
    return result.join('');
  }
  function unprefixed$1(value, bitLength = -1) {
    const byteLength = Math.ceil(bitLength / 8);
    return byteLength > 0 && value.length > byteLength ? trim$1(value, Math.ceil(byteLength / 2)) : extract$1(value);
  }
  function trim$1(value, halfLength) {
    return `${unprefixed$1(value.subarray(0, halfLength))}…${unprefixed$1(value.subarray(value.length - halfLength))}`;
  }
  function u8aToHex$1(value, bitLength = -1, isPrefixed = true) {
    return `${isPrefixed ? '0x' : ''}${!value || !value.length ? '' : unprefixed$1(value, bitLength)}`;
  }

  function u8aToBn(value, options = {
    isLe: true,
    isNegative: false
  }) {
    return hexToBn$1(u8aToHex$1(value), options);
  }

  const decoder$1 = new TextDecoder$2('utf-8');
  function u8aToString$1(value) {
    return !(value !== null && value !== void 0 && value.length) ? '' : decoder$1.decode(value);
  }

  function createEmpty$1(byteLength, options) {
    return options.bitLength === -1 ? new Uint8Array() : new Uint8Array(byteLength);
  }
  function createValue$2(valueBn, byteLength, {
    isLe,
    isNegative
  }) {
    const output = new Uint8Array(byteLength);
    const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
    output.set(bn.toArray(isLe ? 'le' : 'be', byteLength), 0);
    return output;
  }
  function bnToU8a$1(value, arg1 = {
    bitLength: -1,
    isLe: true,
    isNegative: false
  }, arg2) {
    const options = objectSpread$1({
      bitLength: -1,
      isLe: true,
      isNegative: false
    }, isNumber$1(arg1) ? {
      bitLength: arg1,
      isLe: arg2
    } : arg1);
    const valueBn = bnToBn$1(value);
    const byteLength = options.bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((options.bitLength || 0) / 8);
    return value ? createValue$2(valueBn, byteLength, options) : createEmpty$1(byteLength, options);
  }

  const ZERO_STR = '0x00';
  function bnToHex(value, arg1 = {
    bitLength: -1,
    isLe: false,
    isNegative: false
  }, arg2) {
    if (!value) {
      return ZERO_STR;
    }
    return u8aToHex$1(bnToU8a$1(value, objectSpread$1({
      isLe: false,
      isNegative: false
    }, isNumber$1(arg1) ? {
      bitLength: arg1,
      isLe: arg2
    } : arg1)));
  }

  const MAX_U8 = new BN$8(2).pow(new BN$8(8 - 2)).subn(1);
  const MAX_U16 = new BN$8(2).pow(new BN$8(16 - 2)).subn(1);
  const MAX_U32 = new BN$8(2).pow(new BN$8(32 - 2)).subn(1);
  function compactToU8a(_value) {
    const value = bnToBn$1(_value);
    if (value.lte(MAX_U8)) {
      return new Uint8Array([value.toNumber() << 2]);
    } else if (value.lte(MAX_U16)) {
      return bnToU8a$1(value.shln(2).iadd(BN_ONE), 16, true);
    } else if (value.lte(MAX_U32)) {
      return bnToU8a$1(value.shln(2).iadd(BN_TWO), 32, true);
    }
    const u8a = bnToU8a$1(value);
    let length = u8a.length;
    while (u8a[length - 1] === 0) {
      length--;
    }
    assert$h(length >= 4, 'Invalid length, previous checks match anything less than 2^30');
    return u8aConcat$1(
    [(length - 4 << 2) + 0b11], u8a.subarray(0, length));
  }

  function compactAddLength(input) {
    return u8aConcat$1(compactToU8a(input.length), input);
  }

  function compactFromU8a(_input) {
    const input = u8aToU8a$1(_input);
    const flag = input[0] & 0b11;
    if (flag === 0b00) {
      return [1, new BN$8(input[0]).ishrn(2)];
    } else if (flag === 0b01) {
      return [2, u8aToBn(input.slice(0, 2), true).ishrn(2)];
    } else if (flag === 0b10) {
      return [4, u8aToBn(input.slice(0, 4), true).ishrn(2)];
    }
    const offset = 1 + new BN$8(input[0]).ishrn(2)
    .iadd(BN_FOUR)
    .toNumber();
    return [offset, u8aToBn(input.subarray(1, offset), true)];
  }

  function compactStripLength(input) {
    const [offset, length] = compactFromU8a(input);
    const total = offset + length.toNumber();
    return [total, input.subarray(offset, total)];
  }

  const NUMBER_REGEX = new RegExp('(\\d+?)(?=(\\d{3})+(?!\\d)|$)', 'g');
  function formatDecimal(value) {
    const isNegative = value[0].startsWith('-');
    const matched = isNegative ? value.substr(1).match(NUMBER_REGEX) : value.match(NUMBER_REGEX);
    return matched ? `${isNegative ? '-' : ''}${matched.join(',')}` : value;
  }

  const SI_MID = 8;
  const SI = [{
    power: -24,
    text: 'yocto',
    value: 'y'
  }, {
    power: -21,
    text: 'zepto',
    value: 'z'
  }, {
    power: -18,
    text: 'atto',
    value: 'a'
  }, {
    power: -15,
    text: 'femto',
    value: 'f'
  }, {
    power: -12,
    text: 'pico',
    value: 'p'
  }, {
    power: -9,
    text: 'nano',
    value: 'n'
  }, {
    power: -6,
    text: 'micro',
    value: 'µ'
  }, {
    power: -3,
    text: 'milli',
    value: 'm'
  }, {
    power: 0,
    text: 'Unit',
    value: '-'
  },
  {
    power: 3,
    text: 'Kilo',
    value: 'k'
  }, {
    power: 6,
    text: 'Mill',
    value: 'M'
  },
  {
    power: 9,
    text: 'Bill',
    value: 'B'
  },
  {
    power: 12,
    text: 'Tril',
    value: 'T'
  },
  {
    power: 15,
    text: 'Peta',
    value: 'P'
  }, {
    power: 18,
    text: 'Exa',
    value: 'E'
  }, {
    power: 21,
    text: 'Zeta',
    value: 'Z'
  }, {
    power: 24,
    text: 'Yotta',
    value: 'Y'
  }];
  function findSi(type) {
    for (let i = 0; i < SI.length; i++) {
      if (SI[i].value === type) {
        return SI[i];
      }
    }
    return SI[SI_MID];
  }
  function calcSi(text, decimals, forceUnit) {
    if (forceUnit) {
      return findSi(forceUnit);
    }
    const siDefIndex = SI_MID - 1 + Math.ceil((text.length - decimals) / 3);
    return SI[siDefIndex] || SI[siDefIndex < 0 ? 0 : SI.length - 1];
  }

  const DEFAULT_DECIMALS = 0;
  const DEFAULT_UNIT = SI[SI_MID].text;
  let defaultDecimals = DEFAULT_DECIMALS;
  let defaultUnit = DEFAULT_UNIT;
  function _formatBalance(input, options = true, optDecimals = defaultDecimals) {
    let text = bnToBn$1(input).toString();
    if (text.length === 0 || text === '0') {
      return '0';
    }
    const isNegative = text[0].startsWith('-');
    if (isNegative) {
      text = text.substr(1);
    }
    const {
      decimals = optDecimals,
      forceUnit = undefined,
      withSi = true,
      withSiFull = false,
      withUnit = true
    } = isBoolean$1(options) ? {
      withSi: options
    } : options;
    const si = calcSi(text, decimals, forceUnit);
    const mid = text.length - (decimals + si.power);
    const prefix = text.substr(0, mid);
    const padding = mid < 0 ? 0 - mid : 0;
    const postfix = `${`${new Array(padding + 1).join('0')}${text}`.substr(mid < 0 ? 0 : mid)}0000`.substr(0, 4);
    const units = withSi || withSiFull ? si.value === '-' ? withUnit ? ` ${isBoolean$1(withUnit) ? si.text : withUnit}` : '' : ` ${withSiFull ? si.text : si.value}${withUnit ? `${withSiFull ? ' ' : ''}${isBoolean$1(withUnit) ? SI[SI_MID].text : withUnit}` : ''}` : '';
    return `${isNegative ? '-' : ''}${formatDecimal(prefix || '0')}.${postfix}${units}`;
  }
  const formatBalance = _formatBalance;
  formatBalance.calcSi = (text, decimals = defaultDecimals) => calcSi(text, decimals);
  formatBalance.findSi = findSi;
  formatBalance.getDefaults = () => {
    return {
      decimals: defaultDecimals,
      unit: defaultUnit
    };
  };
  formatBalance.getOptions = (decimals = defaultDecimals) => {
    return SI.filter(({
      power
    }) => power < 0 ? decimals + power >= 0 : true);
  };
  formatBalance.setDefaults = ({
    decimals,
    unit
  }) => {
    defaultDecimals = isUndefined(decimals) ? defaultDecimals : Array.isArray(decimals) ? decimals[0] : decimals;
    defaultUnit = isUndefined(unit) ? defaultUnit : Array.isArray(unit) ? unit[0] : unit;
    SI[SI_MID].text = defaultUnit;
  };

  function zeroPad(value) {
    return value.toString().padStart(2, '0');
  }
  function formatDate(date) {
    const year = date.getFullYear().toString();
    const month = zeroPad(date.getMonth() + 1);
    const day = zeroPad(date.getDate());
    const hour = zeroPad(date.getHours());
    const minute = zeroPad(date.getMinutes());
    const second = zeroPad(date.getSeconds());
    return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
  }

  function formatNumber(value) {
    return formatDecimal(bnToBn$1(value).toString());
  }

  const FORMAT = [9, 10, 13];
  function getCharCode0(s) {
    return s.charCodeAt(0);
  }
  function isAsciiByte(b) {
    return b < 127 && (b >= 32 || FORMAT.includes(b));
  }
  function isAscii(value) {
    const isStringIn = isString$1(value);
    if (value) {
      return (isStringIn && !isHex$1(value) ? value.toString().split('').map(getCharCode0) : u8aToU8a$1(value)).every(isAsciiByte);
    }
    return isStringIn;
  }

  function isBn(value) {
    return BN$8.isBN(value);
  }

  function replacer(_, v) {
    return isBigInt$1(v) ? v.toString() : v;
  }
  function stringify(args, space) {
    return JSON.stringify(args, replacer, space);
  }

  function isObject(value) {
    return typeof value === 'object';
  }

  function isUtf8(value) {
    if (!value) {
      return isString$1(value);
    }
    const u8a = u8aToU8a$1(value);
    const len = u8a.length;
    let i = 0;
    while (i < len) {
      if (u8a[i] <= 0x7F)
        {
          i += 1;
        } else if (u8a[i] >= 0xC2 && u8a[i] <= 0xDF)
        {
          if (i + 1 < len)
            {
              if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {
                return false;
              }
            } else {
            return false;
          }
          i += 2;
        } else if (u8a[i] === 0xE0)
        {
          if (i + 2 < len)
            {
              if (u8a[i + 1] < 0xA0 || u8a[i + 1] > 0xBF) {
                return false;
              }
              if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
                return false;
              }
            } else {
            return false;
          }
          i += 3;
        } else if (u8a[i] >= 0xE1 && u8a[i] <= 0xEC)
        {
          if (i + 2 < len)
            {
              if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {
                return false;
              }
              if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
                return false;
              }
            } else {
            return false;
          }
          i += 3;
        } else if (u8a[i] === 0xED)
        {
          if (i + 2 < len)
            {
              if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x9F) {
                return false;
              }
              if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
                return false;
              }
            } else {
            return false;
          }
          i += 3;
        } else if (u8a[i] >= 0xEE && u8a[i] <= 0xEF)
        {
          if (i + 2 < len)
            {
              if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {
                return false;
              }
              if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
                return false;
              }
            } else {
            return false;
          }
          i += 3;
        } else if (u8a[i] === 0xF0)
        {
          if (i + 3 < len)
            {
              if (u8a[i + 1] < 0x90 || u8a[i + 1] > 0xBF) {
                return false;
              }
              if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
                return false;
              }
              if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {
                return false;
              }
            } else {
            return false;
          }
          i += 4;
        } else if (u8a[i] >= 0xF1 && u8a[i] <= 0xF3)
        {
          if (i + 3 < len)
            {
              if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0xBF) {
                return false;
              }
              if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
                return false;
              }
              if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {
                return false;
              }
            } else {
            return false;
          }
          i += 4;
        } else if (u8a[i] === 0xF4)
        {
          if (i + 3 < len)
            {
              if (u8a[i + 1] < 0x80 || u8a[i + 1] > 0x8F) {
                return false;
              }
              if (u8a[i + 2] < 0x80 || u8a[i + 2] > 0xBF) {
                return false;
              }
              if (u8a[i + 3] < 0x80 || u8a[i + 3] > 0xBF) {
                return false;
              }
            } else {
            return false;
          }
          i += 4;
        } else {
        return false;
      }
    }
    return true;
  }

  function lazyMethod(result, item, creator, getName) {
    const name = getName ? getName(item) : item.toString();
    let value;
    Object.defineProperty(result, name, {
      configurable: true,
      enumerable: true,
      get: function () {
        if (isUndefined(value)) {
          value = creator(item);
          try {
            Object.defineProperty(this, name, {
              value
            });
          } catch {
          }
        }
        return value;
      }
    });
  }
  function lazyMethods(result, items, creator, getName) {
    for (let i = 0; i < items.length; i++) {
      lazyMethod(result, items[i], creator, getName);
    }
    return result;
  }

  const logTo = {
    debug: 'log',
    error: 'error',
    log: 'log',
    warn: 'warn'
  };
  function formatOther(value) {
    if (value && isObject(value) && value.constructor === Object) {
      const result = {};
      for (const k of Object.keys(value)) {
        result[k] = loggerFormat(value[k]);
      }
      return result;
    }
    return value;
  }
  function loggerFormat(value) {
    if (Array.isArray(value)) {
      return value.map(loggerFormat);
    } else if (isBn(value)) {
      return value.toString();
    } else if (isU8a$1(value) || isBuffer$1(value)) {
      return u8aToHex$1(u8aToU8a$1(value));
    }
    return formatOther(value);
  }
  function formatWithLength(maxLength) {
    return v => {
      if (maxLength <= 0) {
        return v;
      }
      const r = `${v}`;
      return r.length < maxLength ? v : `${r.substr(0, maxLength)} ...`;
    };
  }
  function apply(log, type, values, maxSize = -1) {
    if (values.length === 1 && isFunction$1(values[0])) {
      const fnResult = values[0]();
      return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);
    }
    console[logTo[log]](formatDate(new Date()), type, ...values.map(loggerFormat).map(formatWithLength(maxSize)));
  }
  function noop() {
  }
  function isDebugOn(e, type) {
    return !!e && (e === '*' || type === e || e.endsWith('*') && type.startsWith(e.slice(0, -1)));
  }
  function isDebugOff(e, type) {
    return !!e && e.startsWith('-') && (type === e.slice(1) || e.endsWith('*') && type.startsWith(e.slice(1, -1)));
  }
  function getDebugFlag(env, type) {
    let flag = false;
    for (const e of env) {
      if (isDebugOn(e, type)) {
        flag = true;
      } else if (isDebugOff(e, type)) {
        flag = false;
      }
    }
    return flag;
  }
  function parseEnv(type) {
    const env = (typeof process === 'object' ? process : {}).env || {};
    const maxSize = parseInt(env.DEBUG_MAX || '-1', 10);
    return [getDebugFlag((env.DEBUG || '').toLowerCase().split(','), type), isNaN(maxSize) ? -1 : maxSize];
  }
  function logger(_type) {
    const type = `${_type.toUpperCase()}:`.padStart(16);
    const [isDebug, maxSize] = parseEnv(_type.toLowerCase());
    return {
      debug: isDebug ? (...values) => apply('debug', type, values, maxSize) : noop,
      error: (...values) => apply('error', type, values),
      log: (...values) => apply('log', type, values),
      noop,
      warn: (...values) => apply('warn', type, values)
    };
  }

  function objectProperty(that, key, getter) {
    if (!Object.prototype.hasOwnProperty.call(that, key) && isUndefined(that[key])) {
      const get = () => getter(key);
      Object.defineProperty(that, key, {
        enumerable: true,
        get
      });
    }
  }
  function objectProperties(that, keys, getter) {
    for (let i = 0; i < keys.length; i++) {
      objectProperty(that, keys[i], k => getter(k, i));
    }
  }

  var camelcase$1 = {exports: {}};

  const preserveCamelCase = (string, locale) => {
  	let isLastCharLower = false;
  	let isLastCharUpper = false;
  	let isLastLastCharUpper = false;
  	for (let i = 0; i < string.length; i++) {
  		const character = string[i];
  		if (isLastCharLower && /[\p{Lu}]/u.test(character)) {
  			string = string.slice(0, i) + '-' + string.slice(i);
  			isLastCharLower = false;
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = true;
  			i++;
  		} else if (isLastCharUpper && isLastLastCharUpper && /[\p{Ll}]/u.test(character)) {
  			string = string.slice(0, i - 1) + '-' + string.slice(i - 1);
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = false;
  			isLastCharLower = true;
  		} else {
  			isLastCharLower = character.toLocaleLowerCase(locale) === character && character.toLocaleUpperCase(locale) !== character;
  			isLastLastCharUpper = isLastCharUpper;
  			isLastCharUpper = character.toLocaleUpperCase(locale) === character && character.toLocaleLowerCase(locale) !== character;
  		}
  	}
  	return string;
  };
  const preserveConsecutiveUppercase = input => {
  	return input.replace(/^[\p{Lu}](?![\p{Lu}])/gu, m1 => m1.toLowerCase());
  };
  const postProcess = (input, options) => {
  	return input.replace(/[_.\- ]+([\p{Alpha}\p{N}_]|$)/gu, (_, p1) => p1.toLocaleUpperCase(options.locale))
  		.replace(/\d+([\p{Alpha}\p{N}_]|$)/gu, m => m.toLocaleUpperCase(options.locale));
  };
  const camelCase = (input, options) => {
  	if (!(typeof input === 'string' || Array.isArray(input))) {
  		throw new TypeError('Expected the input to be `string | string[]`');
  	}
  	options = {
  		pascalCase: false,
  		preserveConsecutiveUppercase: false,
  		...options
  	};
  	if (Array.isArray(input)) {
  		input = input.map(x => x.trim())
  			.filter(x => x.length)
  			.join('-');
  	} else {
  		input = input.trim();
  	}
  	if (input.length === 0) {
  		return '';
  	}
  	if (input.length === 1) {
  		return options.pascalCase ? input.toLocaleUpperCase(options.locale) : input.toLocaleLowerCase(options.locale);
  	}
  	const hasUpperCase = input !== input.toLocaleLowerCase(options.locale);
  	if (hasUpperCase) {
  		input = preserveCamelCase(input, options.locale);
  	}
  	input = input.replace(/^[_.\- ]+/, '');
  	if (options.preserveConsecutiveUppercase) {
  		input = preserveConsecutiveUppercase(input);
  	} else {
  		input = input.toLocaleLowerCase();
  	}
  	if (options.pascalCase) {
  		input = input.charAt(0).toLocaleUpperCase(options.locale) + input.slice(1);
  	}
  	return postProcess(input, options);
  };
  camelcase$1.exports = camelCase;
  camelcase$1.exports.default = camelCase;
  const camelcase = camelcase$1.exports;

  function stringCamelCase(value) {
    return camelcase(value.toString());
  }

  function stringLowerFirst(value) {
    return value ? value.charAt(0).toLowerCase() + value.slice(1) : '';
  }

  function stringUpperFirst(value) {
    return value ? value.charAt(0).toUpperCase() + value.slice(1) : '';
  }

  const numberTypes = {
    Fixed64: 'Int<64, Fixed64>',
    FixedI64: 'Int<64, FixedI64>',
    FixedU64: 'UInt<64, FixedU64>',
    Fixed128: 'Int<128, Fixed128>',
    FixedI128: 'Int<128, FixedI128>',
    FixedU128: 'UInt<128, FixedU128>',
    I32F32: 'Int<64, I32F32>',
    U32F32: 'UInt<64, U32F32>',
    PerU16: 'UInt<16, PerU16>',
    Perbill: 'UInt<32, Perbill>',
    Percent: 'UInt<8, Percent>',
    Permill: 'UInt<32, Permill>',
    Perquintill: 'UInt<64, Perquintill>'
  };
  const definitions$V = {
    rpc: {},
    types: objectSpread$1({}, numberTypes, {
      AccountId: 'AccountId32',
      AccountId20: 'GenericEthereumAccountId',
      AccountId32: 'GenericAccountId',
      AccountIdOf: 'AccountId',
      AccountIndex: 'GenericAccountIndex',
      Address: 'MultiAddress',
      AssetId: 'u32',
      Balance: 'UInt<128, Balance>',
      BalanceOf: 'Balance',
      Block: 'GenericBlock',
      BlockNumber: 'u32',
      BlockNumberFor: 'BlockNumber',
      BlockNumberOf: 'BlockNumber',
      Call: 'GenericCall',
      CallHash: 'Hash',
      CallHashOf: 'CallHash',
      ChangesTrieConfiguration: {
        digestInterval: 'u32',
        digestLevels: 'u32'
      },
      ChangesTrieSignal: {
        _enum: {
          NewConfiguration: 'Option<ChangesTrieConfiguration>'
        }
      },
      ConsensusEngineId: 'GenericConsensusEngineId',
      CodecHash: 'Hash',
      CrateVersion: {
        major: 'u16',
        minor: 'u8',
        patch: 'u8'
      },
      Digest: {
        logs: 'Vec<DigestItem>'
      },
      DigestItem: {
        _enum: {
          Other: 'Bytes',
          AuthoritiesChange: 'Vec<AuthorityId>',
          ChangesTrieRoot: 'Hash',
          SealV0: 'SealV0',
          Consensus: 'Consensus',
          Seal: 'Seal',
          PreRuntime: 'PreRuntime',
          ChangesTrieSignal: 'ChangesTrieSignal',
          RuntimeEnvironmentUpdated: 'Null'
        }
      },
      ExtrinsicsWeight: {
        normal: 'Weight',
        operational: 'Weight'
      },
      H32: '[u8; 4; H32]',
      H64: '[u8; 8; H64]',
      H128: '[u8; 16; H128]',
      H160: '[u8; 20; H160]',
      H256: '[u8; 32; H256]',
      H512: '[u8; 64; H512]',
      H1024: '[u8; 128; H1024]',
      H2048: '[u8; 256; H2048]',
      Hash: 'H256',
      Header: {
        parentHash: 'Hash',
        number: 'Compact<BlockNumber>',
        stateRoot: 'Hash',
        extrinsicsRoot: 'Hash',
        digest: 'Digest'
      },
      HeaderPartial: {
        parentHash: 'Hash',
        number: 'BlockNumber'
      },
      IndicesLookupSource: 'GenericLookupSource',
      Index: 'u32',
      Justification: '(ConsensusEngineId, EncodedJustification)',
      EncodedJustification: 'Bytes',
      Justifications: 'Vec<Justification>',
      KeyValue: '(StorageKey, StorageData)',
      KeyTypeId: 'u32',
      LockIdentifier: '[u8; 8]',
      LookupSource: 'MultiAddress',
      LookupTarget: 'AccountId',
      ModuleId: 'LockIdentifier',
      MultiAddress: 'GenericMultiAddress',
      MultiSigner: {
        _enum: {
          Ed25519: '[u8; 32]',
          Sr25519: '[u8; 32]',
          Ecdsa: '[u8; 33]'
        }
      },
      Moment: 'UInt<64, Moment>',
      OpaqueCall: 'Bytes',
      Origin: 'DoNotConstruct<Origin>',
      OriginCaller: {
        _enum: {
          System: 'SystemOrigin'
        }
      },
      PalletId: 'LockIdentifier',
      PalletsOrigin: 'OriginCaller',
      PalletVersion: {
        major: 'u16',
        minor: 'u8',
        patch: 'u8'
      },
      Pays: {
        _enum: ['Yes', 'No']
      },
      Phantom: 'Null',
      PhantomData: 'Null',
      Releases: {
        _enum: ['V1', 'V2', 'V3', 'V4', 'V5', 'V6', 'V7', 'V8', 'V9', 'V10']
      },
      RuntimeDbWeight: {
        read: 'Weight',
        write: 'Weight'
      },
      SignedBlock: 'SignedBlockWithJustifications',
      SignedBlockWithJustification: {
        block: 'Block',
        justification: 'Option<EncodedJustification>'
      },
      SignedBlockWithJustifications: {
        block: 'Block',
        justifications: 'Option<Justifications>'
      },
      Slot: 'u64',
      StorageData: 'Bytes',
      StorageProof: {
        trieNodes: 'Vec<Bytes>'
      },
      TransactionPriority: 'u64',
      TransactionInfo: {
        _alias: {
          dataSize: 'size'
        },
        chunkRoot: 'H256',
        contentHash: 'H256',
        dataSize: 'u32',
        blockChunks: 'u32'
      },
      TransactionStorageProof: {
        chunk: 'Vec<u8>',
        proof: 'Vec<Vec<u8>>'
      },
      ValidatorId: 'AccountId',
      ValidatorIdOf: 'ValidatorId',
      Weight: 'u64',
      WeightMultiplier: 'Fixed64',
      PreRuntime: '(ConsensusEngineId, Bytes)',
      SealV0: '(u64, Signature)',
      Seal: '(ConsensusEngineId, Bytes)',
      Consensus: '(ConsensusEngineId, Bytes)'
    })
  };

  const definitions$U = {
    rpc: {},
    types: {
      AssetApprovalKey: {
        owner: 'AccountId',
        delegate: 'AccountId'
      },
      AssetApproval: {
        amount: 'TAssetBalance',
        deposit: 'TAssetDepositBalance'
      },
      AssetBalance: {
        balance: 'TAssetBalance',
        isFrozen: 'bool',
        isSufficient: 'bool'
      },
      AssetDestroyWitness: {
        accounts: 'Compact<u32>',
        sufficients: 'Compact<u32>',
        approvals: 'Compact<u32>'
      },
      AssetDetails: {
        owner: 'AccountId',
        issuer: 'AccountId',
        admin: 'AccountId',
        freezer: 'AccountId',
        supply: 'TAssetBalance',
        deposit: 'TAssetDepositBalance',
        minBalance: 'TAssetBalance',
        isSufficient: 'bool',
        accounts: 'u32',
        sufficients: 'u32',
        approvals: 'u32',
        isFrozen: 'bool'
      },
      AssetMetadata: {
        deposit: 'TAssetDepositBalance',
        name: 'Vec<u8>',
        symbol: 'Vec<u8>',
        decimals: 'u8',
        isFrozen: 'bool'
      },
      TAssetBalance: 'u64',
      TAssetDepositBalance: 'BalanceOf'
    }
  };

  const definitions$T = {
    rpc: {},
    types: {
      UncleEntryItem: {
        _enum: {
          InclusionHeight: 'BlockNumber',
          Uncle: '(Hash, Option<AccountId>)'
        }
      }
    }
  };

  const definitions$S = {
    rpc: {},
    types: {
      RawAuraPreDigest: {
        slotNumber: 'u64'
      }
    }
  };

  const definitions$R = {
    rpc: {
      epochAuthorship: {
        description: 'Returns data about which slots (primary or secondary) can be claimed in the current epoch with the keys in the keystore',
        params: [],
        type: 'HashMap<AuthorityId, EpochAuthorship>'
      }
    },
    types: {
      AllowedSlots: {
        _enum: ['PrimarySlots', 'PrimaryAndSecondaryPlainSlots', 'PrimaryAndSecondaryVRFSlots']
      },
      BabeAuthorityWeight: 'u64',
      BabeEpochConfiguration: {
        c: '(u64, u64)',
        allowedSlots: 'AllowedSlots'
      },
      BabeBlockWeight: 'u32',
      BabeEquivocationProof: {
        offender: 'AuthorityId',
        slotNumber: 'SlotNumber',
        firstHeader: 'Header',
        secondHeader: 'Header'
      },
      BabeWeight: 'u64',
      MaybeRandomness: 'Option<Randomness>',
      MaybeVrf: 'Option<VrfData>',
      EpochAuthorship: {
        primary: 'Vec<u64>',
        secondary: 'Vec<u64>',
        secondary_vrf: 'Vec<u64>'
      },
      NextConfigDescriptor: {
        _enum: {
          V0: 'Null',
          V1: 'NextConfigDescriptorV1'
        }
      },
      NextConfigDescriptorV1: {
        c: '(u64, u64)',
        allowedSlots: 'AllowedSlots'
      },
      Randomness: 'Hash',
      RawBabePreDigest: {
        _enum: {
          Phantom: 'Null',
          Primary: 'RawBabePreDigestPrimary',
          SecondaryPlain: 'RawBabePreDigestSecondaryPlain',
          SecondaryVRF: 'RawBabePreDigestSecondaryVRF'
        }
      },
      RawBabePreDigestPrimary: {
        authorityIndex: 'u32',
        slotNumber: 'SlotNumber',
        vrfOutput: 'VrfOutput',
        vrfProof: 'VrfProof'
      },
      RawBabePreDigestSecondaryPlain: {
        authorityIndex: 'u32',
        slotNumber: 'SlotNumber'
      },
      RawBabePreDigestSecondaryVRF: {
        authorityIndex: 'u32',
        slotNumber: 'SlotNumber',
        vrfOutput: 'VrfOutput',
        vrfProof: 'VrfProof'
      },
      RawBabePreDigestTo159: {
        _enum: {
          Primary: 'RawBabePreDigestPrimaryTo159',
          Secondary: 'RawBabePreDigestSecondaryTo159'
        }
      },
      RawBabePreDigestPrimaryTo159: {
        authorityIndex: 'u32',
        slotNumber: 'SlotNumber',
        weight: 'BabeBlockWeight',
        vrfOutput: 'VrfOutput',
        vrfProof: 'VrfProof'
      },
      RawBabePreDigestSecondaryTo159: {
        authorityIndex: 'u32',
        slotNumber: 'SlotNumber',
        weight: 'BabeBlockWeight'
      },
      RawBabePreDigestCompat: {
        _enum: {
          Zero: 'u32',
          One: 'u32',
          Two: 'u32',
          Three: 'u32'
        }
      },
      SlotNumber: 'u64',
      VrfData: '[u8; 32]',
      VrfOutput: '[u8; 32]',
      VrfProof: '[u8; 64]'
    }
  };

  const definitions$Q = {
    rpc: {},
    types: {
      AccountData: {
        free: 'Balance',
        reserved: 'Balance',
        miscFrozen: 'Balance',
        feeFrozen: 'Balance'
      },
      BalanceLockTo212: {
        id: 'LockIdentifier',
        amount: 'Balance',
        until: 'BlockNumber',
        reasons: 'WithdrawReasons'
      },
      BalanceLock: {
        id: 'LockIdentifier',
        amount: 'Balance',
        reasons: 'Reasons'
      },
      BalanceStatus: {
        _enum: ['Free', 'Reserved']
      },
      Reasons: {
        _enum: ['Fee', 'Misc', 'All']
      },
      ReserveData: {
        id: 'ReserveIdentifier',
        amount: 'Balance'
      },
      ReserveIdentifier: '[u8; 8]',
      VestingSchedule: {
        offset: 'Balance',
        perBlock: 'Balance',
        startingBlock: 'BlockNumber'
      },
      WithdrawReasons: {
        _set: {
          TransactionPayment: 0b00000001,
          Transfer: 0b00000010,
          Reserve: 0b00000100,
          Fee: 0b00001000,
          Tip: 0b00010000
        }
      }
    }
  };

  const definitions$P = {
    rpc: {
      subscribeJustifications: {
        description: 'Returns the block most recently finalized by BEEFY, alongside side its justification.',
        params: [],
        pubsub: ['justifications', 'subscribeJustifications', 'unsubscribeJustifications'],
        type: 'BeefySignedCommitment'
      }
    },
    types: {
      BeefyCommitment: {
        payload: 'BeefyPayload',
        blockNumber: 'BlockNumber',
        validatorSetId: 'ValidatorSetId'
      },
      BeefyId: '[u8; 33]',
      BeefySignedCommitment: {
        commitment: 'BeefyCommitment',
        signatures: 'Vec<Option<Signature>>'
      },
      BeefyNextAuthoritySet: {
        id: 'u64',
        len: 'u32',
        root: 'H256'
      },
      BeefyPayload: 'MmrRootHash',
      MmrRootHash: 'H256',
      ValidatorSetId: 'u64'
    }
  };

  const definitions$O = {
    rpc: {},
    types: {
      CollectiveOrigin: {
        _enum: {
          Members: '(MemberCount, MemberCount)',
          Member: 'AccountId'
        }
      },
      MemberCount: 'u32',
      ProposalIndex: 'u32',
      VotesTo230: {
        index: 'ProposalIndex',
        threshold: 'MemberCount',
        ayes: 'Vec<AccountId>',
        nays: 'Vec<AccountId>'
      },
      Votes: {
        index: 'ProposalIndex',
        threshold: 'MemberCount',
        ayes: 'Vec<AccountId>',
        nays: 'Vec<AccountId>',
        end: 'BlockNumber'
      }
    }
  };

  const definitions$N = {
    rpc: {},
    types: {
      AuthorityId: 'AccountId',
      RawVRFOutput: '[u8; 32]'
    }
  };

  const definitions$M = {
    rpc: {
      call: {
        description: 'Executes a call to a contract',
        params: [{
          name: 'callRequest',
          type: 'ContractCallRequest'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'ContractExecResult'
      },
      instantiate: {
        description: 'Instantiate a new contract',
        params: [{
          name: 'request',
          type: 'InstantiateRequest'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHstoric: true,
          isOptional: true
        }],
        type: 'ContractInstantiateResult'
      },
      getStorage: {
        description: 'Returns the value under a specified storage key in a contract',
        params: [{
          name: 'address',
          type: 'AccountId'
        }, {
          name: 'key',
          type: 'H256'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Option<Bytes>'
      },
      rentProjection: {
        description: 'Returns the projected time a given contract will be able to sustain paying its rent',
        params: [{
          name: 'address',
          type: 'AccountId'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Option<BlockNumber>'
      }
    },
    types: {
      AliveContractInfo: {
        trieId: 'TrieId',
        storageSize: 'u32',
        pairCount: 'u32',
        codeHash: 'CodeHash',
        rentAllowance: 'Balance',
        rentPaid: 'Balance',
        deductBlock: 'BlockNumber',
        lastWrite: 'Option<BlockNumber>',
        _reserved: 'Option<Null>'
      },
      CodeHash: 'Hash',
      ContractCallRequest: {
        origin: 'AccountId',
        dest: 'AccountId',
        value: 'Balance',
        gasLimit: 'u64',
        inputData: 'Bytes'
      },
      ContractExecResultSuccessTo255: {
        status: 'u8',
        data: 'Raw'
      },
      ContractExecResultTo255: {
        _enum: {
          Success: 'ContractExecResultSuccessTo255',
          Error: 'Null'
        }
      },
      ContractExecResultSuccessTo260: {
        flags: 'u32',
        data: 'Bytes',
        gasConsumed: 'u64'
      },
      ContractExecResultTo260: {
        _enum: {
          Success: 'ContractExecResultSuccessTo260',
          Error: 'Null'
        }
      },
      ContractExecResultErrModule: {
        index: 'u8',
        error: 'u8',
        message: 'Option<Text>'
      },
      ContractExecResultErr: {
        _enum: {
          Other: 'Text',
          CannotLookup: 'Null',
          BadOrigin: 'Null',
          Module: 'ContractExecResultErrModule'
        }
      },
      ContractExecResultOk: {
        flags: 'u32',
        data: 'Bytes'
      },
      ContractExecResultResult: {
        _enum: {
          Ok: 'ContractExecResultOk',
          Err: 'ContractExecResultErr'
        }
      },
      ContractExecResultTo267: {
        gasConsumed: 'u64',
        debugMessage: 'Text',
        result: 'ContractExecResultResult'
      },
      ContractExecResult: {
        gasConsumed: 'u64',
        gasRequired: 'u64',
        debugMessage: 'Text',
        result: 'ContractExecResultResult'
      },
      ContractInfo: {
        _enum: {
          Alive: 'AliveContractInfo',
          Tombstone: 'TombstoneContractInfo'
        }
      },
      ContractStorageKey: '[u8; 32]',
      DeletedContract: {
        pairCount: 'u32',
        trieId: 'TrieId'
      },
      ExecReturnValue: {
        flags: 'u32',
        data: 'Bytes'
      },
      Gas: 'u64',
      HostFnWeightsTo264: {
        caller: 'Weight',
        address: 'Weight',
        gasLeft: 'Weight',
        balance: 'Weight',
        valueTransferred: 'Weight',
        minimumBalance: 'Weight',
        tombstoneDeposit: 'Weight',
        rentAllowance: 'Weight',
        blockNumber: 'Weight',
        now: 'Weight',
        weightToFee: 'Weight',
        gas: 'Weight',
        input: 'Weight',
        inputPerByte: 'Weight',
        return: 'Weight',
        returnPerByte: 'Weight',
        terminate: 'Weight',
        restoreTo: 'Weight',
        restoreToPerDelta: 'Weight',
        random: 'Weight',
        depositEvent: 'Weight',
        depositEventPerTopic: 'Weight',
        depositEventPerByte: 'Weight',
        setRentAllowance: 'Weight',
        setStorage: 'Weight',
        setStoragePerByte: 'Weight',
        clearStorage: 'Weight',
        getStorage: 'Weight',
        getStoragePerByte: 'Weight',
        transfer: 'Weight',
        call: 'Weight',
        callTransferSurcharge: 'Weight',
        callPerInputByte: 'Weight',
        callPerOutputByte: 'Weight',
        instantiate: 'Weight',
        instantiatePerInputByte: 'Weight',
        instantiatePerOutputByte: 'Weight',
        hashSha2256: 'Weight',
        hashSha2256PerByte: 'Weight',
        hashKeccak256: 'Weight',
        hashKeccak256PerByte: 'Weight',
        hashBlake2256: 'Weight',
        hashBlake2256PerByte: 'Weight',
        hashBlake2128: 'Weight',
        hashBlake2128PerByte: 'Weight'
      },
      HostFnWeights: {
        caller: 'Weight',
        address: 'Weight',
        gasLeft: 'Weight',
        balance: 'Weight',
        valueTransferred: 'Weight',
        minimumBalance: 'Weight',
        tombstoneDeposit: 'Weight',
        rentAllowance: 'Weight',
        blockNumber: 'Weight',
        now: 'Weight',
        weightToFee: 'Weight',
        gas: 'Weight',
        input: 'Weight',
        inputPerByte: 'Weight',
        return: 'Weight',
        returnPerByte: 'Weight',
        terminate: 'Weight',
        terminatePerCodeByte: 'Weight',
        restoreTo: 'Weight',
        restoreToPerCallerCodeByte: 'Weight',
        restoreToPerTombstoneCodeByte: 'Weight',
        restoreToPerDelta: 'Weight',
        random: 'Weight',
        depositEvent: 'Weight',
        depositEventPerTopic: 'Weight',
        depositEventPerByte: 'Weight',
        setRentAllowance: 'Weight',
        setStorage: 'Weight',
        setStoragePerByte: 'Weight',
        clearStorage: 'Weight',
        getStorage: 'Weight',
        getStoragePerByte: 'Weight',
        transfer: 'Weight',
        call: 'Weight',
        callPerCodeByte: 'Weight',
        callTransferSurcharge: 'Weight',
        callPerInputByte: 'Weight',
        callPerOutputByte: 'Weight',
        instantiate: 'Weight',
        instantiatePerCodeByte: 'Weight',
        instantiatePerInputByte: 'Weight',
        instantiatePerOutputByte: 'Weight',
        instantiatePerSaltByte: 'Weight',
        hashSha2256: 'Weight',
        hashSha2256PerByte: 'Weight',
        hashKeccak256: 'Weight',
        hashKeccak256PerByte: 'Weight',
        hashBlake2256: 'Weight',
        hashBlake2256PerByte: 'Weight',
        hashBlake2128: 'Weight',
        hashBlake2128PerByte: 'Weight',
        rentParams: 'Weight'
      },
      InstantiateRequest: {
        origin: 'AccountId',
        endowment: 'Balance',
        gasLimit: 'Gas',
        code: 'Bytes',
        data: 'Bytes',
        salt: 'Bytes'
      },
      ContractInstantiateResultTo267: {
        _enum: {
          Ok: 'InstantiateReturnValueTo267',
          Err: 'Null'
        }
      },
      ContractInstantiateResult: {
        _enum: {
          Ok: 'InstantiateReturnValue',
          Err: 'Null'
        }
      },
      InstantiateReturnValueTo267: {
        result: 'ExecReturnValue',
        accountId: 'AccountId',
        rentProjection: 'Option<RentProjection>'
      },
      InstantiateReturnValue: {
        _fallback: 'InstantiateReturnValueTo267',
        result: 'ExecReturnValue',
        accountId: 'AccountId'
      },
      InstructionWeights: {
        i64const: 'u32',
        i64load: 'u32',
        i64store: 'u32',
        select: 'u32',
        rIf: 'u32',
        br: 'u32',
        brIf: 'u32',
        brIable: 'u32',
        brIablePerEntry: 'u32',
        call: 'u32',
        callIndirect: 'u32',
        callIndirectPerParam: 'u32',
        localGet: 'u32',
        localSet: 'u32',
        local_tee: 'u32',
        globalGet: 'u32',
        globalSet: 'u32',
        memoryCurrent: 'u32',
        memoryGrow: 'u32',
        i64clz: 'u32',
        i64ctz: 'u32',
        i64popcnt: 'u32',
        i64eqz: 'u32',
        i64extendsi32: 'u32',
        i64extendui32: 'u32',
        i32wrapi64: 'u32',
        i64eq: 'u32',
        i64ne: 'u32',
        i64lts: 'u32',
        i64ltu: 'u32',
        i64gts: 'u32',
        i64gtu: 'u32',
        i64les: 'u32',
        i64leu: 'u32',
        i64ges: 'u32',
        i64geu: 'u32',
        i64add: 'u32',
        i64sub: 'u32',
        i64mul: 'u32',
        i64divs: 'u32',
        i64divu: 'u32',
        i64rems: 'u32',
        i64remu: 'u32',
        i64and: 'u32',
        i64or: 'u32',
        i64xor: 'u32',
        i64shl: 'u32',
        i64shrs: 'u32',
        i64shru: 'u32',
        i64rotl: 'u32',
        i64rotr: 'u32'
      },
      LimitsTo264: {
        eventTopics: 'u32',
        stackHeight: 'u32',
        globals: 'u32',
        parameters: 'u32',
        memoryPages: 'u32',
        tableSize: 'u32',
        brTableSize: 'u32',
        subjectLen: 'u32',
        codeSize: 'u32'
      },
      Limits: {
        eventTopics: 'u32',
        stackHeight: 'u32',
        globals: 'u32',
        parameters: 'u32',
        memoryPages: 'u32',
        tableSize: 'u32',
        brTableSize: 'u32',
        subjectLen: 'u32'
      },
      PrefabWasmModule: {
        scheduleVersion: 'Compact<u32>',
        initial: 'Compact<u32>',
        maximum: 'Compact<u32>',
        refcount: 'Compact<u64>',
        _reserved: 'Option<Null>',
        code: 'Bytes',
        originalCodeLen: 'u32'
      },
      RentProjection: {
        _enum: {
          EvictionAt: 'BlockNumber',
          NoEviction: 'Null'
        }
      },
      ScheduleTo212: {
        version: 'u32',
        putCodePerByteCost: 'Gas',
        growMemCost: 'Gas',
        regularOpCost: 'Gas',
        returnDataPerByteCost: 'Gas',
        eventDataPerByteCost: 'Gas',
        eventPerTopicCost: 'Gas',
        eventBaseCost: 'Gas',
        sandboxDataReadCost: 'Gas',
        sandboxDataWriteCost: 'Gas',
        maxEventTopics: 'u32',
        maxStackHeight: 'u32',
        maxMemoryPages: 'u32',
        enablePrintln: 'bool',
        maxSubjectLen: 'u32'
      },
      ScheduleTo258: {
        version: 'u32',
        putCodePerByteCost: 'Gas',
        growMemCost: 'Gas',
        regularOpCost: 'Gas',
        returnDataPerByteCost: 'Gas',
        eventDataPerByteCost: 'Gas',
        eventPerTopicCost: 'Gas',
        eventBaseCost: 'Gas',
        sandboxDataReadCost: 'Gas',
        sandboxDataWriteCost: 'Gas',
        transferCost: 'Gas',
        maxEventTopics: 'u32',
        maxStackHeight: 'u32',
        maxMemoryPages: 'u32',
        enablePrintln: 'bool',
        maxSubjectLen: 'u32'
      },
      ScheduleTo264: {
        version: 'u32',
        enablePrintln: 'bool',
        limits: 'LimitsTo264',
        instructionWeights: 'InstructionWeights',
        hostFnWeights: 'HostFnWeightsTo264'
      },
      Schedule: {
        version: 'u32',
        enablePrintln: 'bool',
        limits: 'Limits',
        instructionWeights: 'InstructionWeights',
        hostFnWeights: 'HostFnWeights'
      },
      SeedOf: 'Hash',
      TombstoneContractInfo: 'Hash',
      TrieId: 'Bytes'
    }
  };

  const AllConvictions = [
  'None',
  'Locked1x',
  'Locked2x',
  'Locked3x',
  'Locked4x',
  'Locked5x',
  'Locked6x'];
  const definitions$L = {
    rpc: {},
    types: {
      AccountVote: {
        _enum: {
          Standard: 'AccountVoteStandard',
          Split: 'AccountVoteSplit'
        }
      },
      AccountVoteSplit: {
        aye: 'Balance',
        nay: 'Balance'
      },
      AccountVoteStandard: {
        vote: 'Vote',
        balance: 'Balance'
      },
      Conviction: {
        _enum: AllConvictions
      },
      Delegations: {
        votes: 'Balance',
        capital: 'Balance'
      },
      PreimageStatus: {
        _enum: {
          Missing: 'BlockNumber',
          Available: 'PreimageStatusAvailable'
        }
      },
      PreimageStatusAvailable: {
        data: 'Bytes',
        provider: 'AccountId',
        deposit: 'Balance',
        since: 'BlockNumber',
        expiry: 'Option<BlockNumber>'
      },
      PriorLock: '(BlockNumber, Balance)',
      PropIndex: 'u32',
      Proposal: 'Call',
      ProxyState: {
        _enum: {
          Open: 'AccountId',
          Active: 'AccountId'
        }
      },
      ReferendumIndex: 'u32',
      ReferendumInfoTo239: {
        end: 'BlockNumber',
        proposalHash: 'Hash',
        threshold: 'VoteThreshold',
        delay: 'BlockNumber'
      },
      ReferendumInfo: {
        _enum: {
          Ongoing: 'ReferendumStatus',
          Finished: 'ReferendumInfoFinished'
        }
      },
      ReferendumInfoFinished: {
        approved: 'bool',
        end: 'BlockNumber'
      },
      ReferendumStatus: {
        end: 'BlockNumber',
        proposalHash: 'Hash',
        threshold: 'VoteThreshold',
        delay: 'BlockNumber',
        tally: 'Tally'
      },
      Tally: {
        ayes: 'Balance',
        nays: 'Balance',
        turnout: 'Balance'
      },
      Voting: {
        _enum: {
          Direct: 'VotingDirect',
          Delegating: 'VotingDelegating'
        }
      },
      VotingDirect: {
        votes: 'Vec<VotingDirectVote>',
        delegations: 'Delegations',
        prior: 'PriorLock'
      },
      VotingDirectVote: '(ReferendumIndex, AccountVote)',
      VotingDelegating: {
        balance: 'Balance',
        target: 'AccountId',
        conviction: 'Conviction',
        delegations: 'Delegations',
        prior: 'PriorLock'
      }
    }
  };

  const definitions$K = {
    rpc: {},
    types: {
      ApprovalFlag: 'u32',
      DefunctVoter: {
        who: 'AccountId',
        voteCount: 'Compact<u32>',
        candidateCount: 'Compact<u32>'
      },
      Renouncing: {
        _enum: {
          Member: 'Null',
          RunnerUp: 'Null',
          Candidate: 'Compact<u32>'
        }
      },
      SetIndex: 'u32',
      Vote: 'GenericVote',
      VoteIndex: 'u32',
      VoterInfo: {
        lastActive: 'VoteIndex',
        lastWin: 'VoteIndex',
        pot: 'Balance',
        stake: 'Balance'
      },
      VoteThreshold: {
        _enum: ['Super Majority Approve', 'Super Majority Against', 'Simple Majority']
      }
    }
  };

  const definitions$J = {
    rpc: {
      createBlock: {
        description: 'Instructs the manual-seal authorship task to create a new block',
        params: [{
          name: 'createEmpty',
          type: 'bool'
        }, {
          name: 'finalize',
          type: 'bool'
        }, {
          name: 'parentHash',
          type: 'BlockHash',
          isOptional: true
        }],
        type: 'CreatedBlock'
      },
      finalizeBlock: {
        description: 'Instructs the manual-seal authorship task to finalize a block',
        params: [{
          name: 'hash',
          type: 'BlockHash'
        }, {
          name: 'justification',
          type: 'Justification',
          isOptional: true
        }],
        type: 'bool'
      }
    },
    types: {
      CreatedBlock: {
        hash: 'BlockHash',
        aux: 'ImportedAux'
      },
      ImportedAux: {
        headerOnly: 'bool',
        clearJustificationRequests: 'bool',
        needsJustification: 'bool',
        badJustification: 'bool',
        needsFinalityProof: 'bool',
        isNewBest: 'bool'
      }
    }
  };

  const definitions$I = {
    rpc: {},
    types: {
      EvmAccount: {
        nonce: 'u256',
        balance: 'u256'
      },
      EvmLog: {
        address: 'H160',
        topics: 'Vec<H256>',
        data: 'Bytes'
      },
      EvmVicinity: {
        gasPrice: 'u256',
        origin: 'H160'
      },
      ExitError: {
        _enum: {
          StackUnderflow: 'Null',
          StackOverflow: 'Null',
          InvalidJump: 'Null',
          InvalidRange: 'Null',
          DesignatedInvalid: 'Null',
          CallTooDeep: 'Null',
          CreateCollision: 'Null',
          CreateContractLimit: 'Null',
          OutOfOffset: 'Null',
          OutOfGas: 'Null',
          OutOfFund: 'Null',
          PCUnderflow: 'Null',
          CreateEmpty: 'Null',
          Other: 'Text'
        }
      },
      ExitFatal: {
        _enum: {
          NotSupported: 'Null',
          UnhandledInterrupt: 'Null',
          CallErrorAsFatal: 'ExitError',
          Other: 'Text'
        }
      },
      ExitReason: {
        _enum: {
          Succeed: 'ExitSucceed',
          Error: 'ExitError',
          Revert: 'ExitRevert',
          Fatal: 'ExitFatal'
        }
      },
      ExitRevert: {
        _enum: ['Reverted']
      },
      ExitSucceed: {
        _enum: ['Stopped', 'Returned', 'Suicided']
      }
    }
  };

  const definitions$H = {
    rpc: {},
    types: {
      Extrinsic: 'GenericExtrinsic',
      ExtrinsicEra: 'GenericExtrinsicEra',
      ExtrinsicPayload: 'GenericExtrinsicPayload',
      ExtrinsicSignature: 'MultiSignature',
      ExtrinsicV4: 'GenericExtrinsicV4',
      ExtrinsicPayloadV4: 'GenericExtrinsicPayloadV4',
      ExtrinsicSignatureV4: 'GenericExtrinsicSignatureV4',
      ExtrinsicUnknown: 'GenericExtrinsicUnknown',
      ExtrinsicPayloadUnknown: 'GenericExtrinsicPayloadUnknown',
      Era: 'ExtrinsicEra',
      ImmortalEra: 'GenericImmortalEra',
      MortalEra: 'GenericMortalEra',
      AnySignature: 'H512',
      MultiSignature: {
        _enum: {
          Ed25519: 'Ed25519Signature',
          Sr25519: 'Sr25519Signature',
          Ecdsa: 'EcdsaSignature'
        }
      },
      Signature: 'H512',
      SignerPayload: 'GenericSignerPayload',
      EcdsaSignature: '[u8; 65]',
      Ed25519Signature: 'H512',
      Sr25519Signature: 'H512'
    }
  };

  const definitions$G = {
    rpc: {},
    types: {
      AssetOptions: {
        initalIssuance: 'Compact<Balance>',
        permissions: 'PermissionLatest'
      },
      Owner: {
        _enum: {
          None: 'Null',
          Address: 'AccountId'
        }
      },
      PermissionsV1: {
        update: 'Owner',
        mint: 'Owner',
        burn: 'Owner'
      },
      PermissionVersions: {
        _enum: {
          V1: 'PermissionsV1'
        }
      },
      PermissionLatest: 'PermissionsV1'
    }
  };

  const definitions$F = {
    rpc: {},
    types: {
      ActiveGilt: {
        proportion: 'Perquintill',
        amount: 'Balance',
        who: 'AccountId',
        expiry: 'BlockNumber'
      },
      ActiveGiltsTotal: {
        frozen: 'Balance',
        proportion: 'Perquintill',
        index: 'ActiveIndex',
        target: 'Perquintill'
      },
      ActiveIndex: 'u32',
      GiltBid: {
        amount: 'Balance',
        who: 'AccountId'
      }
    }
  };

  const definitions$E = {
    rpc: {
      proveFinality: {
        description: 'Prove finality for the range (begin; end] hash.',
        params: [{
          name: 'begin',
          type: 'BlockHash'
        }, {
          name: 'end',
          type: 'BlockHash'
        }, {
          name: 'authoritiesSetId',
          type: 'u64',
          isOptional: true
        }],
        type: 'Option<EncodedFinalityProofs>'
      },
      roundState: {
        description: 'Returns the state of the current best round state as well as the ongoing background rounds',
        params: [],
        type: 'ReportedRoundStates'
      },
      subscribeJustifications: {
        description: 'Subscribes to grandpa justifications',
        params: [],
        pubsub: ['justifications', 'subscribeJustifications', 'unsubscribeJustifications'],
        type: 'JustificationNotification'
      }
    },
    types: {
      AuthorityIndex: 'u64',
      AuthorityList: 'Vec<NextAuthority>',
      AuthoritySet: {
        currentAuthorities: 'AuthorityList',
        setId: 'u64',
        pendingStandardChanges: 'ForkTreePendingChange',
        pendingForcedChanges: 'Vec<PendingChange>',
        authoritySetChanges: 'AuthoritySetChanges'
      },
      ForkTreePendingChange: {
        roots: 'Vec<ForkTreePendingChangeNode>',
        bestFinalizedNumber: 'Option<BlockNumber>'
      },
      ForkTreePendingChangeNode: {
        hash: 'BlockHash',
        number: 'BlockNumber',
        data: 'PendingChange',
        children: 'Vec<ForkTreePendingChangeNode>'
      },
      AuthoritySetChange: '(U64, BlockNumber)',
      AuthoritySetChanges: 'Vec<AuthoritySetChange>',
      AuthorityWeight: 'u64',
      DelayKind: {
        _enum: {
          Finalized: 'Null',
          Best: 'DelayKindBest'
        }
      },
      DelayKindBest: {
        medianLastFinalized: 'BlockNumber'
      },
      EncodedFinalityProofs: 'Bytes',
      GrandpaEquivocation: {
        _enum: {
          Prevote: 'GrandpaEquivocationValue',
          Precommit: 'GrandpaEquivocationValue'
        }
      },
      GrandpaEquivocationProof: {
        setId: 'SetId',
        equivocation: 'GrandpaEquivocation'
      },
      GrandpaEquivocationValue: {
        roundNumber: 'u64',
        identity: 'AuthorityId',
        first: '(GrandpaPrevote, AuthoritySignature)',
        second: '(GrandpaPrevote, AuthoritySignature)'
      },
      GrandpaPrevote: {
        targetHash: 'Hash',
        targetNumber: 'BlockNumber'
      },
      GrandpaCommit: {
        targetHash: 'BlockHash',
        targetNumber: 'BlockNumber',
        precommits: 'Vec<GrandpaSignedPrecommit>'
      },
      GrandpaPrecommit: {
        targetHash: 'BlockHash',
        targetNumber: 'BlockNumber'
      },
      GrandpaSignedPrecommit: {
        precommit: 'GrandpaPrecommit',
        signature: 'AuthoritySignature',
        id: 'AuthorityId'
      },
      GrandpaJustification: {
        round: 'u64',
        commit: 'GrandpaCommit',
        votesAncestries: 'Vec<Header>'
      },
      JustificationNotification: 'Bytes',
      KeyOwnerProof: 'MembershipProof',
      NextAuthority: '(AuthorityId, AuthorityWeight)',
      PendingChange: {
        nextAuthorities: 'AuthorityList',
        delay: 'BlockNumber',
        canonHeight: 'BlockNumber',
        canonHash: 'BlockHash',
        delayKind: 'DelayKind'
      },
      PendingPause: {
        scheduledAt: 'BlockNumber',
        delay: 'BlockNumber'
      },
      PendingResume: {
        scheduledAt: 'BlockNumber',
        delay: 'BlockNumber'
      },
      Precommits: {
        currentWeight: 'u32',
        missing: 'BTreeSet<AuthorityId>'
      },
      Prevotes: {
        currentWeight: 'u32',
        missing: 'BTreeSet<AuthorityId>'
      },
      ReportedRoundStates: {
        setId: 'u32',
        best: 'RoundState',
        background: 'Vec<RoundState>'
      },
      RoundState: {
        round: 'u32',
        totalWeight: 'u32',
        thresholdWeight: 'u32',
        prevotes: 'Prevotes',
        precommits: 'Precommits'
      },
      SetId: 'u64',
      StoredPendingChange: {
        scheduledAt: 'BlockNumber',
        delay: 'BlockNumber',
        nextAuthorities: 'AuthorityList'
      },
      StoredState: {
        _enum: {
          Live: 'Null',
          PendingPause: 'PendingPause',
          Paused: 'Null',
          PendingResume: 'PendingResume'
        }
      }
    }
  };

  const definitions$D = {
    rpc: {},
    types: {
      IdentityFields: {
        _set: {
          _bitLength: 64,
          Display: 0b00000000000000000000000000000001,
          Legal: 0b00000000000000000000000000000010,
          Web: 0b00000000000000000000000000000100,
          Riot: 0b00000000000000000000000000001000,
          Email: 0b00000000000000000000000000010000,
          PgpFingerprint: 0b00000000000000000000000000100000,
          Image: 0b00000000000000000000000001000000,
          Twitter: 0b00000000000000000000000010000000
        }
      },
      IdentityInfoAdditional: '(Data, Data)',
      IdentityInfoTo198: {
        additional: 'Vec<IdentityInfoAdditional>',
        display: 'Data',
        legal: 'Data',
        web: 'Data',
        riot: 'Data',
        email: 'Data',
        pgpFingerprint: 'Option<H160>',
        image: 'Data'
      },
      IdentityInfo: {
        _fallback: 'IdentityInfoTo198',
        additional: 'Vec<IdentityInfoAdditional>',
        display: 'Data',
        legal: 'Data',
        web: 'Data',
        riot: 'Data',
        email: 'Data',
        pgpFingerprint: 'Option<H160>',
        image: 'Data',
        twitter: 'Data'
      },
      IdentityJudgement: {
        _enum: {
          Unknown: 'Null',
          FeePaid: 'Balance',
          Reasonable: 'Null',
          KnownGood: 'Null',
          OutOfDate: 'Null',
          LowQuality: 'Null',
          Erroneous: 'Null'
        }
      },
      RegistrationJudgement: '(RegistrarIndex, IdentityJudgement)',
      RegistrationTo198: {
        judgements: 'Vec<RegistrationJudgement>',
        deposit: 'Balance',
        info: 'IdentityInfoTo198'
      },
      Registration: {
        _fallback: 'RegistrationTo198',
        judgements: 'Vec<RegistrationJudgement>',
        deposit: 'Balance',
        info: 'IdentityInfo'
      },
      RegistrarIndex: 'u32',
      RegistrarInfo: {
        account: 'AccountId',
        fee: 'Balance',
        fields: 'IdentityFields'
      }
    }
  };

  const definitions$C = {
    rpc: {},
    types: {
      AuthIndex: 'u32',
      AuthoritySignature: 'Signature',
      Heartbeat: {
        blockNumber: 'BlockNumber',
        networkState: 'OpaqueNetworkState',
        sessionIndex: 'SessionIndex',
        authorityIndex: 'AuthIndex',
        validatorsLen: 'u32'
      },
      HeartbeatTo244: {
        blockNumber: 'BlockNumber',
        networkState: 'OpaqueNetworkState',
        sessionIndex: 'SessionIndex',
        authorityIndex: 'AuthIndex'
      },
      OpaqueMultiaddr: 'Bytes',
      OpaquePeerId: 'Bytes',
      OpaqueNetworkState: {
        peerId: 'OpaquePeerId',
        externalAddresses: 'Vec<OpaqueMultiaddr>'
      }
    }
  };

  const definitions$B = {
    rpc: {},
    types: {
      CallIndex: '(u8, u8)',
      LotteryConfig: {
        price: 'Balance',
        start: 'BlockNumber',
        length: 'BlockNumber',
        delay: 'BlockNumber',
        repeat: 'bool'
      }
    }
  };

  const definitions$A = {
    rpc: {
      generateProof: {
        description: 'Generate MMR proof for given leaf index.',
        params: [{
          name: 'leafIndex',
          type: 'u64'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'MmrLeafProof'
      }
    },
    types: {
      MmrLeafProof: {
        blockHash: 'BlockHash',
        leaf: 'Bytes',
        proof: 'Bytes'
      }
    }
  };

  const definitions$z = {
    rpc: {},
    types: {
      DeferredOffenceOf: '(Vec<OffenceDetails>, Vec<Perbill>, SessionIndex)',
      Kind: '[u8; 16]',
      OffenceDetails: {
        offender: 'Offender',
        reporters: 'Vec<Reporter>'
      },
      Offender: 'IdentificationTuple',
      OpaqueTimeSlot: 'Bytes',
      ReportIdOf: 'Hash',
      Reporter: 'AccountId'
    }
  };

  const definitions$y = {
    rpc: {},
    types: {
      ProxyDefinition: {
        delegate: 'AccountId',
        proxyType: 'ProxyType',
        delay: 'BlockNumber'
      },
      ProxyType: {
        _enum: ['Any', 'NonTransfer', 'Governance', 'Staking']
      },
      ProxyAnnouncement: {
        real: 'AccountId',
        callHash: 'Hash',
        height: 'BlockNumber'
      }
    }
  };

  const definitions$x = {
    rpc: {},
    types: {
      ActiveRecovery: {
        created: 'BlockNumber',
        deposit: 'Balance',
        friends: 'Vec<AccountId>'
      },
      RecoveryConfig: {
        delayPeriod: 'BlockNumber',
        deposit: 'Balance',
        friends: 'Vec<AccountId>',
        threshold: 'u16'
      }
    }
  };

  const definitions$w = {
    rpc: {},
    types: {
      Period: '(BlockNumber, u32)',
      Priority: 'u8',
      SchedulePeriod: 'Period',
      SchedulePriority: 'Priority',
      Scheduled: {
        maybeId: 'Option<Bytes>',
        priority: 'SchedulePriority',
        call: 'Call',
        maybePeriodic: 'Option<SchedulePeriod>',
        origin: 'PalletsOrigin'
      },
      ScheduledTo254: {
        maybeId: 'Option<Bytes>',
        priority: 'SchedulePriority',
        call: 'Call',
        maybePeriodic: 'Option<SchedulePeriod>'
      },
      TaskAddress: '(BlockNumber, u32)'
    }
  };

  const keyTypes = {
    BeefyKey: '[u8; 33]',
    Keys: 'SessionKeys4',
    SessionKeys1: '(AccountId)',
    SessionKeys2: '(AccountId, AccountId)',
    SessionKeys3: '(AccountId, AccountId, AccountId)',
    SessionKeys4: '(AccountId, AccountId, AccountId, AccountId)',
    SessionKeys5: '(AccountId, AccountId, AccountId, AccountId, AccountId)',
    SessionKeys6: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)',
    SessionKeys6B: '(AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)',
    SessionKeys7: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)',
    SessionKeys7B: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)',
    SessionKeys8: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)',
    SessionKeys8B: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)',
    SessionKeys9: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)',
    SessionKeys9B: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)',
    SessionKeys10: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId)',
    SessionKeys10B: '(AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, AccountId, BeefyKey)'
  };
  const definitions$v = {
    rpc: {},
    types: objectSpread$1({}, keyTypes, {
      FullIdentification: 'Exposure',
      IdentificationTuple: '(ValidatorId, FullIdentification)',
      MembershipProof: {
        session: 'SessionIndex',
        trieNodes: 'Vec<Vec<u8>>',
        validatorCount: 'ValidatorCount'
      },
      SessionIndex: 'u32',
      ValidatorCount: 'u32'
    })
  };

  const definitions$u = {
    rpc: {},
    types: {
      Bid: {
        who: 'AccountId',
        kind: 'BidKind',
        value: 'Balance'
      },
      BidKind: {
        _enum: {
          Deposit: 'Balance',
          Vouch: '(AccountId, Balance)'
        }
      },
      SocietyJudgement: {
        _enum: ['Rebid', 'Reject', 'Approve']
      },
      SocietyVote: {
        _enum: ['Skeptic', 'Reject', 'Approve']
      },
      StrikeCount: 'u32',
      VouchingStatus: {
        _enum: ['Vouching', 'Banned']
      }
    }
  };

  const deprecated = {
    Points: 'u32',
    EraPoints: {
      total: 'Points',
      individual: 'Vec<Points>'
    }
  };
  const phragmen = {
    CompactAssignments: 'CompactAssignmentsWith16',
    CompactAssignmentsWith16: {
      votes1: 'Vec<(NominatorIndexCompact, ValidatorIndexCompact)>',
      votes2: 'Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>',
      votes3: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>',
      votes4: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>',
      votes5: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>',
      votes6: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>',
      votes7: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>',
      votes8: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>',
      votes9: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>',
      votes10: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>',
      votes11: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>',
      votes12: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>',
      votes13: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>',
      votes14: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>',
      votes15: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>',
      votes16: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>'
    },
    CompactAssignmentsWith24: {
      votes1: 'Vec<(NominatorIndexCompact, ValidatorIndexCompact)>',
      votes2: 'Vec<(NominatorIndexCompact, CompactScoreCompact, ValidatorIndexCompact)>',
      votes3: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 2], ValidatorIndexCompact)>',
      votes4: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 3], ValidatorIndexCompact)>',
      votes5: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 4], ValidatorIndexCompact)>',
      votes6: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 5], ValidatorIndexCompact)>',
      votes7: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 6], ValidatorIndexCompact)>',
      votes8: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 7], ValidatorIndexCompact)>',
      votes9: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 8], ValidatorIndexCompact)>',
      votes10: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 9], ValidatorIndexCompact)>',
      votes11: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 10], ValidatorIndexCompact)>',
      votes12: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 11], ValidatorIndexCompact)>',
      votes13: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 12], ValidatorIndexCompact)>',
      votes14: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 13], ValidatorIndexCompact)>',
      votes15: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 14], ValidatorIndexCompact)>',
      votes16: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 15], ValidatorIndexCompact)>',
      votes17: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 16], ValidatorIndexCompact)>',
      votes18: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 17], ValidatorIndexCompact)>',
      votes19: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 18], ValidatorIndexCompact)>',
      votes20: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 19], ValidatorIndexCompact)>',
      votes21: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 20], ValidatorIndexCompact)>',
      votes22: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 21], ValidatorIndexCompact)>',
      votes23: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 22], ValidatorIndexCompact)>',
      votes24: 'Vec<(NominatorIndexCompact, [CompactScoreCompact; 23], ValidatorIndexCompact)>'
    },
    CompactAssignmentsTo265: 'CompactAssignmentsWith16',
    CompactAssignmentsTo257: {
      votes1: 'Vec<(NominatorIndex, [CompactScore; 0], ValidatorIndex)>',
      votes2: 'Vec<(NominatorIndex, [CompactScore; 1], ValidatorIndex)>',
      votes3: 'Vec<(NominatorIndex, [CompactScore; 2], ValidatorIndex)>',
      votes4: 'Vec<(NominatorIndex, [CompactScore; 3], ValidatorIndex)>',
      votes5: 'Vec<(NominatorIndex, [CompactScore; 4], ValidatorIndex)>',
      votes6: 'Vec<(NominatorIndex, [CompactScore; 5], ValidatorIndex)>',
      votes7: 'Vec<(NominatorIndex, [CompactScore; 6], ValidatorIndex)>',
      votes8: 'Vec<(NominatorIndex, [CompactScore; 7], ValidatorIndex)>',
      votes9: 'Vec<(NominatorIndex, [CompactScore; 8], ValidatorIndex)>',
      votes10: 'Vec<(NominatorIndex, [CompactScore; 9], ValidatorIndex)>',
      votes11: 'Vec<(NominatorIndex, [CompactScore; 10], ValidatorIndex)>',
      votes12: 'Vec<(NominatorIndex, [CompactScore; 11], ValidatorIndex)>',
      votes13: 'Vec<(NominatorIndex, [CompactScore; 12], ValidatorIndex)>',
      votes14: 'Vec<(NominatorIndex, [CompactScore; 13], ValidatorIndex)>',
      votes15: 'Vec<(NominatorIndex, [CompactScore; 14], ValidatorIndex)>',
      votes16: 'Vec<(NominatorIndex, [CompactScore; 15], ValidatorIndex)>'
    },
    CompactScore: '(ValidatorIndex, OffchainAccuracy)',
    CompactScoreCompact: '(ValidatorIndexCompact, OffchainAccuracyCompact)',
    ElectionCompute: {
      _enum: ['OnChain', 'Signed', 'Unsigned']
    },
    ElectionPhase: {
      _enum: {
        Off: null,
        Signed: null,
        Unsigned: '(bool, BlockNumber)',
        Emergency: null
      }
    },
    ElectionResult: {
      compute: 'ElectionCompute',
      slotStake: 'Balance',
      electedStashes: 'Vec<AccountId>',
      exposures: 'Vec<(AccountId, Exposure)>'
    },
    ElectionScore: '[u128; 3]',
    ElectionSize: {
      validators: 'Compact<ValidatorIndex>',
      nominators: 'Compact<NominatorIndex>'
    },
    ElectionStatus: {
      _enum: {
        Close: 'Null',
        Open: 'BlockNumber'
      }
    },
    ExtendedBalance: 'u128',
    RawSolution: 'RawSolutionWith16',
    RawSolutionWith16: {
      compact: 'CompactAssignmentsWith16',
      score: 'ElectionScore',
      round: 'u32'
    },
    RawSolutionWith24: {
      compact: 'CompactAssignmentsWith24',
      score: 'ElectionScore',
      round: 'u32'
    },
    RawSolutionTo265: 'RawSolutionWith16',
    ReadySolution: {
      supports: 'SolutionSupports',
      score: 'ElectionScore',
      compute: 'ElectionCompute'
    },
    RoundSnapshot: {
      voters: 'Vec<(AccountId, VoteWeight, Vec<AccountId>)>',
      targets: 'Vec<AccountId>'
    },
    SeatHolder: {
      who: 'AccountId',
      stake: 'Balance',
      deposit: 'Balance'
    },
    SignedSubmission: {
      _fallback: 'SignedSubmissionTo276',
      who: 'AccountId',
      deposit: 'Balance',
      solution: 'RawSolution',
      reward: 'Balance'
    },
    SignedSubmissionTo276: {
      who: 'AccountId',
      deposit: 'Balance',
      solution: 'RawSolution'
    },
    SignedSubmissionOf: 'SignedSubmission',
    SolutionOrSnapshotSize: {
      voters: 'Compact<u32>',
      targets: 'Compact<u32>'
    },
    SolutionSupport: {
      total: 'ExtendedBalance',
      voters: 'Vec<(AccountId, ExtendedBalance)>'
    },
    SolutionSupports: 'Vec<(AccountId, SolutionSupport)>',
    Supports: 'SolutionSupports',
    SubmissionIndicesOf: 'BTreeMap<ElectionScore, u32>',
    Voter: {
      votes: 'Vec<AccountId>',
      stake: 'Balance',
      deposit: 'Balance'
    },
    VoteWeight: 'u64'
  };
  const definitions$t = {
    rpc: {},
    types: objectSpread$1({}, deprecated, phragmen, {
      ActiveEraInfo: {
        index: 'EraIndex',
        start: 'Option<Moment>'
      },
      EraIndex: 'u32',
      EraRewardPoints: {
        total: 'RewardPoint',
        individual: 'BTreeMap<AccountId, RewardPoint>'
      },
      EraRewards: {
        total: 'u32',
        rewards: 'Vec<u32>'
      },
      Exposure: {
        total: 'Compact<Balance>',
        own: 'Compact<Balance>',
        others: 'Vec<IndividualExposure>'
      },
      Forcing: {
        _enum: ['NotForcing', 'ForceNew', 'ForceNone', 'ForceAlways']
      },
      IndividualExposure: {
        who: 'AccountId',
        value: 'Compact<Balance>'
      },
      KeyType: 'AccountId',
      MomentOf: 'Moment',
      Nominations: {
        targets: 'Vec<AccountId>',
        submittedIn: 'EraIndex',
        suppressed: 'bool'
      },
      NominatorIndex: 'u32',
      NominatorIndexCompact: 'Compact<NominatorIndex>',
      OffchainAccuracy: 'PerU16',
      OffchainAccuracyCompact: 'Compact<OffchainAccuracy>',
      PhragmenScore: '[u128; 3]',
      Points: 'u32',
      RewardDestination: {
        _enum: {
          Staked: 'Null',
          Stash: 'Null',
          Controller: 'Null',
          Account: 'AccountId',
          None: 'Null'
        }
      },
      RewardPoint: 'u32',
      SlashJournalEntry: {
        who: 'AccountId',
        amount: 'Balance',
        ownSlash: 'Balance'
      },
      SlashingSpansTo204: {
        spanIndex: 'SpanIndex',
        lastStart: 'EraIndex',
        prior: 'Vec<EraIndex>'
      },
      SlashingSpans: {
        spanIndex: 'SpanIndex',
        lastStart: 'EraIndex',
        lastNonzeroSlash: 'EraIndex',
        prior: 'Vec<EraIndex>'
      },
      SpanIndex: 'u32',
      SpanRecord: {
        slashed: 'Balance',
        paidOut: 'Balance'
      },
      StakingLedgerTo223: {
        stash: 'AccountId',
        total: 'Compact<Balance>',
        active: 'Compact<Balance>',
        unlocking: 'Vec<UnlockChunk>'
      },
      StakingLedgerTo240: {
        stash: 'AccountId',
        total: 'Compact<Balance>',
        active: 'Compact<Balance>',
        unlocking: 'Vec<UnlockChunk>',
        lastReward: 'Option<EraIndex>'
      },
      StakingLedger: {
        stash: 'AccountId',
        total: 'Compact<Balance>',
        active: 'Compact<Balance>',
        unlocking: 'Vec<UnlockChunk>',
        claimedRewards: 'Vec<EraIndex>'
      },
      UnappliedSlashOther: '(AccountId, Balance)',
      UnappliedSlash: {
        validator: 'AccountId',
        own: 'Balance',
        others: 'Vec<UnappliedSlashOther>',
        reporters: 'Vec<AccountId>',
        payout: 'Balance'
      },
      UnlockChunk: {
        value: 'Compact<Balance>',
        era: 'Compact<BlockNumber>'
      },
      ValidatorIndex: 'u16',
      ValidatorIndexCompact: 'Compact<ValidatorIndex>',
      ValidatorPrefs: 'ValidatorPrefsWithBlocked',
      ValidatorPrefsWithCommission: {
        commission: 'Compact<Perbill>'
      },
      ValidatorPrefsWithBlocked: {
        commission: 'Compact<Perbill>',
        blocked: 'bool'
      },
      ValidatorPrefsTo196: {
        validatorPayment: 'Compact<Balance>'
      },
      ValidatorPrefsTo145: {
        unstakeThreshold: 'Compact<u32>',
        validatorPayment: 'Compact<Balance>'
      }
    })
  };

  const definitions$s = {
    rpc: {},
    types: {
      WeightToFeeCoefficient: {
        coeffInteger: 'Balance',
        coeffFrac: 'Perbill',
        negative: 'bool',
        degree: 'u8'
      }
    }
  };

  const definitions$r = {
    rpc: {
      genSyncSpec: {
        endpoint: 'sync_state_genSyncSpec',
        description: 'Returns the json-serialized chainspec running the node, with a sync state.',
        params: [{
          name: 'raw',
          type: 'bool'
        }],
        type: 'Json'
      }
    },
    types: {}
  };

  const definitions$q = {
    rpc: {
      accountNextIndex: {
        alias: ['account_nextIndex'],
        description: 'Retrieves the next accountIndex as available on the node',
        params: [{
          name: 'accountId',
          type: 'AccountId'
        }],
        type: 'Index'
      },
      dryRun: {
        alias: ['system_dryRunAt'],
        description: 'Dry run an extrinsic at a given block',
        params: [{
          name: 'extrinsic',
          type: 'Bytes'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'ApplyExtrinsicResult'
      },
      name: {
        description: 'Retrieves the node name',
        params: [],
        type: 'Text'
      },
      version: {
        description: 'Retrieves the version of the node',
        params: [],
        type: 'Text'
      },
      chain: {
        description: 'Retrieves the chain',
        params: [],
        type: 'Text'
      },
      chainType: {
        description: 'Retrieves the chain type',
        params: [],
        type: 'ChainType'
      },
      properties: {
        description: 'Get a custom set of properties as a JSON object, defined in the chain spec',
        params: [],
        type: 'ChainProperties'
      },
      health: {
        description: 'Return health status of the node',
        params: [],
        type: 'Health'
      },
      localPeerId: {
        description: 'Returns the base58-encoded PeerId of the node',
        params: [],
        type: 'Text'
      },
      localListenAddresses: {
        description: 'The addresses include a trailing /p2p/ with the local PeerId, and are thus suitable to be passed to addReservedPeer or as a bootnode address for example',
        params: [],
        type: 'Vec<Text>'
      },
      peers: {
        description: 'Returns the currently connected peers',
        params: [],
        type: 'Vec<PeerInfo>'
      },
      networkState: {
        alias: ['system_unstable_networkState'],
        description: 'Returns current state of the network',
        params: [],
        type: 'NetworkState'
      },
      addReservedPeer: {
        description: 'Adds a reserved peer',
        params: [{
          name: 'peer',
          type: 'Text'
        }],
        type: 'Text'
      },
      removeReservedPeer: {
        description: 'Remove a reserved peer',
        params: [{
          name: 'peerId',
          type: 'Text'
        }],
        type: 'Text'
      },
      reservedPeers: {
        description: 'Returns the list of reserved peers',
        params: [],
        type: 'Vec<Text>'
      },
      nodeRoles: {
        description: 'Returns the roles the node is running as',
        params: [],
        type: 'Vec<NodeRole>'
      },
      syncState: {
        description: 'Returns the state of the syncing of the node',
        params: [],
        type: 'SyncState'
      },
      addLogFilter: {
        description: 'Adds the supplied directives to the current log filter',
        params: [{
          name: 'directives',
          type: 'Text'
        }],
        type: 'Null'
      },
      resetLogFilter: {
        description: 'Resets the log filter to Substrate defaults',
        params: [],
        type: 'Null'
      }
    },
    types: {
      AccountInfo: 'AccountInfoWithTripleRefCount',
      AccountInfoWithRefCountU8: {
        nonce: 'Index',
        refcount: 'u8',
        data: 'AccountData'
      },
      AccountInfoWithRefCount: {
        _fallback: 'AccountInfoWithRefCountU8',
        nonce: 'Index',
        refcount: 'RefCount',
        data: 'AccountData'
      },
      AccountInfoWithDualRefCount: {
        _fallback: 'AccountInfoWithRefCount',
        nonce: 'Index',
        consumers: 'RefCount',
        providers: 'RefCount',
        data: 'AccountData'
      },
      AccountInfoWithProviders: 'AccountInfoWithDualRefCount',
      AccountInfoWithTripleRefCount: {
        _fallback: 'AccountInfoWithDualRefCount',
        nonce: 'Index',
        consumers: 'RefCount',
        providers: 'RefCount',
        sufficients: 'RefCount',
        data: 'AccountData'
      },
      ApplyExtrinsicResult: 'Result<DispatchOutcome, TransactionValidityError>',
      ArithmeticError: {
        _enum: ['Underflow', 'Overflow', 'DivisionByZero']
      },
      BlockLength: {
        max: 'PerDispatchClassU32'
      },
      BlockWeights: {
        baseBlock: 'Weight',
        maxBlock: 'Weight',
        perClass: 'PerDispatchClassWeightsPerClass'
      },
      ChainProperties: 'GenericChainProperties',
      ChainType: {
        _enum: {
          Development: 'Null',
          Local: 'Null',
          Live: 'Null',
          Custom: 'Text'
        }
      },
      ConsumedWeight: 'PerDispatchClassWeight',
      DigestOf: 'Digest',
      DispatchClass: {
        _enum: ['Normal', 'Operational', 'Mandatory']
      },
      DispatchError: {
        _enum: {
          Other: 'Null',
          CannotLookup: 'Null',
          BadOrigin: 'Null',
          Module: 'DispatchErrorModule',
          ConsumerRemaining: 'Null',
          NoProviders: 'Null',
          Token: 'TokenError',
          Arithmetic: 'ArithmeticError'
        }
      },
      DispatchErrorModule: {
        index: 'u8',
        error: 'u8'
      },
      DispatchErrorTo198: {
        module: 'Option<u8>',
        error: 'u8'
      },
      DispatchInfo: {
        weight: 'Weight',
        class: 'DispatchClass',
        paysFee: 'Pays'
      },
      DispatchInfoTo190: {
        weight: 'Weight',
        class: 'DispatchClass'
      },
      DispatchInfoTo244: {
        weight: 'Weight',
        class: 'DispatchClass',
        paysFee: 'bool'
      },
      DispatchOutcome: 'Result<(), DispatchError>',
      DispatchResult: 'Result<(), DispatchError>',
      DispatchResultOf: 'DispatchResult',
      DispatchResultTo198: 'Result<(), Text>',
      Event: 'GenericEvent',
      EventId: '[u8; 2]',
      EventIndex: 'u32',
      EventRecord: {
        phase: 'Phase',
        event: 'Event',
        topics: 'Vec<Hash>'
      },
      Health: {
        peers: 'u64',
        isSyncing: 'bool',
        shouldHavePeers: 'bool'
      },
      InvalidTransaction: {
        _enum: {
          Call: 'Null',
          Payment: 'Null',
          Future: 'Null',
          Stale: 'Null',
          BadProof: 'Null',
          AncientBirthBlock: 'Null',
          ExhaustsResources: 'Null',
          Custom: 'u8',
          BadMandatory: 'Null',
          MandatoryDispatch: 'Null'
        }
      },
      Key: 'Bytes',
      LastRuntimeUpgradeInfo: {
        specVersion: 'Compact<u32>',
        specName: 'Text'
      },
      NetworkState: {
        peerId: 'Text',
        listenedAddresses: 'Vec<Text>',
        externalAddresses: 'Vec<Text>',
        connectedPeers: 'HashMap<Text, Peer>',
        notConnectedPeers: 'HashMap<Text, NotConnectedPeer>',
        averageDownloadPerSec: 'u64',
        averageUploadPerSec: 'u64',
        peerset: 'NetworkStatePeerset'
      },
      NetworkStatePeerset: {
        messageQueue: 'u64',
        nodes: 'HashMap<Text, NetworkStatePeersetInfo>'
      },
      NetworkStatePeersetInfo: {
        connected: 'bool',
        reputation: 'i32'
      },
      NodeRole: {
        _enum: {
          Full: 'Null',
          LightClient: 'Null',
          Authority: 'Null',
          UnknownRole: 'u8'
        }
      },
      NotConnectedPeer: {
        knownAddresses: 'Vec<Text>',
        latestPingTime: 'Option<PeerPing>',
        versionString: 'Option<Text>'
      },
      Peer: {
        enabled: 'bool',
        endpoint: 'PeerEndpoint',
        knownAddresses: 'Vec<Text>',
        latestPingTime: 'PeerPing',
        open: 'bool',
        versionString: 'Text'
      },
      PeerEndpoint: {
        listening: 'PeerEndpointAddr'
      },
      PeerEndpointAddr: {
        _alias: {
          localAddr: 'local_addr',
          sendBackAddr: 'send_back_addr'
        },
        localAddr: 'Text',
        sendBackAddr: 'Text'
      },
      PeerPing: {
        nanos: 'u64',
        secs: 'u64'
      },
      PeerInfo: {
        peerId: 'Text',
        roles: 'Text',
        protocolVersion: 'u32',
        bestHash: 'Hash',
        bestNumber: 'BlockNumber'
      },
      PerDispatchClassU32: {
        normal: 'u32',
        operational: 'u32',
        mandatory: 'u32'
      },
      PerDispatchClassWeight: {
        normal: 'Weight',
        operational: 'Weight',
        mandatory: 'Weight'
      },
      PerDispatchClassWeightsPerClass: {
        normal: 'WeightPerClass',
        operational: 'WeightPerClass',
        mandatory: 'WeightPerClass'
      },
      Phase: {
        _enum: {
          ApplyExtrinsic: 'u32',
          Finalization: 'Null',
          Initialization: 'Null'
        }
      },
      RawOrigin: {
        _enum: {
          Root: 'Null',
          Signed: 'AccountId',
          None: 'Null'
        }
      },
      RefCount: 'u32',
      RefCountTo259: 'u8',
      SyncState: {
        startingBlock: 'BlockNumber',
        currentBlock: 'BlockNumber',
        highestBlock: 'Option<BlockNumber>'
      },
      SystemOrigin: 'RawOrigin',
      TokenError: {
        _enum: ['NoFunds', 'WouldDie', 'BelowMinimum', 'CannotCreate', 'UnknownAsset', 'Frozen',
        'Underflow', 'Overflow']
      },
      TransactionValidityError: {
        _enum: {
          Invalid: 'InvalidTransaction',
          Unknown: 'UnknownTransaction'
        }
      },
      UnknownTransaction: {
        _enum: {
          CannotLookup: 'Null',
          NoUnsignedValidator: 'Null',
          Custom: 'u8'
        }
      },
      WeightPerClass: {
        baseExtrinsic: 'Weight',
        maxExtrinsic: 'Weight',
        maxTotal: 'Option<Weight>',
        reserved: 'Option<Weight>'
      }
    }
  };

  const definitions$p = {
    rpc: {},
    types: {
      Bounty: {
        proposer: 'AccountId',
        value: 'Balance',
        fee: 'Balance',
        curatorDeposit: 'Balance',
        bond: 'Balance',
        status: 'BountyStatus'
      },
      BountyIndex: 'u32',
      BountyStatus: {
        _enum: {
          Proposed: 'Null',
          Approved: 'Null',
          Funded: 'Null',
          CuratorProposed: 'BountyStatusCuratorProposed',
          Active: 'BountyStatusActive',
          PendingPayout: 'BountyStatusPendingPayout'
        }
      },
      BountyStatusActive: {
        curator: 'AccountId',
        updateDue: 'BlockNumber'
      },
      BountyStatusCuratorProposed: {
        curator: 'AccountId'
      },
      BountyStatusPendingPayout: {
        curator: 'AccountId',
        beneficiary: 'AccountId',
        unlockAt: 'BlockNumber'
      },
      OpenTip: {
        reason: 'Hash',
        who: 'AccountId',
        finder: 'AccountId',
        deposit: 'Balance',
        closes: 'Option<BlockNumber>',
        tips: 'Vec<OpenTipTip>',
        findersFee: 'bool'
      },
      OpenTipTo225: {
        reason: 'Hash',
        who: 'AccountId',
        finder: 'Option<OpenTipFinderTo225>',
        closes: 'Option<BlockNumber>',
        tips: 'Vec<OpenTipTip>'
      },
      OpenTipFinderTo225: '(AccountId, Balance)',
      OpenTipTip: '(AccountId, Balance)',
      TreasuryProposal: {
        proposer: 'AccountId',
        value: 'Balance',
        beneficiary: 'AccountId',
        bond: 'Balance'
      }
    }
  };

  const definitions$o = {
    rpc: {},
    types: {
      Multiplier: 'Fixed128'
    }
  };

  const definitions$n = {
    rpc: {},
    types: {
      ClassId: 'u32',
      InstanceId: 'u32',
      DepositBalance: 'Balance',
      DepositBalanceOf: 'Balance',
      ClassDetails: {
        owner: 'AccountId',
        issuer: 'AccountId',
        admin: 'AccountId',
        freezer: 'AccountId',
        totalDeposit: 'DepositBalance',
        freeHolding: 'bool',
        instances: 'u32',
        instanceMetadatas: 'u32',
        attributes: 'u32',
        isFrozen: 'bool'
      },
      DestroyWitness: {
        instances: 'Compact<u32>',
        instanceMetadatas: 'Compact<u32>',
        attributes: 'Compact<u32>'
      },
      InstanceDetails: {
        owner: 'AccountId',
        approved: 'Option<AccountId>',
        isFrozen: 'bool',
        deposit: 'DepositBalance'
      },
      ClassMetadata: {
        deposit: 'DepositBalance',
        data: 'Vec<u8>',
        isFrozen: 'bool'
      },
      InstanceMetadata: {
        deposit: 'DepositBalance',
        data: 'Vec<u8>',
        isFrozen: 'bool'
      }
    }
  };

  const definitions$m = {
    rpc: {},
    types: {
      Multisig: {
        when: 'Timepoint',
        deposit: 'Balance',
        depositor: 'AccountId',
        approvals: 'Vec<AccountId>'
      },
      Timepoint: {
        height: 'BlockNumber',
        index: 'u32'
      }
    }
  };

  const definitions$l = {
    rpc: {},
    types: {
      VestingInfo: {
        locked: 'Balance',
        perBlock: 'Balance',
        startingBlock: 'BlockNumber'
      }
    }
  };

  const definitions$k = {
    rpc: {},
    types: {
      BlockAttestations: {
        receipt: 'CandidateReceipt',
        valid: 'Vec<AccountId>',
        invalid: 'Vec<AccountId>'
      },
      IncludedBlocks: {
        actualNumber: 'BlockNumber',
        session: 'SessionIndex',
        randomSeed: 'H256',
        activeParachains: 'Vec<ParaId>',
        paraBlocks: 'Vec<Hash>'
      },
      MoreAttestations: {}
    }
  };

  const definitions$j = {
    rpc: {},
    types: {
      BridgedBlockHash: 'H256',
      BridgedBlockNumber: 'BlockNumber',
      BridgedHeader: 'Header',
      BridgeMessageId: '(LaneId, MessageNonce)',
      CallOrigin: {
        _enum: {
          SourceRoot: 'Null',
          TargetAccount: '(AccountId, MultiSigner, MultiSignature)',
          SourceAccount: 'AccountId'
        }
      },
      ChainId: '[u8; 4]',
      DeliveredMessages: {
        begin: 'MessageNonce',
        end: 'MessageNonce',
        dispatchResults: 'BitVec'
      },
      DispatchFeePayment: {
        _enum: ['AtSourceChain', 'AtTargetChain']
      },
      InboundLaneData: {
        relayers: 'Vec<UnrewardedRelayer>',
        lastConfirmedNonce: 'MessageNonce'
      },
      InboundRelayer: 'AccountId',
      InitializationData: {
        header: 'Header',
        authorityList: 'AuthorityList',
        setId: 'SetId',
        isHalted: 'bool'
      },
      LaneId: '[u8; 4]',
      MessageData: {
        payload: 'Bytes',
        fee: 'Balance'
      },
      MessagesDeliveryProofOf: {
        bridgedHeaderHash: 'BlockHash',
        storageProof: 'Vec<Bytes>',
        lane: 'LaneId'
      },
      MessageKey: {
        laneId: 'LaneId',
        nonce: 'MessageNonce'
      },
      MessageNonce: 'u64',
      MessagesProofOf: {
        bridgedHeaderHash: 'BridgedBlockHash',
        storageProof: 'Vec<Bytes>',
        lane: 'LaneId',
        noncesStart: 'MessageNonce',
        noncesEnd: 'MessageNonce'
      },
      OperatingMode: {
        _enum: ['Normal', 'RejectingOutboundMessages', 'Halted']
      },
      OutboundLaneData: {
        oldestUnprunedNonce: 'MessageNonce',
        latestReceivedNonce: 'MessageNonce',
        latestGeneratedNonce: 'MessageNonce'
      },
      OutboundMessageFee: 'Balance',
      OutboundPayload: {
        specVersion: 'u32',
        weight: 'Weight',
        origin: 'CallOrigin',
        dispatchFeePayment: 'DispatchFeePayment',
        call: 'Bytes'
      },
      Parameter: 'Null',
      RelayerId: 'AccountId',
      UnrewardedRelayer: {
        relayer: 'RelayerId',
        messages: 'DeliveredMessages'
      },
      UnrewardedRelayersState: {
        unrewardedRelayer_Entries: 'MessageNonce',
        messagesInOldestEntry: 'MessageNonce',
        totalMessages: 'MessageNonce'
      }
    }
  };

  const definitions$i = {
    rpc: {},
    types: {
      StatementKind: {
        _enum: ['Regular', 'Saft']
      }
    }
  };

  const definitions$h = {
    rpc: {},
    types: {
      FundIndex: 'u32',
      LastContribution: {
        _enum: {
          Never: 'Null',
          PreEnding: 'u32',
          Ending: 'BlockNumber'
        }
      },
      FundInfo: {
        depositor: 'AccountId',
        verifier: 'Option<MultiSigner>',
        deposit: 'Balance',
        raised: 'Balance',
        end: 'BlockNumber',
        cap: 'Balance',
        lastContribution: 'LastContribution',
        firstPeriod: 'LeasePeriod',
        lastPeriod: 'LeasePeriod',
        trieIndex: 'TrieIndex'
      },
      TrieIndex: 'u32'
    }
  };

  const dmpQueue = {
    ConfigData: {
      maxIndividual: 'Weight'
    },
    MessageId: '[u8; 32]',
    OverweightIndex: 'u64',
    PageCounter: 'u32',
    PageIndexData: {
      beginUsed: 'PageCounter',
      endUsed: 'PageCounter',
      overweightCount: 'OverweightIndex'
    }
  };
  const definitions$g = {
    rpc: {},
    types: dmpQueue
  };

  const hrmpTypes = {
    HrmpChannel: {
      maxCapacity: 'u32',
      maxTotalSize: 'u32',
      maxMessageSize: 'u32',
      msgCount: 'u32',
      totalSize: 'u32',
      mqcHead: 'Option<Hash>',
      senderDeposit: 'Balance',
      recipientDeposit: 'Balance'
    },
    HrmpChannelId: {
      sender: 'u32',
      receiver: 'u32'
    },
    HrmpOpenChannelRequest: {
      confirmed: 'bool',
      age: 'SessionIndex',
      senderDeposit: 'Balance',
      maxMessageSize: 'u32',
      maxCapacity: 'u32',
      maxTotalSize: 'u32'
    }
  };

  const SLOT_RANGE_COUNT = 10;
  const oldTypes = {
    Bidder: {
      _enum: {
        New: 'NewBidder',
        Existing: 'ParaId'
      }
    },
    IncomingParachain: {
      _enum: {
        Unset: 'NewBidder',
        Fixed: 'IncomingParachainFixed',
        Deploy: 'IncomingParachainDeploy'
      }
    },
    IncomingParachainDeploy: {
      code: 'ValidationCode',
      initialHeadData: 'HeadData'
    },
    IncomingParachainFixed: {
      codeHash: 'Hash',
      codeSize: 'u32',
      initialHeadData: 'HeadData'
    },
    NewBidder: {
      who: 'AccountId',
      sub: 'SubId'
    },
    SubId: 'u32'
  };
  const slotTypes = objectSpread$1({}, oldTypes, {
    AuctionIndex: 'u32',
    LeasePeriod: 'BlockNumber',
    LeasePeriodOf: 'BlockNumber',
    SlotRange: {
      _enum: ['ZeroZero', 'ZeroOne', 'ZeroTwo', 'ZeroThree', 'OneOne', 'OneTwo', 'OneThree', 'TwoTwo', 'TwoThree', 'ThreeThree']
    },
    WinningData: `[WinningDataEntry; ${SLOT_RANGE_COUNT}]`,
    WinningDataEntry: 'Option<(AccountId, ParaId, BalanceOf)>',
    WinnersData: 'Vec<WinnersDataTuple>',
    WinnersDataTuple: '(AccountId, ParaId, BalanceOf, SlotRange)'
  });

  const proposeTypes = {
    ParachainProposal: {
      proposer: 'AccountId',
      genesisHead: 'HeadData',
      validators: 'Vec<ValidatorId>',
      name: 'Bytes',
      balance: 'Balance'
    },
    RegisteredParachainInfo: {
      validators: 'Vec<ValidatorId>',
      proposer: 'AccountId'
    }
  };
  const cumulusTypes = {
    ServiceQuality: {
      _enum: ['Ordered', 'Fast']
    }
  };
  const disputeTypes = {
    DisputeLocation: {
      _enum: ['Local', 'Remote']
    },
    DisputeResult: {
      _enum: ['Valid', 'Invalid']
    },
    DisputeState: {
      validatorsFor: 'BitVec',
      validatorsAgainst: 'BitVec',
      start: 'BlockNumber',
      concludedAt: 'Option<BlockNumber>'
    },
    DisputeStatement: {
      _enum: {
        Valid: 'ValidDisputeStatementKind',
        Invalid: 'InvalidDisputeStatementKind'
      }
    },
    DisputeStatementSet: {
      candidateHash: 'CandidateHash',
      session: 'SessionIndex',
      statements: 'Vec<(DisputeStatement, ParaValidatorIndex, ValidatorSignature)>'
    },
    ExplicitDisputeStatement: {
      valid: 'bool',
      candidateHash: 'CandidateHash',
      session: 'SessionIndex'
    },
    InvalidDisputeStatementKind: {
      _enum: ['Explicit']
    },
    MultiDisputeStatementSet: 'Vec<DisputeStatementSet>',
    ValidDisputeStatementKind: {
      _enum: {
        Explicit: 'Null',
        BackingSeconded: 'Hash',
        BackingValid: 'Hash',
        ApprovalChecking: 'Null'
      }
    }
  };
  const definitions$f = {
    rpc: {},
    types: objectSpread$1({}, cumulusTypes, disputeTypes, hrmpTypes, proposeTypes, slotTypes, {
      AbridgedCandidateReceipt: {
        parachainIndex: 'ParaId',
        relayParent: 'Hash',
        headData: 'HeadData',
        collator: 'CollatorId',
        signature: 'CollatorSignature',
        povBlockHash: 'Hash',
        commitments: 'CandidateCommitments'
      },
      AbridgedHostConfiguration: {
        maxCodeSize: 'u32',
        maxHeadDataSize: 'u32',
        maxUpwardQueueCount: 'u32',
        maxUpwardQueueSize: 'u32',
        maxUpwardMessageSize: 'u32',
        maxUpwardMessageNumPerCandidate: 'u32',
        hrmpMaxMessageNumPerCandidate: 'u32',
        validationUpgradeFrequency: 'BlockNumber',
        validationUpgradeDelay: 'BlockNumber'
      },
      AbridgedHrmpChannel: {
        maxCapacity: 'u32',
        maxTotalSize: 'u32',
        maxMessageSize: 'u32',
        msgCount: 'u32',
        totalSize: 'u32',
        mqcHead: 'Option<Hash>'
      },
      AssignmentId: 'AccountId',
      AssignmentKind: {
        _enum: {
          Parachain: 'Null',
          Parathread: '(CollatorId, u32)'
        }
      },
      AttestedCandidate: {
        candidate: 'AbridgedCandidateReceipt',
        validityVotes: 'Vec<ValidityAttestation>',
        validatorIndices: 'BitVec'
      },
      AuthorityDiscoveryId: 'AccountId',
      AvailabilityBitfield: 'BitVec',
      AvailabilityBitfieldRecord: {
        bitfield: 'AvailabilityBitfield',
        submittedTt: 'BlockNumber'
      },
      BackedCandidate: {
        candidate: 'CommittedCandidateReceipt',
        validityVotes: 'Vec<ValidityAttestation>',
        validatorIndices: 'BitVec'
      },
      BufferedSessionChange: {
        applyAt: 'BlockNumber',
        validators: 'Vec<ValidatorId>',
        queued: 'Vec<ValidatorId>',
        sessionIndex: 'SessionIndex'
      },
      CandidateCommitments: {
        upwardMessages: 'Vec<UpwardMessage>',
        horizontalMessages: 'Vec<OutboundHrmpMessage>',
        newValidationCode: 'Option<ValidationCode>',
        headData: 'HeadData',
        processedDownwardMessages: 'u32',
        hrmpWatermark: 'BlockNumber'
      },
      CandidateDescriptor: {
        paraId: 'ParaId',
        relayParent: 'RelayChainHash',
        collatorId: 'CollatorId',
        persistedValidationDataHash: 'Hash',
        povHash: 'Hash',
        erasureRoot: 'Hash',
        signature: 'CollatorSignature',
        paraHead: 'Hash',
        validationCodeHash: 'ValidationCodeHash'
      },
      CandidateHash: 'Hash',
      CandidateInfo: {
        who: 'AccountId',
        deposit: 'Balance'
      },
      CandidatePendingAvailability: {
        core: 'CoreIndex',
        hash: 'CandidateHash',
        descriptor: 'CandidateDescriptor',
        availabilityVotes: 'BitVec',
        backers: 'BitVec',
        relayParentNumber: 'BlockNumber',
        backedInNumber: 'BlockNumber',
        backingGroup: 'GroupIndex'
      },
      CandidateReceipt: {
        descriptor: 'CandidateDescriptor',
        commitmentsHash: 'Hash'
      },
      GlobalValidationData: {
        maxCodeSize: 'u32',
        maxHeadDataSize: 'u32',
        blockNumber: 'BlockNumber'
      },
      CollatorId: 'H256',
      CollatorSignature: 'Signature',
      CommittedCandidateReceipt: {
        descriptor: 'CandidateDescriptor',
        commitments: 'CandidateCommitments'
      },
      CoreAssignment: {
        core: 'CoreIndex',
        paraId: 'ParaId',
        kind: 'AssignmentKind',
        groupIdx: 'GroupIndex'
      },
      CoreIndex: 'u32',
      CoreOccupied: {
        _enum: {
          Parathread: 'ParathreadEntry',
          Parachain: 'Null'
        }
      },
      DoubleVoteReport: {
        identity: 'ValidatorId',
        first: '(Statement, ValidatorSignature)',
        second: '(Statement, ValidatorSignature)',
        proof: 'MembershipProof',
        signingContext: 'SigningContext'
      },
      DownwardMessage: 'Bytes',
      GroupIndex: 'u32',
      GlobalValidationSchedule: {
        maxCodeSize: 'u32',
        maxHeadDataSize: 'u32',
        blockNumber: 'BlockNumber'
      },
      HeadData: 'Bytes',
      HostConfiguration: {
        maxCodeSize: 'u32',
        maxHeadDataSize: 'u32',
        maxUpwardQueueCount: 'u32',
        maxUpwardQueueSize: 'u32',
        maxUpwardMessageSize: 'u32',
        maxUpwardMessageNumPerCandidate: 'u32',
        hrmpMaxMessageNumPerCandidate: 'u32',
        validationUpgradeFrequency: 'BlockNumber',
        validationUpgradeDelay: 'BlockNumber',
        maxPovSize: 'u32',
        maxDownwardMessageSize: 'u32',
        preferredDispatchableUpwardMessagesStepWeight: 'Weight',
        hrmpMaxParachainOutboundChannels: 'u32',
        hrmpMaxParathreadOutboundChannels: 'u32',
        hrmpOpenRequestTtl: 'u32',
        hrmpSenderDeposit: 'Balance',
        hrmpRecipientDeposit: 'Balance',
        hrmpChannelMaxCapacity: 'u32',
        hrmpChannelMaxTotalSize: 'u32',
        hrmpMaxParachainInboundChannels: 'u32',
        hrmpMaxParathreadInboundChannels: 'u32',
        hrmpChannelMaxMessageSize: 'u32',
        codeRetentionPeriod: 'BlockNumber',
        parathreadCores: 'u32',
        parathreadRetries: 'u32',
        groupRotationFrequency: 'BlockNumber',
        chainAvailabilityPeriod: 'BlockNumber',
        threadAvailabilityPeriod: 'BlockNumber',
        schedulingLookahead: 'u32',
        maxValidatorsPerCore: 'Option<u32>',
        maxValidators: 'Option<u32>',
        disputePeriod: 'SessionIndex',
        disputePostConclusionAcceptancePeriod: 'BlockNumber',
        disputeMaxSpamSlots: 'u32',
        disputeConclusionByTimeOutPeriod: 'BlockNumber',
        noShowSlots: 'u32',
        nDelayTranches: 'u32',
        zerothDelayTrancheWidth: 'u32',
        neededApprovals: 'u32',
        relayVrfModuloSamples: 'u32'
      },
      InboundDownwardMessage: {
        pubSentAt: 'BlockNumber',
        pubMsg: 'DownwardMessage'
      },
      InboundHrmpMessage: {
        sentAt: 'BlockNumber',
        data: 'Bytes'
      },
      InboundHrmpMessages: 'Vec<InboundHrmpMessage>',
      LocalValidationData: {
        parentHead: 'HeadData',
        balance: 'Balance',
        codeUpgradeAllowed: 'Option<BlockNumber>'
      },
      MessageIngestionType: {
        downwardMessages: 'Vec<InboundDownwardMessage>',
        horizontalMessages: 'BTreeMap<ParaId, InboundHrmpMessages>'
      },
      MessageQueueChain: 'RelayChainHash',
      OutboundHrmpMessage: {
        recipient: 'u32',
        data: 'Bytes'
      },
      ParachainDispatchOrigin: {
        _enum: ['Signed', 'Parachain', 'Root']
      },
      ParachainInherentData: {
        validationData: 'PersistedValidationData',
        relayChainState: 'StorageProof',
        downwardMessages: 'Vec<InboundDownwardMessage>',
        horizontalMessages: 'BTreeMap<ParaId, VecInboundHrmpMessage>'
      },
      ParachainsInherentData: {
        bitfields: 'SignedAvailabilityBitfields',
        backedCandidates: 'Vec<BackedCandidate>',
        disputes: 'MultiDisputeStatementSet',
        parentHeader: 'Header'
      },
      ParaGenesisArgs: {
        genesisHead: 'Bytes',
        validationCode: 'Bytes',
        parachain: 'bool'
      },
      ParaId: 'u32',
      ParaInfo: {
        manager: 'AccountId',
        deposit: 'Balance',
        locked: 'bool'
      },
      ParaLifecycle: {
        _enum: ['Onboarding', 'Parathread', 'Parachain', 'UpgradingToParachain', 'DowngradingToParathread', 'OutgoingParathread', 'OutgoingParachain']
      },
      ParaPastCodeMeta: {
        upgradeTimes: 'Vec<ReplacementTimes>',
        lastPruned: 'Option<BlockNumber>'
      },
      ParaScheduling: {
        _enum: ['Always', 'Dynamic']
      },
      ParathreadClaim: '(ParaId, CollatorId)',
      ParathreadClaimQueue: {
        queue: 'Vec<QueuedParathread>',
        nextCoreOffset: 'u32'
      },
      ParathreadEntry: {
        claim: 'ParathreadClaim',
        retries: 'u32'
      },
      ParaValidatorIndex: 'u32',
      PersistedValidationData: {
        parentHead: 'HeadData',
        relayParentNumber: 'RelayChainBlockNumber',
        relayParentStorageRoot: 'Hash',
        maxPovSize: 'u32'
      },
      QueuedParathread: {
        claim: 'ParathreadEntry',
        coreOffset: 'u32'
      },
      RelayBlockNumber: 'u32',
      RelayChainBlockNumber: 'RelayBlockNumber',
      RelayHash: 'Hash',
      RelayChainHash: 'RelayHash',
      Remark: '[u8; 32]',
      ReplacementTimes: {
        expectedAt: 'BlockNumber',
        activatedAt: 'BlockNumber'
      },
      Retriable: {
        _enum: {
          Never: 'Null',
          WithRetries: 'u32'
        }
      },
      Scheduling: {
        _enum: ['Always', 'Dynamic']
      },
      SessionInfo: {
        validators: 'Vec<ValidatorId>',
        discoveryKeys: 'Vec<AuthorityDiscoveryId>',
        assignmentKeys: 'Vec<AssignmentId>',
        validatorGroups: 'Vec<SessionInfoValidatorGroup>',
        nCores: 'u32',
        zerothDelayTrancheWidth: 'u32',
        relayVrfModuloSamples: 'u32',
        nDelayTranches: 'u32',
        noShowSlots: 'u32',
        neededApprovals: 'u32'
      },
      SessionInfoValidatorGroup: 'Vec<ParaValidatorIndex>',
      SignedAvailabilityBitfield: {
        payload: 'BitVec',
        validatorIndex: 'ParaValidatorIndex',
        signature: 'ValidatorSignature'
      },
      SignedAvailabilityBitfields: 'Vec<SignedAvailabilityBitfield>',
      SigningContext: {
        sessionIndex: 'SessionIndex',
        parentHash: 'Hash'
      },
      Statement: {
        _enum: {
          Never: 'Null',
          Candidate: 'Hash',
          Valid: 'Hash',
          Invalid: 'Hash'
        }
      },
      TransientValidationData: {
        maxCodeSize: 'u32',
        maxHeadDataSize: 'u32',
        balance: 'Balance',
        codeUpgradeAllowed: 'Option<BlockNumber>',
        dmqLength: 'u32'
      },
      UpgradeGoAhead: {
        _enum: ['Abort', 'GoAhead']
      },
      UpgradeRestriction: {
        _enum: ['Present']
      },
      UpwardMessage: 'Bytes',
      ValidationFunctionParams: {
        maxCodeSize: 'u32',
        relayChainHeight: 'RelayChainBlockNumber',
        codeUpgradeAllowed: 'Option<RelayChainBlockNumber>'
      },
      ValidationCode: 'Bytes',
      ValidationCodeHash: 'Hash',
      ValidationData: {
        persisted: 'PersistedValidationData',
        transient: 'TransientValidationData'
      },
      ValidationDataType: {
        validationData: 'ValidationData',
        relayChainState: 'Vec<Bytes>'
      },
      ValidatorSignature: 'Signature',
      ValidityAttestation: {
        _enum: {
          Never: 'Null',
          Implicit: 'ValidatorSignature',
          Explicit: 'ValidatorSignature'
        }
      },
      MessagingStateSnapshot: {
        relayDispatchQueueSize: '(u32, u32)',
        egressChannels: 'Vec<MessagingStateSnapshotEgressEntry>'
      },
      MessagingStateSnapshotEgressEntry: '(ParaId, AbridgedHrmpChannel)',
      SystemInherentData: 'ParachainInherentData',
      VecInboundHrmpMessage: 'Vec<InboundHrmpMessage>'
    })
  };

  const definitions$e = {
    rpc: {},
    types: {
      Approvals: '[bool; 4]'
    }
  };

  const definitions$d = {
    rpc: {},
    types: {
      AccountStatus: {
        validity: 'AccountValidity',
        freeBalance: 'Balance',
        lockedBalance: 'Balance',
        signature: 'Vec<u8>',
        vat: 'Permill'
      },
      AccountValidity: {
        _enum: ['Invalid', 'Initiated', 'Pending', 'ValidLow', 'ValidHigh', 'Completed']
      }
    }
  };

  const v0$1 = {
    FungibilityV0: 'FungibilityV1',
    WildFungibilityV0: 'WildFungibilityV1',
    AssetInstanceV0: {
      _enum: {
        Undefined: 'Null',
        Index8: 'u8',
        Index16: 'Compact<u16>',
        Index32: 'Compact<u32>',
        Index64: 'Compact<u64>',
        Index128: 'Compact<u128>',
        Array4: '[u8; 4]',
        Array8: '[u8; 8]',
        Array16: '[u8; 16]',
        Array32: '[u8; 32]',
        Blob: 'Vec<u8>'
      }
    },
    JunctionV0: {
      _enum: {
        Parent: 'Null',
        Parachain: 'Compact<u32>',
        AccountId32: {
          network: 'NetworkId',
          id: 'AccountId'
        },
        AccountIndex64: {
          network: 'NetworkId',
          index: 'Compact<u64>'
        },
        AccountKey20: {
          network: 'NetworkId',
          key: '[u8; 20]'
        },
        PalletInstance: 'u8',
        GeneralIndex: 'Compact<u128>',
        GeneralKey: 'Vec<u8>',
        OnlyChild: 'Null',
        Plurality: {
          id: 'BodyId',
          part: 'BodyPart'
        }
      }
    },
    MultiAssetV0: {
      _enum: {
        None: 'Null',
        All: 'Null',
        AllFungible: 'Null',
        AllNonFungible: 'Null',
        AllAbstractFungible: 'Vec<u8>',
        AllAbstractNonFungible: 'Vec<u8>',
        AllConcreteFungible: 'MultiLocationV0',
        AllConcreteNonFungible: 'MultiLocationV0',
        AbstractFungible: {
          id: 'Vec<u8>',
          instance: 'Compact<u128>'
        },
        AbstractNonFungible: {
          class: 'Vec<u8>',
          instance: 'AssetInstanceV0'
        },
        ConcreteFungible: {
          id: 'MultiLocationV0',
          amount: 'Compact<u128>'
        },
        ConcreteNonFungible: {
          class: 'MultiLocationV0',
          instance: 'AssetInstanceV0'
        }
      }
    },
    MultiLocationV0: {
      _enum: {
        Here: 'Null',
        X1: 'JunctionV0',
        X2: '(JunctionV0, JunctionV0)',
        X3: '(JunctionV0, JunctionV0, JunctionV0)',
        X4: '(JunctionV0, JunctionV0, JunctionV0, JunctionV0)',
        X5: '(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)',
        X6: '(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)',
        X7: '(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)',
        X8: '(JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0, JunctionV0)'
      }
    },
    OriginKindV0: {
      _enum: ['Native', 'SovereignAccount', 'Superuser', 'Xcm']
    },
    ResponseV0: {
      _enum: {
        Assets: 'Vec<MultiAssetV0>'
      }
    },
    XcmV0: {
      _enum: {
        WithdrawAsset: {
          assets: 'Vec<MultiAssetV0>',
          effects: 'Vec<XcmOrderV0>'
        },
        ReserveAssetDeposit: {
          assets: 'Vec<MultiAssetV0>',
          effects: 'Vec<XcmOrderV0>'
        },
        ReceiveTeleportedAsset: {
          assets: 'Vec<MultiAssetV0>',
          effects: 'Vec<XcmOrderV0>'
        },
        QueryResponse: {
          queryId: 'Compact<u64>',
          response: 'ResponseV0'
        },
        TransferAsset: {
          assets: 'Vec<MultiAssetV0>',
          dest: 'MultiLocationV0'
        },
        TransferReserveAsset: {
          assets: 'Vec<MultiAssetV0>',
          dest: 'MultiLocationV0',
          effects: 'Vec<XcmOrderV0>'
        },
        Transact: {
          originType: 'XcmOriginKind',
          requireWeightAtMost: 'u64',
          call: 'DoubleEncodedCall'
        },
        HrmpNewChannelOpenRequest: {
          sender: 'Compact<u32>',
          maxMessageSize: 'Compact<u32>',
          maxCapacity: 'Compact<u32>'
        },
        HrmpChannelAccepted: {
          recipient: 'Compact<u32>'
        },
        HrmpChannelClosing: {
          initiator: 'Compact<u32>',
          sender: 'Compact<u32>',
          recipient: 'Compact<u32>'
        },
        RelayedFrom: {
          who: 'MultiLocationV0',
          message: 'XcmV0'
        }
      }
    },
    XcmErrorV0: {
      _enum: {
        Undefined: 'Null',
        Overflow: 'Null',
        Unimplemented: 'Null',
        UnhandledXcmVersion: 'Null',
        UnhandledXcmMessage: 'Null',
        UnhandledEffect: 'Null',
        EscalationOfPrivilege: 'Null',
        UntrustedReserveLocation: 'Null',
        UntrustedTeleportLocation: 'Null',
        DestinationBufferOverflow: 'Null',
        SendFailed: 'Null',
        CannotReachDestination: '(MultiLocation, Xcm)',
        MultiLocationFull: 'Null',
        FailedToDecode: 'Null',
        BadOrigin: 'Null',
        ExceedsMaxMessageSize: 'Null',
        FailedToTransactAsset: 'Null',
        WeightLimitReached: 'Weight',
        Wildcard: 'Null',
        TooMuchWeightRequired: 'Null',
        NotHoldingFees: 'Null',
        WeightNotComputable: 'Null',
        Barrier: 'Null',
        NotWithdrawable: 'Null',
        LocationCannotHold: 'Null',
        TooExpensive: 'Null',
        AssetNotFound: 'Null',
        RecursionLimitReached: 'Null'
      }
    },
    XcmOrderV0: {
      _enum: {
        Null: 'Null',
        DepositAsset: {
          assets: 'Vec<MultiAssetV0>',
          dest: 'MultiLocationV0'
        },
        DepositReserveAsset: {
          assets: 'Vec<MultiAssetV0>',
          dest: 'MultiLocationV0',
          effects: 'Vec<XcmOrderV0>'
        },
        ExchangeAsset: {
          give: 'Vec<MultiAssetV0>',
          receive: 'Vec<MultiAssetV0>'
        },
        InitiateReserveWithdraw: {
          assets: 'Vec<MultiAssetV0>',
          reserve: 'MultiLocationV0',
          effects: 'Vec<XcmOrderV0>'
        },
        InitiateTeleport: {
          assets: 'Vec<MultiAsset>',
          dest: 'MultiLocationV0',
          effects: 'Vec<XcmOrderV0>'
        },
        QueryHolding: {
          queryId: 'Compact<u64>',
          dest: 'MultiLocationV0',
          assets: 'Vec<MultiAssetV0>'
        },
        BuyExecution: {
          fees: 'MultiAsset',
          weight: 'u64',
          debt: 'u64',
          haltOnError: 'bool',
          xcm: 'Vec<XcmV0>'
        }
      }
    }
  };

  const v1$1 = {
    AssetInstanceV1: {
      _enum: {
        Undefined: 'Null',
        Index: 'Compact<u128>',
        Array4: '[u8; 4]',
        Array8: '[u8; 8]',
        Array16: '[u8; 16]',
        Array32: '[u8; 32]',
        Blob: 'Bytes'
      }
    },
    FungibilityV1: {
      _enum: {
        Fungible: 'Compact<u128>',
        NonFungible: 'AssetInstanceV1'
      }
    },
    JunctionV1: {
      _enum: {
        Parachain: 'Compact<u32>',
        AccountId32: {
          network: 'NetworkId',
          id: 'AccountId'
        },
        AccountIndex64: {
          network: 'NetworkId',
          index: 'Compact<u64>'
        },
        AccountKey20: {
          network: 'NetworkId',
          key: '[u8; 20]'
        },
        PalletInstance: 'u8',
        GeneralIndex: 'Compact<u128>',
        GeneralKey: 'Vec<u8>',
        OnlyChild: 'Null',
        Plurality: {
          id: 'BodyId',
          part: 'BodyPart'
        }
      }
    },
    JunctionsV1: {
      _enum: {
        Here: 'Null',
        X1: 'JunctionV1',
        X2: '(JunctionV1, JunctionV1)',
        X3: '(JunctionV1, JunctionV1, JunctionV1)',
        X4: '(JunctionV1, JunctionV1, JunctionV1, JunctionV1)',
        X5: '(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)',
        X6: '(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)',
        X7: '(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)',
        X8: '(JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1, JunctionV1)'
      }
    },
    MultiAssetsV1: 'Vec<MultiAssetV1>',
    MultiAssetV1: {
      id: 'XcmAssetId',
      fungibility: 'FungibilityV1'
    },
    MultiAssetFilterV1: {
      _enum: {
        Definite: 'MultiAssetsV1',
        Wild: 'WildMultiAssetV1'
      }
    },
    MultiLocationV1: {
      parents: 'u8',
      interior: 'JunctionsV1'
    },
    OriginKindV1: 'OriginKindV0',
    ResponseV1: {
      _enum: {
        Assets: 'MultiAssetsV1'
      }
    },
    WildFungibilityV1: {
      _enum: ['Fungible', 'NonFungible']
    },
    WildMultiAssetV1: {
      _enum: {
        All: 'Null',
        AllOf: {
          id: 'XcmAssetId',
          fungibility: 'WildFungibilityV1'
        }
      }
    },
    XcmV1: {
      _enum: {
        WithdrawAsset: {
          assets: 'MultiAssetsV1',
          effects: 'Vec<XcmOrderV1>'
        },
        ReserveAssetDeposit: {
          assets: 'MultiAssetsV1',
          effects: 'Vec<XcmOrderV1>'
        },
        ReceiveTeleportedAsset: {
          assets: 'MultiAssetsV1',
          effects: 'Vec<XcmOrderV1>'
        },
        QueryResponse: {
          queryId: 'Compact<u64>',
          response: 'ResponseV1'
        },
        TransferAsset: {
          assets: 'MultiAssetsV1',
          dest: 'MultiLocationV1'
        },
        TransferReserveAsset: {
          assets: 'MultiAssetsV1',
          dest: 'MultiLocationV1',
          effects: 'Vec<XcmOrderV1>'
        },
        Transact: {
          originType: 'XcmOriginKind',
          requireWeightAtMost: 'u64',
          call: 'DoubleEncodedCall'
        },
        HrmpNewChannelOpenRequest: {
          sender: 'Compact<u32>',
          maxMessageSize: 'Compact<u32>',
          maxCapacity: 'Compact<u32>'
        },
        HrmpChannelAccepted: {
          recipient: 'Compact<u32>'
        },
        HrmpChannelClosing: {
          initiator: 'Compact<u32>',
          sender: 'Compact<u32>',
          recipient: 'Compact<u32>'
        },
        RelayedFrom: {
          who: 'MultiLocationV1',
          message: 'XcmV1'
        }
      }
    },
    XcmErrorV1: {
      _enum: {
        Undefined: 'Null',
        Overflow: 'Null',
        Unimplemented: 'Null',
        UnhandledXcmVersion: 'Null',
        UnhandledXcmMessage: 'Null',
        UnhandledEffect: 'Null',
        EscalationOfPrivilege: 'Null',
        UntrustedReserveLocation: 'Null',
        UntrustedTeleportLocation: 'Null',
        DestinationBufferOverflow: 'Null',
        SendFailed: 'Null',
        CannotReachDestination: '(MultiLocationV1, XcmV1)',
        MultiLocationFull: 'Null',
        FailedToDecode: 'Null',
        BadOrigin: 'Null',
        ExceedsMaxMessageSize: 'Null',
        FailedToTransactAsset: 'Null',
        WeightLimitReached: 'Weight',
        Wildcard: 'Null',
        TooMuchWeightRequired: 'Null',
        NotHoldingFees: 'Null',
        WeightNotComputable: 'Null',
        Barrier: 'Null',
        NotWithdrawable: 'Null',
        LocationCannotHold: 'Null',
        TooExpensive: 'Null',
        AssetNotFound: 'Null',
        DestinationUnsupported: 'Null',
        RecursionLimitReached: 'Null'
      }
    },
    XcmOrderV1: {
      _enum: {
        Noop: 'Null',
        DepositAsset: {
          assets: 'MultiAssetFilterV1',
          maxAssets: 'u32',
          beneficiary: 'MultiLocationV1'
        },
        DepositReserveAsset: {
          assets: 'MultiAssetFilterV1',
          maxAssets: 'u32',
          dest: 'MultiLocationV1',
          effects: 'Vec<XcmOrderV1>'
        },
        ExchangeAsset: {
          give: 'MultiAssetFilterV1',
          receive: 'MultiAssetsV1'
        },
        InitiateReserveWithdraw: {
          assets: 'MultiAssetFilterV1',
          reserve: 'MultiLocationV1',
          effects: 'Vec<XcmOrderV1>'
        },
        InitiateTeleport: {
          assets: 'MultiAssetFilterV1',
          dest: 'MultiLocationV1',
          effects: 'Vec<XcmOrderV1>'
        },
        QueryHolding: {
          queryId: 'Compact<u64>',
          dest: 'MultiLocationV1',
          assets: 'MultiAssetFilterV1'
        },
        BuyExecution: {
          fees: 'MultiAssetV1',
          weight: 'u64',
          debt: 'u64',
          haltOnError: 'bool',
          instructions: 'Vec<XcmV1>'
        }
      }
    }
  };

  const v2 = {
    AssetInstanceV2: 'AssetInstanceV1',
    FungibilityV2: 'FungibilityV1',
    JunctionV2: 'JunctionV1',
    JunctionsV2: 'JunctionsV1',
    MultiAssetsV2: 'MultiAssetsV1',
    MultiAssetV2: 'MultiAssetV1',
    MultiAssetFilterV2: 'MultiAssetFilterV1',
    MultiLocationV2: 'MultiLocationV1',
    OriginKindV2: 'OriginKindV1',
    WildFungibilityV2: 'WildFungibilityV1',
    ResponseV2: {
      _enum: {
        Null: 'Null',
        Assets: 'MultiAssetsV2',
        ExecutionResult: 'ResponseV2Result'
      }
    },
    ResponseV2Error: '(u32, XcmErrorV2)',
    ResponseV2Result: 'Result<Null, ResponseV2Error>',
    WeightLimitV2: {
      _enum: {
        Unlimited: 'Null',
        Limited: 'Compact<u64>'
      }
    },
    InstructionV2: {
      _enum: {
        WithdrawAsset: 'MultiAssetsV2',
        ReserveAssetDeposited: 'MultiAssetsV2',
        ReceiveTeleportedAsset: 'MultiAssetsV2',
        QueryResponse: {
          queryId: 'Compact<u64>',
          response: 'ResponseV2',
          maxWeight: 'Compact<u64>'
        },
        TransferAsset: {
          assets: 'MultiAssetsV2',
          beneficiary: 'MultiLocationV2'
        },
        TransferReserveAsset: {
          assets: 'MultiAssetsV2',
          dest: 'MultiLocationV2',
          xcm: 'XcmV2'
        },
        Transact: {
          originType: 'OriginKindV2',
          requireWeightAtMost: 'u64',
          call: 'DoubleEncodedCall'
        },
        HrmpNewChannelOpenRequest: {
          sender: 'Compact<u32>',
          maxMessageSize: 'Compact<u32>',
          maxCapacity: 'Compact<u32>'
        },
        HrmpChannelAccepted: {
          recipient: 'Compact<u32>'
        },
        HrmpChannelClosing: {
          initiator: 'Compact<u32>',
          sender: 'Compact<u32>',
          recipient: 'Compact<u32>'
        },
        ClearOrigin: 'Null',
        DescendOrigin: 'InteriorMultiLocation',
        ReportError: {
          queryId: 'Compact<u64>',
          dest: 'MultiLocationV2',
          maxResponseWeight: 'Compact<u64>'
        },
        DepositAsset: {
          assets: 'MultiAssetFilterV2',
          maxAssets: 'u32',
          beneficiary: 'MultiLocationV2'
        },
        DepositReserveAsset: {
          assets: 'MultiAssetFilterV2',
          maxAssets: 'u32',
          dest: 'MultiLocationV2',
          xcm: 'XcmV2'
        },
        ExchangeAsset: {
          give: 'MultiAssetFilterV2',
          receive: 'MultiAssetsV2'
        },
        InitiateReserveWithdraw: {
          assets: 'MultiAssetFilterV2',
          reserve: 'MultiLocationV2',
          xcm: 'XcmV2'
        },
        InitiateTeleport: {
          assets: 'MultiAssetFilterV2',
          dest: 'MultiLocationV2',
          xcm: 'XcmV2'
        },
        QueryHolding: {
          query_id: 'Compact<u64>',
          dest: 'MultiLocationV2',
          assets: 'MultiAssetFilterV2',
          maxResponse_Weight: 'Compact<u64>'
        },
        BuyExecution: {
          fees: 'MultiAssetV2',
          weightLimit: 'WeightLimitV2'
        },
        RefundSurplus: 'Null',
        SetErrorHandler: 'XcmV2',
        SetAppendix: 'XcmV2',
        ClearError: 'Null',
        ClaimAsset: {
          assets: 'MultiAssetsV2',
          ticket: 'MultiLocationV2'
        },
        Trap: 'u64'
      }
    },
    WildMultiAssetV2: 'WildMultiAssetV1',
    XcmV2: 'Vec<InstructionV2>',
    XcmErrorV2: {
      _enum: {
        Undefined: 'Null',
        Overflow: 'Null',
        Unimplemented: 'Null',
        UnhandledXcmVersion: 'Null',
        UnhandledXcmMessage: 'Null',
        UnhandledEffect: 'Null',
        EscalationOfPrivilege: 'Null',
        UntrustedReserveLocation: 'Null',
        UntrustedTeleportLocation: 'Null',
        DestinationBufferOverflow: 'Null',
        MultiLocationFull: 'Null',
        MultiLocationNotInvertible: 'Null',
        FailedToDecode: 'Null',
        BadOrigin: 'Null',
        ExceedsMaxMessageSize: 'Null',
        FailedToTransactAsset: 'Null',
        WeightLimitReached: 'Weight',
        Wildcard: 'Null',
        TooMuchWeightRequired: 'Null',
        NotHoldingFees: 'Null',
        WeightNotComputable: 'Null',
        Barrier: 'Null',
        NotWithdrawable: 'Null',
        LocationCannotHold: 'Null',
        TooExpensive: 'Null',
        AssetNotFound: 'Null',
        DestinationUnsupported: 'Null',
        RecursionLimitReached: 'Null',
        Transport: 'Null',
        Unroutable: 'Null',
        UnknownWeightRequired: 'Null',
        Trap: 'u64',
        UnknownClaim: 'Null',
        InvalidLocation: 'Null'
      }
    },
    XcmOrderV2: 'XcmOrderV1'
  };

  const XCM_LATEST = 'V2';
  const xcm = {
    XcmOrigin: {
      _enum: {
        Xcm: 'MultiLocation'
      }
    },
    XcmpMessageFormat: {
      _enum: ['ConcatenatedVersionedXcm', 'ConcatenatedEncodedBlob', 'Signals']
    },
    XcmAssetId: {
      _enum: {
        Concrete: 'MultiLocation',
        Abstract: 'Bytes'
      }
    },
    InboundStatus: {
      _enum: ['Ok', 'Suspended']
    },
    OutboundStatus: {
      _enum: ['Ok', 'Suspended']
    },
    MultiAssets: 'Vec<MultiAsset>'
  };
  const location = {
    BodyId: {
      _enum: {
        Unit: 'Null',
        Named: 'Vec<u8>',
        Index: 'Compact<u32>',
        Executive: 'Null',
        Technical: 'Null',
        Legislative: 'Null',
        Judicial: 'Null'
      }
    },
    BodyPart: {
      _enum: {
        Voice: 'Null',
        Members: 'Compact<u32>',
        Fraction: {
          nom: 'Compact<u32>',
          denom: 'Compact<u32>'
        },
        AtLeastProportion: {
          nom: 'Compact<u32>',
          denom: 'Compact<u32>'
        },
        MoreThanProportion: {
          nom: 'Compact<u32>',
          denom: 'Compact<u32>'
        }
      }
    },
    InteriorMultiLocation: 'Junctions',
    NetworkId: {
      _enum: {
        Any: 'Null',
        Named: 'Vec<u8>',
        Polkadot: 'Null',
        Kusama: 'Null'
      }
    }
  };
  const definitions$c = {
    rpc: {},
    types: objectSpread$1({}, location, xcm, v0$1, v1$1, v2, typesKnown.mapXcmTypes(XCM_LATEST), {
      DoubleEncodedCall: {
        encoded: 'Vec<u8>'
      },
      XcmOriginKind: {
        _enum: ['Native', 'SovereignAccount', 'Superuser', 'Xcm']
      },
      Outcome: {
        _enum: {
          Complete: 'Weight',
          Incomplete: '(Weight, XcmErrorV0)',
          Error: 'XcmErrorV0'
        }
      },
      QueryId: 'u64',
      QueryStatus: {
        _enum: {
          Pending: {
            responder: 'VersionedMultiLocation',
            maybeNotify: 'Option<(u8, u8)>',
            timeout: 'BlockNumber'
          },
          Ready: {
            response: 'VersionedResponse',
            at: 'BlockNumber'
          }
        }
      },
      QueueConfigData: {
        suspendThreshold: 'u32',
        dropThreshold: 'u32',
        resumeThreshold: 'u32',
        thresholdWeight: 'Weight',
        weightRestrictDecay: 'Weight'
      },
      VersionMigrationStage: {
        _enum: {
          MigrateSupportedVersion: 'Null',
          MigrateVersionNotifiers: 'Null',
          NotifyCurrentTargets: 'Option<Bytes>',
          MigrateAndNotifyOldTargets: 'Null'
        }
      },
      VersionedMultiAsset: {
        _enum: {
          V0: 'MultiAssetV0',
          V1: 'MultiAssetV1',
          V2: 'MultiAssetV2'
        }
      },
      VersionedMultiAssets: {
        _enum: {
          V0: 'Vec<MultiAssetV0>',
          V1: 'MultiAssetsV1',
          V2: 'MultiAssetsV2'
        }
      },
      VersionedMultiLocation: {
        _enum: {
          V0: 'MultiLocationV0',
          V1: 'MultiLocationV1',
          V2: 'MultiLocationV2'
        }
      },
      VersionedResponse: {
        V0: 'ResponseV0',
        V1: 'ResponseV1',
        V2: 'ResponseV2'
      },
      VersionedXcm: {
        _enum: {
          V0: 'XcmV0',
          V1: 'XcmV1',
          V2: 'XcmV2'
        }
      },
      XcmVersion: 'u32'
    })
  };

  const layout = {
    ContractCryptoHasher: {
      _enum: ['Blake2x256', 'Sha2x256', 'Keccak256']
    },
    ContractDiscriminant: 'u32',
    ContractLayoutArray: {
      offset: 'ContractLayoutKey',
      len: 'u32',
      cellsPerElem: 'u64',
      layout: 'ContractStorageLayout'
    },
    ContractLayoutCell: {
      key: 'ContractLayoutKey',
      ty: 'SiLookupTypeId'
    },
    ContractLayoutEnum: {
      dispatchKey: 'ContractLayoutKey',
      variants: 'BTreeMap<ContractDiscriminant, ContractLayoutStruct>'
    },
    ContractLayoutHash: {
      offset: 'ContractLayoutKey',
      strategy: 'ContractLayoutHashingStrategy',
      layout: 'ContractStorageLayout'
    },
    ContractLayoutHashingStrategy: {
      hasher: 'ContractCryptoHasher',
      postfix: 'Vec<u8>',
      prefix: 'Vec<u8>'
    },
    ContractLayoutKey: '[u8; 32]',
    ContractLayoutStruct: {
      fields: 'Vec<ContractLayoutStructField>'
    },
    ContractLayoutStructField: {
      layout: 'ContractStorageLayout',
      name: 'Text'
    },
    ContractStorageLayout: {
      _enum: {
        Cell: 'ContractLayoutCell',
        Hash: 'ContractLayoutHash',
        Array: 'ContractLayoutArray',
        Struct: 'ContractLayoutStruct',
        Enum: 'ContractLayoutEnum'
      }
    }
  };
  const spec = {
    ContractConstructorSpec: {
      name: 'Text',
      selector: 'ContractSelector',
      args: 'Vec<ContractMessageParamSpec>',
      docs: 'Vec<Text>'
    },
    ContractContractSpec: {
      constructors: 'Vec<ContractConstructorSpec>',
      messages: 'Vec<ContractMessageSpec>',
      events: 'Vec<ContractEventSpec>',
      docs: 'Vec<Text>'
    },
    ContractDisplayName: 'SiPath',
    ContractEventParamSpec: {
      name: 'Text',
      indexed: 'bool',
      type: 'ContractTypeSpec',
      docs: 'Vec<Text>'
    },
    ContractEventSpec: {
      name: 'Text',
      args: 'Vec<ContractEventParamSpec>',
      docs: 'Vec<Text>'
    },
    ContractMessageParamSpec: {
      name: 'Text',
      type: 'ContractTypeSpec'
    },
    ContractMessageSpec: {
      name: 'Text',
      selector: 'ContractSelector',
      mutates: 'bool',
      payable: 'bool',
      args: 'Vec<ContractMessageParamSpec>',
      returnType: 'Option<ContractTypeSpec>',
      docs: 'Vec<Text>'
    },
    ContractSelector: '[u8; 4]',
    ContractTypeSpec: {
      type: 'SiLookupTypeId',
      displayName: 'ContractDisplayName'
    }
  };
  const ContractMetadataV0 = {
    types: 'Vec<Si0Type>',
    spec: 'ContractContractSpec'
  };
  const ContractMetadataV1 = {
    types: 'Vec<PortableType>',
    spec: 'ContractContractSpec'
  };
  const ContractProjectInfo = {
    source: 'ContractProjectSource',
    contract: 'ContractProjectContract'
  };
  const definitions$b = {
    rpc: {},
    types: objectSpread$1({}, layout, spec, {
      ContractProjectInfo,
      ContractMetadataV0,
      ContractMetadataV1,
      ContractMetadata: {
        _enum: {
          V0: 'ContractMetadataV0',
          V1: 'ContractMetadataV1'
        }
      },
      ContractMetadataLatest: 'ContractMetadataV1',
      ContractProjectV0: objectSpread$1({
        metadataVersion: 'Text'
      }, ContractProjectInfo, ContractMetadataV0),
      ContractProject: '(ContractProjectInfo, ContractMetadata)',
      ContractProjectContract: {
        _alias: {
          docs: 'documentation'
        },
        name: 'Text',
        version: 'Text',
        authors: 'Vec<Text>',
        description: 'Option<Text>',
        docs: 'Option<Text>',
        repository: 'Option<Text>',
        homepage: 'Option<Text>',
        license: 'Option<Text>'
      },
      ContractProjectSource: {
        _alias: {
          wasmHash: 'hash'
        },
        wasmHash: '[u8; 32]',
        language: 'Text',
        compiler: 'Text',
        wasm: 'Raw'
      }
    })
  };

  const v0 = {
    Si0Field: {
      name: 'Option<Text>',
      type: 'Si0LookupTypeId',
      typeName: 'Option<Text>',
      docs: 'Vec<Text>'
    },
    Si0LookupTypeId: 'u32',
    Si0Path: 'Vec<Text>',
    Si0Type: {
      path: 'Si0Path',
      params: 'Vec<Si0LookupTypeId>',
      def: 'Si0TypeDef'
    },
    Si0TypeDef: {
      _enum: {
        Composite: 'Si0TypeDefComposite',
        Variant: 'Si0TypeDefVariant',
        Sequence: 'Si0TypeDefSequence',
        Array: 'Si0TypeDefArray',
        Tuple: 'Si0TypeDefTuple',
        Primitive: 'Si0TypeDefPrimitive',
        Compact: 'Si0TypeDefCompact',
        Phantom: 'Si0TypeDefPhantom',
        BitSequence: 'Si0TypeDefBitSequence'
      }
    },
    Si0TypeDefArray: {
      len: 'u32',
      type: 'Si0LookupTypeId'
    },
    Si0TypeDefBitSequence: {
      bitStoreType: 'Si0LookupTypeId',
      bitOrderType: 'Si0LookupTypeId'
    },
    Si0TypeDefCompact: {
      type: 'Si0LookupTypeId'
    },
    Si0TypeDefComposite: {
      fields: 'Vec<Si0Field>'
    },
    Si0TypeDefPhantom: 'Null',
    Si0TypeDefVariant: {
      variants: 'Vec<Si0Variant>'
    },
    Si0TypeDefPrimitive: {
      _enum: ['Bool', 'Char', 'Str', 'U8', 'U16', 'U32', 'U64', 'U128', 'U256', 'I8', 'I16', 'I32', 'I64', 'I128', 'I256']
    },
    Si0TypeDefSequence: {
      type: 'Si0LookupTypeId'
    },
    Si0TypeDefTuple: 'Vec<Si0LookupTypeId>',
    Si0TypeParameter: {
      name: 'Text',
      type: 'Option<Si0LookupTypeId>'
    },
    Si0Variant: {
      name: 'Text',
      fields: 'Vec<Si0Field>',
      index: 'Option<u8>',
      discriminant: 'Option<u64>',
      docs: 'Vec<Text>'
    }
  };

  const Si1Variant = {
    name: 'Text',
    fields: 'Vec<Si1Field>',
    index: 'u8',
    docs: 'Vec<Text>'
  };
  const v1 = {
    Si1Field: {
      name: 'Option<Text>',
      type: 'Si1LookupTypeId',
      typeName: 'Option<Text>',
      docs: 'Vec<Text>'
    },
    Si1LookupTypeId: 'Compact<u32>',
    Si1Path: 'Si0Path',
    Si1Type: {
      path: 'Si1Path',
      params: 'Vec<Si1TypeParameter>',
      def: 'Si1TypeDef',
      docs: 'Vec<Text>'
    },
    Si1TypeDef: {
      _enum: {
        Composite: 'Si1TypeDefComposite',
        Variant: 'Si1TypeDefVariant',
        Sequence: 'Si1TypeDefSequence',
        Array: 'Si1TypeDefArray',
        Tuple: 'Si1TypeDefTuple',
        Primitive: 'Si1TypeDefPrimitive',
        Compact: 'Si1TypeDefCompact',
        BitSequence: 'Si1TypeDefBitSequence',
        HistoricMetaCompat: 'Type'
      }
    },
    Si1TypeDefArray: {
      len: 'u32',
      type: 'Si1LookupTypeId'
    },
    Si1TypeDefBitSequence: {
      bitStoreType: 'Si1LookupTypeId',
      bitOrderType: 'Si1LookupTypeId'
    },
    Si1TypeDefCompact: {
      type: 'Si1LookupTypeId'
    },
    Si1TypeDefComposite: {
      fields: 'Vec<Si1Field>'
    },
    Si1TypeDefPrimitive: 'Si0TypeDefPrimitive',
    Si1TypeDefSequence: {
      type: 'Si1LookupTypeId'
    },
    Si1TypeDefTuple: 'Vec<Si1LookupTypeId>',
    Si1TypeParameter: {
      name: 'Text',
      type: 'Option<Si1LookupTypeId>'
    },
    Si1TypeDefVariant: {
      variants: 'Vec<Si1Variant>'
    },
    Si1Variant
  };

  const definitions$a = {
    rpc: {},
    types: objectSpread$1({}, v0, v1, {
      SiField: 'Si1Field',
      SiLookupTypeId: 'Si1LookupTypeId',
      SiPath: 'Si1Path',
      SiType: 'Si1Type',
      SiTypeDef: 'Si1TypeDef',
      SiTypeDefArray: 'Si1TypeDefArray',
      SiTypeDefBitSequence: 'Si1TypeDefBitSequence',
      SiTypeDefCompact: 'Si1TypeDefCompact',
      SiTypeDefComposite: 'Si1TypeDefComposite',
      SiTypeDefPrimitive: 'Si1TypeDefPrimitive',
      SiTypeDefSequence: 'Si1TypeDefSequence',
      SiTypeDefTuple: 'Si1TypeDefTuple',
      SiTypeParameter: 'Si1TypeParameter',
      SiTypeDefVariant: 'Si1TypeDefVariant',
      SiVariant: 'Si1Variant'
    })
  };

  const netRpc = {
    listening: {
      aliasSection: 'net',
      description: 'Returns true if client is actively listening for network connections. Otherwise false.',
      params: [],
      type: 'bool'
    },
    peerCount: {
      aliasSection: 'net',
      description: 'Returns number of peers connected to node.',
      params: [],
      type: 'String'
    },
    version: {
      aliasSection: 'net',
      description: 'Returns protocol version.',
      params: [],
      type: 'String'
    }
  };
  const web3Rpc = {
    clientVersion: {
      aliasSection: 'web3',
      description: 'Returns current client version.',
      params: [],
      type: 'String'
    },
    sha3: {
      aliasSection: 'web3',
      description: 'Returns sha3 of the given data',
      params: [{
        name: 'data',
        type: 'Bytes'
      }],
      type: 'H256'
    }
  };
  const rpc = objectSpread$1({}, netRpc, web3Rpc, {
    accounts: {
      description: 'Returns accounts list.',
      params: [],
      type: 'Vec<H160>'
    },
    blockNumber: {
      description: 'Returns the blockNumber',
      params: [],
      type: 'U256'
    },
    call: {
      description: 'Call contract, returning the output data.',
      params: [{
        name: 'request',
        type: 'EthCallRequest'
      }, {
        isOptional: true,
        name: 'number',
        type: 'BlockNumber'
      }],
      type: 'Bytes'
    },
    chainId: {
      description: 'Returns the chain ID used for transaction signing at the current best block. None is returned if not available.',
      params: [],
      type: 'U64'
    },
    coinbase: {
      description: 'Returns block author.',
      params: [],
      type: 'H160'
    },
    estimateGas: {
      description: 'Estimate gas needed for execution of given contract.',
      params: [{
        name: 'request',
        type: 'EthCallRequest'
      }, {
        isOptional: true,
        name: 'number',
        type: 'BlockNumber'
      }],
      type: 'U256'
    },
    gasPrice: {
      description: 'Returns current gas price.',
      params: [],
      type: 'U256'
    },
    getBalance: {
      description: 'Returns balance of the given account.',
      params: [{
        name: 'address',
        type: 'H160'
      }, {
        isOptional: true,
        name: 'number',
        type: 'BlockNumber'
      }],
      type: 'U256'
    },
    getBlockByHash: {
      description: 'Returns block with given hash.',
      params: [{
        name: 'hash',
        type: 'H256'
      }, {
        name: 'full',
        type: 'bool'
      }],
      type: 'Option<EthRichBlock>'
    },
    getBlockByNumber: {
      description: 'Returns block with given number.',
      params: [{
        name: 'block',
        type: 'BlockNumber'
      }, {
        name: 'full',
        type: 'bool'
      }],
      type: 'Option<EthRichBlock>'
    },
    getBlockTransactionCountByHash: {
      description: 'Returns the number of transactions in a block with given hash.',
      params: [{
        name: 'hash',
        type: 'H256'
      }],
      type: 'U256'
    },
    getBlockTransactionCountByNumber: {
      description: 'Returns the number of transactions in a block with given block number.',
      params: [{
        name: 'block',
        type: 'BlockNumber'
      }],
      type: 'U256'
    },
    getCode: {
      description: 'Returns the code at given address at given time (block number).',
      params: [{
        name: 'address',
        type: 'H160'
      }, {
        isOptional: true,
        name: 'number',
        type: 'BlockNumber'
      }],
      type: 'Bytes'
    },
    getFilterChanges: {
      description: 'Returns filter changes since last poll.',
      params: [{
        name: 'index',
        type: 'U256'
      }],
      type: 'EthFilterChanges'
    },
    getFilterLogs: {
      description: 'Returns all logs matching given filter (in a range \'from\' - \'to\').',
      params: [{
        name: 'index',
        type: 'U256'
      }],
      type: 'Vec<EthLog>'
    },
    getLogs: {
      description: 'Returns logs matching given filter object.',
      params: [{
        name: 'filter',
        type: 'EthFilter'
      }],
      type: 'Vec<EthLog>'
    },
    getProof: {
      description: 'Returns proof for account and storage.',
      params: [{
        name: 'address',
        type: 'H160'
      }, {
        name: 'storageKeys',
        type: 'Vec<H256>'
      }, {
        name: 'number',
        type: 'BlockNumber'
      }],
      type: 'EthAccount'
    },
    getStorageAt: {
      description: 'Returns content of the storage at given address.',
      params: [{
        name: 'address',
        type: 'H160'
      }, {
        name: 'index',
        type: 'U256'
      }, {
        isOptional: true,
        name: 'number',
        type: 'BlockNumber'
      }],
      type: 'H256'
    },
    getTransactionByBlockHashAndIndex: {
      description: 'Returns transaction at given block hash and index.',
      params: [{
        name: 'hash',
        type: 'H256'
      }, {
        name: 'index',
        type: 'U256'
      }],
      type: 'EthTransaction'
    },
    getTransactionByBlockNumberAndIndex: {
      description: 'Returns transaction by given block number and index.',
      params: [{
        name: 'number',
        type: 'BlockNumber'
      }, {
        name: 'index',
        type: 'U256'
      }],
      type: 'EthTransaction'
    },
    getTransactionByHash: {
      description: 'Get transaction by its hash.',
      params: [{
        name: 'hash',
        type: 'H256'
      }],
      type: 'EthTransaction'
    },
    getTransactionCount: {
      description: 'Returns the number of transactions sent from given address at given time (block number).',
      params: [{
        name: 'hash',
        type: 'H256'
      }, {
        isOptional: true,
        name: 'number',
        type: 'BlockNumber'
      }],
      type: 'U256'
    },
    getTransactionReceipt: {
      description: 'Returns transaction receipt by transaction hash.',
      params: [{
        name: 'hash',
        type: 'H256'
      }],
      type: 'EthReceipt'
    },
    getUncleByBlockHashAndIndex: {
      description: 'Returns an uncles at given block and index.',
      params: [{
        name: 'hash',
        type: 'H256'
      }, {
        name: 'index',
        type: 'U256'
      }],
      type: 'EthRichBlock'
    },
    getUncleByBlockNumberAndIndex: {
      description: 'Returns an uncles at given block and index.',
      params: [{
        name: 'number',
        type: 'BlockNumber'
      }, {
        name: 'index',
        type: 'U256'
      }],
      type: 'EthRichBlock'
    },
    getUncleCountByBlockHash: {
      description: 'Returns the number of uncles in a block with given hash.',
      params: [{
        name: 'hash',
        type: 'H256'
      }],
      type: 'U256'
    },
    getUncleCountByBlockNumber: {
      description: 'Returns the number of uncles in a block with given block number.',
      params: [{
        name: 'number',
        type: 'BlockNumber'
      }],
      type: 'U256'
    },
    getWork: {
      description: 'Returns the hash of the current block, the seedHash, and the boundary condition to be met.',
      params: [],
      type: 'EthWork'
    },
    hashrate: {
      description: 'Returns the number of hashes per second that the node is mining with.',
      params: [],
      type: 'U256'
    },
    mining: {
      description: 'Returns true if client is actively mining new blocks.',
      params: [],
      type: 'bool'
    },
    newBlockFilter: {
      description: 'Returns id of new block filter.',
      params: [],
      type: 'U256'
    },
    newFilter: {
      description: 'Returns id of new filter.',
      params: [{
        name: 'filter',
        type: 'EthFilter'
      }],
      type: 'U256'
    },
    newPendingTransactionFilter: {
      description: 'Returns id of new block filter.',
      params: [],
      type: 'U256'
    },
    protocolVersion: {
      description: 'Returns protocol version encoded as a string (quotes are necessary).',
      params: [],
      type: 'u64'
    },
    sendRawTransaction: {
      description: 'Sends signed transaction, returning its hash.',
      params: [{
        name: 'bytes',
        type: 'Bytes'
      }],
      type: 'H256'
    },
    sendTransaction: {
      description: 'Sends transaction; will block waiting for signer to return the transaction hash',
      params: [{
        name: 'tx',
        type: 'EthTransactionRequest'
      }],
      type: 'H256'
    },
    submitHashrate: {
      description: 'Used for submitting mining hashrate.',
      params: [{
        name: 'index',
        type: 'U256'
      }, {
        name: 'hash',
        type: 'H256'
      }],
      type: 'bool'
    },
    submitWork: {
      description: 'Used for submitting a proof-of-work solution.',
      params: [{
        name: 'nonce',
        type: 'H64'
      }, {
        name: 'headerHash',
        type: 'H256'
      }, {
        name: 'mixDigest',
        type: 'H256'
      }],
      type: 'bool'
    },
    subscribe: {
      description: 'Subscribe to Eth subscription.',
      params: [{
        name: 'kind',
        type: 'EthSubKind'
      }, {
        isOptional: true,
        name: 'params',
        type: 'EthSubParams'
      }],
      pubsub: ['subscription', 'subscribe', 'unsubscribe'],
      type: 'Null'
    },
    syncing: {
      description: 'Returns an object with data about the sync status or false.',
      params: [],
      type: 'EthSyncStatus'
    },
    uninstallFilter: {
      description: 'Uninstalls filter.',
      params: [{
        name: 'index',
        type: 'U256'
      }],
      type: 'bool'
    }
  });

  const V0 = {
    BlockV0: {
      header: 'EthHeader',
      transactions: 'Vec<TransactionV0>',
      ommers: 'Vec<EthHeader>'
    },
    LegacyTransaction: {
      nonce: 'U256',
      gasPrice: 'U256',
      gasLimit: 'U256',
      action: 'EthTransactionAction',
      value: 'U256',
      input: 'Bytes',
      signature: 'EthTransactionSignature'
    },
    TransactionV0: 'LegacyTransaction'
  };
  const V1 = {
    BlockV1: {
      header: 'EthHeader',
      transactions: 'Vec<TransactionV1>',
      ommers: 'Vec<EthHeader>'
    },
    EIP2930Transaction: {
      chainId: 'u64',
      nonce: 'U256',
      gasPrice: 'U256',
      gasLimit: 'U256',
      action: 'EthTransactionAction',
      value: 'U256',
      input: 'Bytes',
      accessList: 'EthAccessList',
      oddYParity: 'bool',
      r: 'H256',
      s: 'H256'
    },
    TransactionV1: {
      _enum: {
        Legacy: 'LegacyTransaction',
        EIP2930: 'EIP2930Transaction'
      }
    }
  };
  const V2 = {
    BlockV2: {
      header: 'EthHeader',
      transactions: 'Vec<TransactionV2>',
      ommers: 'Vec<EthHeader>'
    },
    EIP1559Transaction: {
      chainId: 'u64',
      nonce: 'U256',
      maxPriorityFeePerGas: 'U256',
      maxFeePerGas: 'U256',
      gasLimit: 'U256',
      action: 'EthTransactionAction',
      value: 'U256',
      input: 'Bytes',
      accessList: 'EthAccessList',
      oddYParity: 'bool',
      r: 'H256',
      s: 'H256'
    },
    TransactionV2: {
      _enum: {
        Legacy: 'LegacyTransaction',
        EIP2930: 'EIP2930Transaction',
        EIP1559: 'EIP1559Transaction'
      }
    }
  };
  const types = objectSpread$1({}, V0, V1, V2, {
    EthereumAccountId: 'GenericEthereumAccountId',
    EthereumAddress: 'GenericEthereumAccountId',
    EthereumLookupSource: 'GenericEthereumLookupSource',
    EthereumSignature: '[u8; 65]',
    EthAccessListItem: {
      address: 'EthAddress',
      slots: 'Vec<H256>'
    },
    EthAccessList: 'Vec<EthAccessListItem>',
    EthAccount: {
      address: 'EthAddress',
      balance: 'U256',
      nonce: 'U256',
      codeHash: 'H256',
      storageHash: 'H256',
      accountProof: 'Vec<Bytes>',
      storageProof: 'Vec<EthStorageProof>'
    },
    EthAddress: 'H160',
    EthBlock: {
      header: 'EthHeader',
      transactions: 'Vec<EthTransaction>',
      ommers: 'Vec<EthHeader>'
    },
    EthHeader: {
      parentHash: 'H256',
      ommersHash: 'H256',
      beneficiary: 'EthAddress',
      stateRoot: 'H256',
      transactionsRoot: 'H256',
      receiptsRoot: 'H256',
      logsBloom: 'EthBloom',
      difficulty: 'U256',
      number: 'U256',
      gasLimit: 'U256',
      gasUsed: 'U256',
      timestamp: 'u64',
      extraData: 'Bytes',
      mixMash: 'H256',
      nonce: 'H64'
    },
    EthRichBlock: {
      _alias: {
        blockHash: 'hash',
        blockSize: 'size'
      },
      blockHash: 'Option<H256>',
      parentHash: 'H256',
      sha3Uncles: 'H256',
      author: 'EthAddress',
      miner: 'EthAddress',
      stateRoot: 'H256',
      transactionsRoot: 'H256',
      receiptsRoot: 'H256',
      number: 'Option<U256>',
      gasUsed: 'U256',
      gasLimit: 'U256',
      extraData: 'Bytes',
      logsBloom: 'EthBloom',
      timestamp: 'U256',
      difficulty: 'U256',
      totalDifficulty: 'Option<U256>',
      sealFields: 'Vec<Bytes>',
      uncles: 'Vec<H256>',
      transactions: 'Vec<EthTransaction>',
      blockSize: 'Option<U256>'
    },
    EthBloom: 'H2048',
    EthCallRequest: {
      from: 'Option<EthAddress>',
      to: 'Option<EthAddress>',
      gasPrice: 'Option<U256>',
      gas: 'Option<U256>',
      value: 'Option<U256>',
      data: 'Option<Bytes>',
      nonce: 'Option<U256>'
    },
    EthFilter: {
      fromBlock: 'Option<BlockNumber>',
      toBlock: 'Option<BlockNumber>',
      blockHash: 'Option<H256>',
      address: 'Option<EthFilterAddress>',
      topics: 'Option<EthFilterTopic>'
    },
    EthFilterAddress: {
      _enum: {
        Single: 'EthAddress',
        Multiple: 'Vec<EthAddress>',
        Null: 'Null'
      }
    },
    EthFilterChanges: {
      _enum: {
        Logs: 'Vec<EthLog>',
        Hashes: 'Vec<H256>',
        Empty: 'Null'
      }
    },
    EthFilterTopic: {
      _enum: {
        Single: 'EthFilterTopicInner',
        Multiple: 'Vec<EthFilterTopicInner>',
        Null: 'Null'
      }
    },
    EthFilterTopicEntry: 'Option<H256>',
    EthFilterTopicInner: {
      _enum: {
        Single: 'EthFilterTopicEntry',
        Multiple: 'Vec<EthFilterTopicEntry>',
        Null: 'Null'
      }
    },
    EthRichHeader: {
      _alias: {
        blockHash: 'hash',
        blockSize: 'size'
      },
      blockHash: 'Option<H256>',
      parentHash: 'H256',
      sha3Uncles: 'H256',
      author: 'EthAddress',
      miner: 'EthAddress',
      stateRoot: 'H256',
      transactionsRoot: 'H256',
      receiptsRoot: 'H256',
      number: 'Option<U256>',
      gasUsed: 'U256',
      gasLimit: 'U256',
      extraData: 'Bytes',
      logsBloom: 'EthBloom',
      timestamp: 'U256',
      difficulty: 'U256',
      sealFields: 'Vec<Bytes>',
      blockSize: 'Option<U256>'
    },
    EthLog: {
      address: 'EthAddress',
      topics: 'Vec<H256>',
      data: 'Bytes',
      blockHash: 'Option<H256>',
      blockNumber: 'Option<U256>',
      transactionHash: 'Option<H256>',
      transactionIndex: 'Option<U256>',
      logIndex: 'Option<U256>',
      transactionLogIndex: 'Option<U256>',
      removed: 'bool'
    },
    EthReceipt: {
      transactionHash: 'Option<H256>',
      transactionIndex: 'Option<U256>',
      blockHash: 'Option<H256>',
      from: 'Option<EthAddress>',
      to: 'Option<EthAddress>',
      blockNumber: 'Option<U256>',
      cumulativeGasUsed: 'U256',
      gasUsed: 'Option<U256>',
      contractAddress: 'Option<EthAddress>',
      logs: 'Vec<EthLog>',
      root: 'Option<H256>',
      logsBloom: 'EthBloom',
      statusCode: 'Option<U64>'
    },
    EthStorageProof: {
      key: 'U256',
      value: 'U256',
      proof: 'Vec<Bytes>'
    },
    EthSubKind: {
      _enum: ['newHeads', 'logs', 'newPendingTransactions', 'syncing']
    },
    EthSubParams: {
      _enum: {
        None: 'Null',
        Logs: 'EthFilter'
      }
    },
    EthSubResult: {
      _enum: {
        Header: 'EthRichHeader',
        Log: 'EthLog',
        TransactionHash: 'H256',
        SyncState: 'EthSyncStatus'
      }
    },
    EthSyncInfo: {
      startingBlock: 'U256',
      currentBlock: 'U256',
      highestBlock: 'U256',
      warpChunksAmount: 'Option<U256>',
      warpChunksProcessed: 'Option<U256>'
    },
    EthSyncStatus: {
      _enum: {
        Info: 'EthSyncInfo',
        None: 'Null'
      }
    },
    EthTransaction: 'LegacyTransaction',
    EthTransactionSignature: {
      v: 'u64',
      r: 'H256',
      s: 'H256'
    },
    EthTransactionAction: {
      _enum: {
        Call: 'H160',
        Create: 'Null'
      }
    },
    EthTransactionCondition: {
      _enum: {
        block: 'u64',
        time: 'u64'
      }
    },
    EthTransactionRequest: {
      from: 'Option<EthAddress>',
      to: 'Option<EthAddress>',
      gasPrice: 'Option<U256>',
      gas: 'Option<U256>',
      value: 'Option<U256>',
      data: 'Option<Bytes>',
      nonce: 'Option<U256>'
    },
    EthTransactionStatus: {
      transactionHash: 'H256',
      transactionIndex: 'u32',
      from: 'EthAddress',
      to: 'Option<EthAddress>',
      contractAddress: 'Option<EthAddress>',
      logs: 'Vec<EthLog>',
      logsBloom: 'EthBloom'
    },
    EthWork: {
      powHash: 'H256',
      seedHash: 'H256',
      target: 'H256',
      number: 'Option<u64>'
    }
  });
  const definitions$9 = {
    rpc,
    types
  };

  const AllHashers = {
    Blake2_128: null,
    Blake2_256: null,
    Blake2_128Concat: null,
    Twox128: null,
    Twox256: null,
    Twox64Concat: null,
    Identity: null
  };

  const v9 = {
    ErrorMetadataV9: {
      name: 'Text',
      docs: 'Vec<Text>'
    },
    EventMetadataV9: {
      name: 'Text',
      args: 'Vec<Type>',
      docs: 'Vec<Text>'
    },
    FunctionArgumentMetadataV9: {
      name: 'Text',
      type: 'Type'
    },
    FunctionMetadataV9: {
      name: 'Text',
      args: 'Vec<FunctionArgumentMetadataV9>',
      docs: 'Vec<Text>'
    },
    MetadataV9: {
      modules: 'Vec<ModuleMetadataV9>'
    },
    ModuleConstantMetadataV9: {
      name: 'Text',
      type: 'Type',
      value: 'Bytes',
      docs: 'Vec<Text>'
    },
    ModuleMetadataV9: {
      name: 'Text',
      storage: 'Option<StorageMetadataV9>',
      calls: 'Option<Vec<FunctionMetadataV9>>',
      events: 'Option<Vec<EventMetadataV9>>',
      constants: 'Vec<ModuleConstantMetadataV9>',
      errors: 'Vec<ErrorMetadataV9>'
    },
    StorageEntryMetadataV9: {
      name: 'Text',
      modifier: 'StorageEntryModifierV9',
      type: 'StorageEntryTypeV9',
      fallback: 'Bytes',
      docs: 'Vec<Text>'
    },
    StorageEntryModifierV9: {
      _enum: ['Optional', 'Default', 'Required']
    },
    StorageEntryTypeV9: {
      _enum: {
        Plain: 'Type',
        Map: {
          hasher: 'StorageHasherV9',
          key: 'Type',
          value: 'Type',
          linked: 'bool'
        },
        DoubleMap: {
          hasher: 'StorageHasherV9',
          key1: 'Type',
          key2: 'Type',
          value: 'Type',
          key2Hasher: 'StorageHasherV9'
        }
      }
    },
    StorageHasherV9: {
      _enum: {
        Blake2_128: null,
        Blake2_256: null,
        Twox128: null,
        Twox256: null,
        Twox64Concat: null
      }
    },
    StorageMetadataV9: {
      prefix: 'Text',
      items: 'Vec<StorageEntryMetadataV9>'
    }
  };

  const v10 = {
    ErrorMetadataV10: 'ErrorMetadataV9',
    EventMetadataV10: 'EventMetadataV9',
    FunctionArgumentMetadataV10: 'FunctionArgumentMetadataV9',
    FunctionMetadataV10: 'FunctionMetadataV9',
    MetadataV10: {
      modules: 'Vec<ModuleMetadataV10>'
    },
    ModuleConstantMetadataV10: 'ModuleConstantMetadataV9',
    ModuleMetadataV10: {
      name: 'Text',
      storage: 'Option<StorageMetadataV10>',
      calls: 'Option<Vec<FunctionMetadataV10>>',
      events: 'Option<Vec<EventMetadataV10>>',
      constants: 'Vec<ModuleConstantMetadataV10>',
      errors: 'Vec<ErrorMetadataV10>'
    },
    StorageEntryModifierV10: 'StorageEntryModifierV9',
    StorageEntryMetadataV10: {
      name: 'Text',
      modifier: 'StorageEntryModifierV10',
      type: 'StorageEntryTypeV10',
      fallback: 'Bytes',
      docs: 'Vec<Text>'
    },
    StorageEntryTypeV10: {
      _enum: {
        Plain: 'Type',
        Map: {
          hasher: 'StorageHasherV10',
          key: 'Type',
          value: 'Type',
          linked: 'bool'
        },
        DoubleMap: {
          hasher: 'StorageHasherV10',
          key1: 'Type',
          key2: 'Type',
          value: 'Type',
          key2Hasher: 'StorageHasherV10'
        }
      }
    },
    StorageMetadataV10: {
      prefix: 'Text',
      items: 'Vec<StorageEntryMetadataV10>'
    },
    StorageHasherV10: {
      _enum: {
        Blake2_128: null,
        Blake2_256: null,
        Blake2_128Concat: null,
        Twox128: null,
        Twox256: null,
        Twox64Concat: null
      }
    }
  };

  const v11 = {
    ErrorMetadataV11: 'ErrorMetadataV10',
    EventMetadataV11: 'EventMetadataV10',
    ExtrinsicMetadataV11: {
      version: 'u8',
      signedExtensions: 'Vec<Text>'
    },
    FunctionArgumentMetadataV11: 'FunctionArgumentMetadataV10',
    FunctionMetadataV11: 'FunctionMetadataV10',
    MetadataV11: {
      modules: 'Vec<ModuleMetadataV11>',
      extrinsic: 'ExtrinsicMetadataV11'
    },
    ModuleConstantMetadataV11: 'ModuleConstantMetadataV10',
    ModuleMetadataV11: {
      name: 'Text',
      storage: 'Option<StorageMetadataV11>',
      calls: 'Option<Vec<FunctionMetadataV11>>',
      events: 'Option<Vec<EventMetadataV11>>',
      constants: 'Vec<ModuleConstantMetadataV11>',
      errors: 'Vec<ErrorMetadataV11>'
    },
    StorageEntryModifierV11: 'StorageEntryModifierV10',
    StorageEntryMetadataV11: {
      name: 'Text',
      modifier: 'StorageEntryModifierV11',
      type: 'StorageEntryTypeV11',
      fallback: 'Bytes',
      docs: 'Vec<Text>'
    },
    StorageEntryTypeV11: {
      _enum: {
        Plain: 'Type',
        Map: {
          hasher: 'StorageHasherV11',
          key: 'Type',
          value: 'Type',
          linked: 'bool'
        },
        DoubleMap: {
          hasher: 'StorageHasherV11',
          key1: 'Type',
          key2: 'Type',
          value: 'Type',
          key2Hasher: 'StorageHasherV11'
        }
      }
    },
    StorageMetadataV11: {
      prefix: 'Text',
      items: 'Vec<StorageEntryMetadataV11>'
    },
    StorageHasherV11: {
      _enum: AllHashers
    }
  };

  const v12 = {
    ErrorMetadataV12: 'ErrorMetadataV11',
    EventMetadataV12: 'EventMetadataV11',
    ExtrinsicMetadataV12: 'ExtrinsicMetadataV11',
    FunctionArgumentMetadataV12: 'FunctionArgumentMetadataV11',
    FunctionMetadataV12: 'FunctionMetadataV11',
    MetadataV12: {
      modules: 'Vec<ModuleMetadataV12>',
      extrinsic: 'ExtrinsicMetadataV12'
    },
    ModuleConstantMetadataV12: 'ModuleConstantMetadataV11',
    ModuleMetadataV12: {
      name: 'Text',
      storage: 'Option<StorageMetadataV12>',
      calls: 'Option<Vec<FunctionMetadataV12>>',
      events: 'Option<Vec<EventMetadataV12>>',
      constants: 'Vec<ModuleConstantMetadataV12>',
      errors: 'Vec<ErrorMetadataV12>',
      index: 'u8'
    },
    StorageEntryModifierV12: 'StorageEntryModifierV11',
    StorageEntryMetadataV12: 'StorageEntryMetadataV11',
    StorageEntryTypeV12: 'StorageEntryTypeV11',
    StorageMetadataV12: 'StorageMetadataV11',
    StorageHasherV12: 'StorageHasherV11'
  };

  const v13 = {
    ErrorMetadataV13: 'ErrorMetadataV12',
    EventMetadataV13: 'EventMetadataV12',
    ExtrinsicMetadataV13: 'ExtrinsicMetadataV12',
    FunctionArgumentMetadataV13: 'FunctionArgumentMetadataV12',
    FunctionMetadataV13: 'FunctionMetadataV12',
    MetadataV13: {
      modules: 'Vec<ModuleMetadataV13>',
      extrinsic: 'ExtrinsicMetadataV13'
    },
    ModuleConstantMetadataV13: 'ModuleConstantMetadataV12',
    ModuleMetadataV13: {
      name: 'Text',
      storage: 'Option<StorageMetadataV13>',
      calls: 'Option<Vec<FunctionMetadataV13>>',
      events: 'Option<Vec<EventMetadataV13>>',
      constants: 'Vec<ModuleConstantMetadataV13>',
      errors: 'Vec<ErrorMetadataV13>',
      index: 'u8'
    },
    StorageEntryModifierV13: 'StorageEntryModifierV12',
    StorageEntryMetadataV13: {
      name: 'Text',
      modifier: 'StorageEntryModifierV13',
      type: 'StorageEntryTypeV13',
      fallback: 'Bytes',
      docs: 'Vec<Text>'
    },
    StorageEntryTypeV13: {
      _enum: {
        Plain: 'Type',
        Map: {
          hasher: 'StorageHasherV13',
          key: 'Type',
          value: 'Type',
          linked: 'bool'
        },
        DoubleMap: {
          hasher: 'StorageHasherV13',
          key1: 'Type',
          key2: 'Type',
          value: 'Type',
          key2Hasher: 'StorageHasherV13'
        },
        NMap: {
          keyVec: 'Vec<Type>',
          hashers: 'Vec<StorageHasherV13>',
          value: 'Type'
        }
      }
    },
    StorageMetadataV13: {
      prefix: 'Text',
      items: 'Vec<StorageEntryMetadataV13>'
    },
    StorageHasherV13: 'StorageHasherV12'
  };

  const v14 = {
    PortableTypeV14: {
      id: 'Si1LookupTypeId',
      type: 'Si1Type'
    },
    ErrorMetadataV14: objectSpread$1({}, Si1Variant, {
      args: 'Vec<Type>'
    }),
    EventMetadataV14: objectSpread$1({}, Si1Variant, {
      args: 'Vec<Type>'
    }),
    FunctionArgumentMetadataV14: {
      name: 'Text',
      type: 'Type',
      typeName: 'Option<Type>'
    },
    FunctionMetadataV14: objectSpread$1({}, Si1Variant, {
      args: 'Vec<FunctionArgumentMetadataV14>'
    }),
    ExtrinsicMetadataV14: {
      type: 'SiLookupTypeId',
      version: 'u8',
      signedExtensions: 'Vec<SignedExtensionMetadataV14>'
    },
    MetadataV14: {
      lookup: 'PortableRegistry',
      pallets: 'Vec<PalletMetadataV14>',
      extrinsic: 'ExtrinsicMetadataV14',
      type: 'SiLookupTypeId'
    },
    PalletCallMetadataV14: {
      type: 'SiLookupTypeId'
    },
    PalletConstantMetadataV14: {
      name: 'Text',
      type: 'SiLookupTypeId',
      value: 'Bytes',
      docs: 'Vec<Text>'
    },
    PalletErrorMetadataV14: {
      type: 'SiLookupTypeId'
    },
    PalletEventMetadataV14: {
      type: 'SiLookupTypeId'
    },
    PalletMetadataV14: {
      name: 'Text',
      storage: 'Option<PalletStorageMetadataV14>',
      calls: 'Option<PalletCallMetadataV14>',
      events: 'Option<PalletEventMetadataV14>',
      constants: 'Vec<PalletConstantMetadataV14>',
      errors: 'Option<PalletErrorMetadataV14>',
      index: 'u8'
    },
    PalletStorageMetadataV14: {
      prefix: 'Text',
      items: 'Vec<StorageEntryMetadataV14>'
    },
    SignedExtensionMetadataV14: {
      identifier: 'Text',
      type: 'SiLookupTypeId',
      additionalSigned: 'SiLookupTypeId'
    },
    StorageEntryMetadataV14: {
      name: 'Text',
      modifier: 'StorageEntryModifierV14',
      type: 'StorageEntryTypeV14',
      fallback: 'Bytes',
      docs: 'Vec<Text>'
    },
    StorageEntryModifierV14: 'StorageEntryModifierV13',
    StorageEntryTypeV14: {
      _enum: {
        Plain: 'SiLookupTypeId',
        Map: {
          hashers: 'Vec<StorageHasherV14>',
          key: 'SiLookupTypeId',
          value: 'SiLookupTypeId'
        }
      }
    },
    StorageHasherV14: 'StorageHasherV13'
  };

  const definitions$8 = {
    rpc: {},
    types: objectSpread$1({}, v9, v10, v11, v12, v13, v14, {
      ErrorMetadataLatest: 'ErrorMetadataV14',
      EventMetadataLatest: 'EventMetadataV14',
      ExtrinsicMetadataLatest: 'ExtrinsicMetadataV14',
      FunctionArgumentMetadataLatest: 'FunctionArgumentMetadataV14',
      FunctionMetadataLatest: 'FunctionMetadataV14',
      MetadataLatest: 'MetadataV14',
      PalletCallMetadataLatest: 'PalletCallMetadataV14',
      PalletConstantMetadataLatest: 'PalletConstantMetadataV14',
      PalletErrorMetadataLatest: 'PalletErrorMetadataV14',
      PalletEventMetadataLatest: 'PalletEventMetadataV14',
      PalletMetadataLatest: 'PalletMetadataV14',
      PalletStorageMetadataLatest: 'PalletStorageMetadataV14',
      PortableType: 'PortableTypeV14',
      SignedExtensionMetadataLatest: 'SignedExtensionMetadataV14',
      StorageEntryMetadataLatest: 'StorageEntryMetadataV14',
      StorageEntryModifierLatest: 'StorageEntryModifierV14',
      StorageEntryTypeLatest: 'StorageEntryTypeV14',
      StorageHasher: 'StorageHasherV14',
      MetadataAll: {
        _enum: {
          V0: 'DoNotConstruct<MetadataV0>',
          V1: 'DoNotConstruct<MetadataV1>',
          V2: 'DoNotConstruct<MetadataV2>',
          V3: 'DoNotConstruct<MetadataV3>',
          V4: 'DoNotConstruct<MetadataV4>',
          V5: 'DoNotConstruct<MetadataV5>',
          V6: 'DoNotConstruct<MetadataV6>',
          V7: 'DoNotConstruct<MetadataV7>',
          V8: 'DoNotConstruct<MetadataV8>',
          V9: 'MetadataV9',
          V10: 'MetadataV10',
          V11: 'MetadataV11',
          V12: 'MetadataV12',
          V13: 'MetadataV13',
          V14: 'MetadataV14'
        }
      }
    })
  };

  const definitions$7 = {
    rpc: {
      methods: {
        description: 'Retrieves the list of RPC methods that are exposed by the node',
        params: [],
        type: 'RpcMethods'
      }
    },
    types: {
      RpcMethods: {
        version: 'u32',
        methods: 'Vec<Text>'
      }
    }
  };

  const definitions$6 = {
    rpc: {
      hasKey: {
        description: 'Returns true if the keystore has private keys for the given public key and key type.',
        params: [{
          name: 'publicKey',
          type: 'Bytes'
        }, {
          name: 'keyType',
          type: 'Text'
        }],
        type: 'bool'
      },
      hasSessionKeys: {
        description: 'Returns true if the keystore has private keys for the given session public keys.',
        params: [{
          name: 'sessionKeys',
          type: 'Bytes'
        }],
        type: 'bool'
      },
      removeExtrinsic: {
        description: 'Remove given extrinsic from the pool and temporarily ban it to prevent reimporting',
        params: [{
          name: 'bytesOrHash',
          type: 'Vec<ExtrinsicOrHash>'
        }],
        type: 'Vec<Hash>'
      },
      insertKey: {
        description: 'Insert a key into the keystore.',
        params: [{
          name: 'keyType',
          type: 'Text'
        }, {
          name: 'suri',
          type: 'Text'
        }, {
          name: 'publicKey',
          type: 'Bytes'
        }],
        type: 'Bytes'
      },
      rotateKeys: {
        description: 'Generate new session keys and returns the corresponding public keys',
        params: [],
        type: 'Bytes'
      },
      pendingExtrinsics: {
        description: 'Returns all pending extrinsics, potentially grouped by sender',
        params: [],
        type: 'Vec<Extrinsic>'
      },
      submitExtrinsic: {
        isSigned: true,
        description: 'Submit a fully formatted extrinsic for block inclusion',
        params: [{
          name: 'extrinsic',
          type: 'Extrinsic'
        }],
        type: 'Hash'
      },
      submitAndWatchExtrinsic: {
        description: 'Submit and subscribe to watch an extrinsic until unsubscribed',
        isSigned: true,
        params: [{
          name: 'extrinsic',
          type: 'Extrinsic'
        }],
        pubsub: ['extrinsicUpdate', 'submitAndWatchExtrinsic', 'unwatchExtrinsic'],
        type: 'ExtrinsicStatus'
      }
    },
    types: {
      ExtrinsicOrHash: {
        _enum: {
          Hash: 'Hash',
          Extrinsic: 'Bytes'
        }
      },
      ExtrinsicStatus: {
        _enum: {
          Future: 'Null',
          Ready: 'Null',
          Broadcast: 'Vec<Text>',
          InBlock: 'Hash',
          Retracted: 'Hash',
          FinalityTimeout: 'Hash',
          Finalized: 'Hash',
          Usurped: 'Hash',
          Dropped: 'Null',
          Invalid: 'Null'
        }
      }
    }
  };

  const definitions$5 = {
    rpc: {
      getHeader: {
        alias: ['chain_getHead'],
        description: 'Retrieves the header for a specific block',
        params: [{
          name: 'hash',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Header'
      },
      getBlock: {
        description: 'Get header and body of a relay chain block',
        params: [{
          name: 'hash',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'SignedBlock'
      },
      getBlockHash: {
        description: 'Get the block hash for a specific block',
        params: [{
          name: 'blockNumber',
          type: 'BlockNumber',
          isOptional: true
        }],
        type: 'BlockHash'
      },
      getFinalizedHead: {
        alias: ['chain_getFinalisedHead'],
        description: 'Get hash of the last finalized block in the canon chain',
        params: [],
        type: 'BlockHash'
      },
      subscribeNewHeads: {
        alias: ['chain_unsubscribeNewHeads', 'subscribe_newHead', 'unsubscribe_newHead'],
        description: 'Retrieves the best header via subscription',
        params: [],
        pubsub: ['newHead', 'subscribeNewHead', 'unsubscribeNewHead'],
        type: 'Header'
      },
      subscribeFinalizedHeads: {
        alias: ['chain_subscribeFinalisedHeads', 'chain_unsubscribeFinalisedHeads'],
        description: 'Retrieves the best finalized header via subscription',
        params: [],
        pubsub: ['finalizedHead', 'subscribeFinalizedHeads', 'unsubscribeFinalizedHeads'],
        type: 'Header'
      },
      subscribeAllHeads: {
        description: 'Retrieves the newest header via subscription',
        params: [],
        pubsub: ['allHead', 'subscribeAllHeads', 'unsubscribeAllHeads'],
        type: 'Header'
      }
    },
    types: {
      BlockHash: 'Hash'
    }
  };

  const definitions$4 = {
    rpc: {
      getKeys: {
        description: 'Returns the keys with prefix from a child storage, leave empty to get all the keys',
        params: [{
          name: 'childKey',
          type: 'PrefixedStorageKey'
        }, {
          name: 'prefix',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'Hash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Vec<StorageKey>'
      },
      getKeysPaged: {
        alias: ['childstate_getKeysPagedAt'],
        description: 'Returns the keys with prefix from a child storage with pagination support',
        params: [{
          name: 'childKey',
          type: 'PrefixedStorageKey'
        }, {
          name: 'prefix',
          type: 'StorageKey'
        }, {
          name: 'count',
          type: 'u32'
        }, {
          name: 'startKey',
          type: 'StorageKey',
          isOptional: true
        }, {
          name: 'at',
          type: 'Hash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Vec<StorageKey>'
      },
      getStorage: {
        description: 'Returns a child storage entry at a specific block state',
        params: [{
          name: 'childKey',
          type: 'PrefixedStorageKey'
        }, {
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'Hash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Option<StorageData>'
      },
      getStorageEntries: {
        description: 'Returns child storage entries for multiple keys at a specific block state',
        params: [{
          name: 'childKey',
          type: 'PrefixedStorageKey'
        }, {
          name: 'keys',
          type: 'Vec<StorageKey>'
        }, {
          name: 'at',
          type: 'Hash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Vec<Option<StorageData>>'
      },
      getStorageHash: {
        description: 'Returns the hash of a child storage entry at a block state',
        params: [{
          name: 'childKey',
          type: 'PrefixedStorageKey'
        }, {
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'Hash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Option<Hash>'
      },
      getStorageSize: {
        description: 'Returns the size of a child storage entry at a block state',
        params: [{
          name: 'childKey',
          type: 'PrefixedStorageKey'
        }, {
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'Hash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Option<u64>'
      }
    },
    types: {
      PrefixedStorageKey: 'StorageKey'
    }
  };

  const definitions$3 = {
    rpc: {
      localStorageSet: {
        description: 'Set offchain local storage under given key and prefix',
        params: [{
          name: 'kind',
          type: 'StorageKind'
        }, {
          name: 'key',
          type: 'Bytes'
        }, {
          name: 'value',
          type: 'Bytes'
        }],
        type: 'Null'
      },
      localStorageGet: {
        description: 'Get offchain local storage under given key and prefix',
        params: [{
          name: 'kind',
          type: 'StorageKind'
        }, {
          name: 'key',
          type: 'Bytes'
        }],
        type: 'Option<Bytes>'
      }
    },
    types: {
      StorageKind: {
        _enum: {
          PERSISTENT: 1,
          LOCAL: 2
        }
      }
    }
  };

  const QUERY_PARAMS = [{
    name: 'extrinsic',
    type: 'Bytes'
  }, {
    name: 'at',
    type: 'BlockHash',
    isHistoric: true,
    isOptional: true
  }];
  const definitions$2 = {
    rpc: {
      queryInfo: {
        description: 'Retrieves the fee information for an encoded extrinsic',
        params: QUERY_PARAMS,
        type: 'RuntimeDispatchInfo'
      },
      queryFeeDetails: {
        description: 'Query the detailed fee of a given encoded extrinsic',
        params: QUERY_PARAMS,
        type: 'FeeDetails'
      }
    },
    types: {
      FeeDetails: {
        inclusionFee: 'Option<InclusionFee>'
      },
      InclusionFee: {
        baseFee: 'Balance',
        lenFee: 'Balance',
        adjustedWeightFee: 'Balance'
      },
      RuntimeDispatchInfo: {
        weight: 'Weight',
        class: 'DispatchClass',
        partialFee: 'Balance'
      }
    }
  };

  const definitions$1 = {
    rpc: {
      call: {
        alias: ['state_callAt'],
        description: 'Perform a call to a builtin on the chain',
        params: [{
          name: 'method',
          type: 'Text'
        }, {
          name: 'data',
          type: 'Bytes'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Bytes'
      },
      getKeys: {
        description: 'Retrieves the keys with a certain prefix',
        params: [{
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Vec<StorageKey>'
      },
      getPairs: {
        description: 'Returns the keys with prefix, leave empty to get all the keys (deprecated: Use getKeysPaged)',
        params: [{
          name: 'prefix',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Vec<KeyValue>'
      },
      getKeysPaged: {
        alias: ['state_getKeysPagedAt'],
        description: 'Returns the keys with prefix with pagination support.',
        params: [{
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'count',
          type: 'u32'
        }, {
          name: 'startKey',
          type: 'StorageKey',
          isOptional: true
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Vec<StorageKey>'
      },
      getStorage: {
        alias: ['state_getStorageAt'],
        description: 'Retrieves the storage for a key',
        params: [{
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'StorageData'
      },
      getStorageHash: {
        alias: ['state_getStorageHashAt'],
        description: 'Retrieves the storage hash',
        params: [{
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Hash'
      },
      getStorageSize: {
        alias: ['state_getStorageSizeAt'],
        description: 'Retrieves the storage size',
        params: [{
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'u64'
      },
      getChildKeys: {
        description: 'Retrieves the keys with prefix of a specific child storage',
        params: [{
          name: 'childStorageKey',
          type: 'StorageKey'
        }, {
          name: 'childDefinition',
          type: 'StorageKey'
        }, {
          name: 'childType',
          type: 'u32'
        }, {
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Vec<StorageKey>'
      },
      getChildStorage: {
        description: 'Retrieves the child storage for a key',
        params: [{
          name: 'childStorageKey',
          type: 'StorageKey'
        }, {
          name: 'childDefinition',
          type: 'StorageKey'
        }, {
          name: 'childType',
          type: 'u32'
        }, {
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'StorageData'
      },
      getChildStorageHash: {
        description: 'Retrieves the child storage hash',
        params: [{
          name: 'childStorageKey',
          type: 'StorageKey'
        }, {
          name: 'childDefinition',
          type: 'StorageKey'
        }, {
          name: 'childType',
          type: 'u32'
        }, {
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Hash'
      },
      getChildStorageSize: {
        description: 'Retrieves the child storage size',
        params: [{
          name: 'childStorageKey',
          type: 'StorageKey'
        }, {
          name: 'childDefinition',
          type: 'StorageKey'
        }, {
          name: 'childType',
          type: 'u32'
        }, {
          name: 'key',
          type: 'StorageKey'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'u64'
      },
      getMetadata: {
        description: 'Returns the runtime metadata',
        params: [{
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Metadata'
      },
      getRuntimeVersion: {
        alias: ['chain_getRuntimeVersion'],
        description: 'Get the runtime version',
        params: [{
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'RuntimeVersion'
      },
      queryStorage: {
        description: 'Query historical storage entries (by key) starting from a start block',
        params: [{
          name: 'keys',
          type: 'Vec<StorageKey>'
        }, {
          name: 'fromBlock',
          type: 'Hash'
        }, {
          name: 'toBlock',
          type: 'BlockHash',
          isOptional: true
        }],
        type: 'Vec<StorageChangeSet>'
      },
      queryStorageAt: {
        description: 'Query storage entries (by key) starting at block hash given as the second parameter',
        params: [{
          name: 'keys',
          type: 'Vec<StorageKey>'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'Vec<StorageChangeSet>'
      },
      getChildReadProof: {
        description: 'Returns proof of storage for child key entries at a specific block state.',
        params: [{
          name: 'childStorageKey',
          type: 'PrefixedStorageKey'
        }, {
          name: 'keys',
          type: 'Vec<StorageKey>'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'ReadProof'
      },
      getReadProof: {
        description: 'Returns proof of storage entries at a specific block state',
        params: [{
          name: 'keys',
          type: 'Vec<StorageKey>'
        }, {
          name: 'at',
          type: 'BlockHash',
          isHistoric: true,
          isOptional: true
        }],
        type: 'ReadProof'
      },
      subscribeRuntimeVersion: {
        alias: ['chain_subscribeRuntimeVersion', 'chain_unsubscribeRuntimeVersion'],
        description: 'Retrieves the runtime version via subscription',
        params: [],
        pubsub: ['runtimeVersion', 'subscribeRuntimeVersion', 'unsubscribeRuntimeVersion'],
        type: 'RuntimeVersion'
      },
      subscribeStorage: {
        description: 'Subscribes to storage changes for the provided keys',
        params: [{
          name: 'keys',
          type: 'Vec<StorageKey>',
          isOptional: true
        }],
        pubsub: ['storage', 'subscribeStorage', 'unsubscribeStorage'],
        type: 'StorageChangeSet'
      },
      traceBlock: {
        description: 'Provides a way to trace the re-execution of a single block',
        params: [{
          name: 'block',
          type: 'Hash'
        }, {
          name: 'targets',
          type: 'Option<Text>'
        }, {
          name: 'storageKeys',
          type: 'Option<Text>'
        }],
        type: 'TraceBlockResponse'
      }
    },
    types: {
      ApiId: '[u8; 8]',
      BlockTrace: {
        blockHash: 'Text',
        parentHash: 'Text',
        tracingTargets: 'Text',
        storageKeys: 'Text',
        spans: 'Vec<BlockTraceSpan>',
        events: 'Vec<BlockTraceEvent>'
      },
      BlockTraceEvent: {
        target: 'Text',
        data: 'BlockTraceEventData',
        parentId: 'Option<u64>'
      },
      BlockTraceEventData: {
        stringValues: 'HashMap<Text, Text>'
      },
      BlockTraceSpan: {
        id: 'u64',
        parentId: 'Option<u64>',
        name: 'Text',
        target: 'Text',
        wasm: 'bool'
      },
      KeyValueOption: '(StorageKey, Option<StorageData>)',
      ReadProof: {
        at: 'Hash',
        proof: 'Vec<Bytes>'
      },
      RuntimeVersionApi: '(ApiId, u32)',
      RuntimeVersion: {
        specName: 'Text',
        implName: 'Text',
        authoringVersion: 'u32',
        specVersion: 'u32',
        implVersion: 'u32',
        apis: 'Vec<RuntimeVersionApi>',
        transactionVersion: 'u32'
      },
      RuntimeVersionPartial: {
        specName: 'Text',
        specVersion: 'u32'
      },
      SpecVersion: 'u32',
      StorageChangeSet: {
        block: 'Hash',
        changes: 'Vec<KeyValueOption>'
      },
      TraceBlockResponse: {
        _enum: {
          TraceError: 'TraceError',
          BlockTrace: 'BlockTrace'
        }
      },
      TraceError: {
        error: 'Text'
      }
    }
  };

  const definitions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    runtime: definitions$V,
    assets: definitions$U,
    authorship: definitions$T,
    aura: definitions$S,
    babe: definitions$R,
    balances: definitions$Q,
    beefy: definitions$P,
    collective: definitions$O,
    consensus: definitions$N,
    contracts: definitions$M,
    democracy: definitions$L,
    elections: definitions$K,
    engine: definitions$J,
    evm: definitions$I,
    extrinsics: definitions$H,
    genericAsset: definitions$G,
    gilt: definitions$F,
    grandpa: definitions$E,
    identity: definitions$D,
    imOnline: definitions$C,
    lottery: definitions$B,
    mmr: definitions$A,
    offences: definitions$z,
    proxy: definitions$y,
    recovery: definitions$x,
    scheduler: definitions$w,
    session: definitions$v,
    society: definitions$u,
    staking: definitions$t,
    support: definitions$s,
    syncstate: definitions$r,
    system: definitions$q,
    treasury: definitions$p,
    txpayment: definitions$o,
    uniques: definitions$n,
    utility: definitions$m,
    vesting: definitions$l,
    attestations: definitions$k,
    bridges: definitions$j,
    claims: definitions$i,
    crowdloan: definitions$h,
    cumulus: definitions$g,
    parachains: definitions$f,
    poll: definitions$e,
    purchase: definitions$d,
    xcm: definitions$c,
    contractsAbi: definitions$b,
    scaleInfo: definitions$a,
    eth: definitions$9,
    metadata: definitions$8,
    rpc: definitions$7,
    author: definitions$6,
    chain: definitions$5,
    childstate: definitions$4,
    offchain: definitions$3,
    payment: definitions$2,
    state: definitions$1
  });

  const jsonrpc = {};
  Object.keys(definitions).filter(key => Object.keys(definitions[key].rpc || {}).length !== 0).forEach(_section => {
    jsonrpc[_section] = {};
    Object.entries(definitions[_section].rpc).forEach(([method, def]) => {
      const isSubscription = !!def.pubsub;
      const section = def.aliasSection || _section;
      if (!jsonrpc[section]) {
        jsonrpc[section] = {};
      }
      jsonrpc[section][method] = objectSpread$1({}, def, {
        isSubscription,
        jsonrpc: `${section}_${method}`,
        method,
        section
      });
    });
  });
  const jsonrpc$1 = jsonrpc;

  function _classPrivateFieldBase(receiver, privateKey) {
    if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
      throw new TypeError("attempted to use private field on non-instance");
    }
    return receiver;
  }

  var id = 0;
  function _classPrivateFieldKey(name) {
    return "__private_" + id++ + "_" + name;
  }

  function hasEq(o) {
    return isFunction$1(o.eq);
  }

  function compareArray(a, b) {
    if (Array.isArray(b)) {
      return a.length === b.length && isUndefined(a.find((v, index) => hasEq(v) ? !v.eq(b[index]) : v !== b[index]));
    }
    return false;
  }

  class AbstractArray extends Array {
    constructor(registry, values, initialU8aLength) {
      super(values.length);
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.initialU8aLength = void 0;
      for (let i = 0; i < values.length; i++) {
        this[i] = values[i];
      }
      this.registry = registry;
      this.initialU8aLength = initialU8aLength;
    }
    get encodedLength() {
      let total = compactToU8a(this.length).length;
      for (let i = 0; i < this.length; i++) {
        total += this[i].encodedLength;
      }
      return total;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this.length === 0;
    }
    get length() {
      return super.length;
    }
    eq(other) {
      return compareArray(this, other);
    }
    toArray() {
      return Array.from(this);
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toHuman(isExtended) {
      const result = new Array(this.length);
      for (let i = 0; i < this.length; i++) {
        result[i] = this[i].toHuman(isExtended);
      }
      return result;
    }
    toJSON() {
      const result = new Array(this.length);
      for (let i = 0; i < this.length; i++) {
        result[i] = this[i].toJSON();
      }
      return result;
    }
    toString() {
      const result = new Array(this.length);
      for (let i = 0; i < this.length; i++) {
        result[i] = this[i].toString();
      }
      return `[${result.join(', ')}]`;
    }
    toU8a(isBare) {
      const encoded = new Array(this.length);
      for (let i = 0; i < this.length; i++) {
        encoded[i] = this[i].toU8a(isBare);
      }
      return isBare ? u8aConcat$1(...encoded) : u8aConcat$1(compactToU8a(this.length), ...encoded);
    }
    concat(other) {
      return this.toArray().concat(other instanceof AbstractArray ? other.toArray() : other);
    }
    filter(callbackfn, thisArg) {
      return this.toArray().filter(callbackfn, thisArg);
    }
    map(callbackfn, thisArg) {
      return this.toArray().map(callbackfn, thisArg);
    }
    includes(check) {
      return this.some(value => value.eq(check));
    }
    slice(start, end) {
      return this.toArray().slice(start, end);
    }
  }

  class Null {
    constructor(registry) {
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.registry = registry;
    }
    get encodedLength() {
      return 0;
    }
    get hash() {
      throw new Error('.hash is not implemented on Null');
    }
    get isEmpty() {
      return true;
    }
    eq(other) {
      return other instanceof Null || isNull(other);
    }
    toHex() {
      return '0x';
    }
    toHuman() {
      return this.toJSON();
    }
    toJSON() {
      return null;
    }
    toRawType() {
      return 'Null';
    }
    toString() {
      return '';
    }
    toU8a(isBare) {
      return new Uint8Array();
    }
  }

  function hasMismatch(a, b) {
    return isUndefined(a) || (hasEq(a) ? !a.eq(b) : a !== b);
  }
  function notEntry(value) {
    return !Array.isArray(value) || value.length !== 2;
  }
  function compareMapArray(a, b) {
    return a.size === b.length && !b.some(e => notEntry(e) || hasMismatch(a.get(e[0]), e[1]));
  }
  function compareMap(a, b) {
    if (Array.isArray(b)) {
      return compareMapArray(a, b);
    } else if (b instanceof Map) {
      return compareMapArray(a, [...b.entries()]);
    } else if (isObject(b)) {
      return compareMapArray(a, Object.entries(b));
    }
    return false;
  }

  function compareSetArray(a, b) {
    return a.size === b.length && !b.some(e => !a.has(e));
  }
  function compareSet(a, b) {
    if (Array.isArray(b)) {
      return compareSetArray(a, b);
    } else if (b instanceof Set) {
      return compareSetArray(a, [...b.values()]);
    } else if (isObject(b)) {
      return compareSetArray(a, Object.values(b));
    }
    return false;
  }

  function formatFailure(error, type, u8a, key) {
    return `decodeU8a: failed at ${u8aToHex$1(u8a)}…${key ? ` on ${key}` : ''}${type ? `: ${type}` : ''}:: ${error.message}`;
  }
  function getRawType(registry, Type) {
    try {
      return new Type(registry).toRawType();
    } catch {
      return '';
    }
  }
  function decodeU8a$3(registry, u8a, types, zip) {
    const [Types, keys] = Array.isArray(types) ? [types, []] : [Object.values(types), Object.keys(types)];
    const result = new Array(Types.length);
    let offset = 0;
    for (let i = 0; i < Types.length; i++) {
      try {
        const value = new Types[i](registry, u8a.subarray(offset));
        offset += value.initialU8aLength || value.encodedLength;
        result[i] = zip ? zip(keys[i], value) : value;
      } catch (error) {
        throw new Error(formatFailure(error, getRawType(registry, Types[i]), u8a.subarray(offset, offset + 16), keys[i]));
      }
    }
    return [result, offset];
  }
  function decodeU8aVec(registry, u8a, start, Type, count) {
    const result = new Array(count);
    let offset = start;
    for (let i = 0; i < count; i++) {
      try {
        const value = new Type(registry, u8a.subarray(offset));
        offset += value.initialU8aLength || value.encodedLength;
        result[i] = value;
      } catch (error) {
        throw new Error(formatFailure(error, getRawType(registry, Type), u8a.subarray(offset, offset + 16)));
      }
    }
    return [result, offset, offset - start];
  }

  function typeToConstructor(registry, type) {
    return isString$1(type) ? registry.createClass(type) : type;
  }

  function mapToTypeMap(registry, input) {
    const entries = Object.entries(input);
    const output = {};
    for (let i = 0; i < entries.length; i++) {
      output[entries[i][0]] = typeToConstructor(registry, entries[i][1]);
    }
    return output;
  }

  function isArrayLike(arg) {
    return arg instanceof Uint8Array || Array.isArray(arg);
  }
  function isCodec(arg) {
    return isFunction$1(arg && arg.toU8a);
  }
  function isEnum(arg) {
    return isCodec(arg) && isNumber$1(arg.index) && isCodec(arg.value);
  }
  function isNumberLike(arg) {
    return isNumber$1(arg) || isBn(arg) || isBigInt$1(arg);
  }
  function sortArray(a, b) {
    let sortRes = 0;
    const minLen = Math.min(a.length, b.length);
    for (let i = 0; i < minLen; ++i) {
      sortRes = sortAsc(a[i], b[i]);
      if (sortRes !== 0) {
        return sortRes;
      }
    }
    return a.length - b.length;
  }
  function sortAsc(a, b) {
    if (isNumberLike(a) && isNumberLike(b)) {
      return bnToBn$1(a).cmp(bnToBn$1(b));
    } else if (a instanceof Map && b instanceof Map) {
      return sortAsc(Array.from(a.values()), Array.from(b.values()));
    } else if (isEnum(a) && isEnum(b)) {
      return sortAsc(a.index, b.index) || sortAsc(a.value, b.value);
    } else if (isArrayLike(a) && isArrayLike(b)) {
      return sortArray(a, b);
    } else if (isCodec(a) && isCodec(b)) {
      return sortAsc(a.toU8a(true), b.toU8a(true));
    }
    throw new Error(`Attempting to sort unrecognized values: ${stringify(a)} (typeof ${typeof a}) <-> ${stringify(b)} (typeof ${typeof b})`);
  }
  function sortSet(set) {
    return new Set(Array.from(set).sort(sortAsc));
  }
  function sortMap(map) {
    return new Map(Array.from(map.entries()).sort(([keyA], [keyB]) => sortAsc(keyA, keyB)));
  }

  function typesToMap(registry, Types) {
    const entries = Object.entries(Types);
    const result = {};
    for (let i = 0; i < entries.length; i++) {
      const [key, Type] = entries[i];
      result[key] = registry.getClassName(Type) || new Type(registry).toRawType();
    }
    return result;
  }

  function isRustEnum$1(def) {
    const defValues = Object.values(def);
    if (defValues.some(v => isNumber$1(v))) {
      assert$h(defValues.every(v => isNumber$1(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');
      return false;
    }
    return true;
  }
  function extractDef(registry, _def) {
    if (Array.isArray(_def)) {
      return {
        def: _def.reduce((def, key, index) => {
          def[key] = {
            Type: Null,
            index
          };
          return def;
        }, {}),
        isBasic: true,
        isIndexed: false
      };
    }
    let isBasic;
    let isIndexed;
    let def;
    if (isRustEnum$1(_def)) {
      def = Object.entries(mapToTypeMap(registry, _def)).reduce((def, [key, Type], index) => {
        def[key] = {
          Type,
          index
        };
        return def;
      }, {});
      isBasic = !Object.values(def).some(({
        Type
      }) => Type !== Null);
      isIndexed = false;
    } else {
      def = Object.entries(_def).reduce((def, [key, index]) => {
        def[key] = {
          Type: Null,
          index
        };
        return def;
      }, {});
      isBasic = true;
      isIndexed = true;
    }
    return {
      def,
      isBasic,
      isIndexed
    };
  }
  function createFromValue(registry, def, index = 0, value) {
    const entry = Object.values(def).find(e => e.index === index);
    assert$h(!isUndefined(entry), () => `Unable to create Enum via index ${index}, in ${Object.keys(def).join(', ')}`);
    return {
      index,
      value: value instanceof entry.Type ? value : new entry.Type(registry, value)
    };
  }
  function decodeFromJSON(registry, def, key, value) {
    const keys = Object.keys(def).map(k => k.toLowerCase());
    const keyLower = key.toLowerCase();
    const index = keys.indexOf(keyLower);
    assert$h(index !== -1, () => `Cannot map Enum JSON, unable to find '${key}' in ${keys.join(', ')}`);
    try {
      return createFromValue(registry, def, Object.values(def)[index].index, value);
    } catch (error) {
      throw new Error(`Enum(${key}):: ${error.message}`);
    }
  }
  function decodeFromString(registry, def, value) {
    return isHex$1(value)
    ? decodeFromValue(registry, def, hexToU8a$1(value)) : decodeFromJSON(registry, def, value);
  }
  function decodeFromValue(registry, def, value) {
    if (isU8a$1(value)) {
      if (value.length) {
        return createFromValue(registry, def, value[0], value.subarray(1));
      }
    } else if (isNumber$1(value)) {
      return createFromValue(registry, def, value);
    } else if (isString$1(value)) {
      return decodeFromString(registry, def, value.toString());
    } else if (isObject(value)) {
      const key = Object.keys(value)[0];
      return decodeFromJSON(registry, def, key, value[key]);
    }
    return createFromValue(registry, def, Object.values(def)[0].index);
  }
  function decodeEnum(registry, def, value, index) {
    if (isNumber$1(index)) {
      return createFromValue(registry, def, index, value);
    } else if (value instanceof Enum) {
      return createFromValue(registry, def, value.index, value.value);
    }
    return decodeFromValue(registry, def, value);
  }
  var _def2 = _classPrivateFieldKey("def");
  var _entryIndex = _classPrivateFieldKey("entryIndex");
  var _indexes = _classPrivateFieldKey("indexes");
  var _isBasic = _classPrivateFieldKey("isBasic");
  var _isIndexed = _classPrivateFieldKey("isIndexed");
  var _raw$2 = _classPrivateFieldKey("raw");
  class Enum {
    constructor(registry, def, value, index) {
      this.registry = void 0;
      this.createdAtHash = void 0;
      Object.defineProperty(this, _def2, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _entryIndex, {
        writable: true,
        value: void 0
      });
      this.initialU8aLength = void 0;
      Object.defineProperty(this, _indexes, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _isBasic, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _isIndexed, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _raw$2, {
        writable: true,
        value: void 0
      });
      const defInfo = extractDef(registry, def);
      const decoded = decodeEnum(registry, defInfo.def, value, index);
      this.registry = registry;
      _classPrivateFieldBase(this, _def2)[_def2] = defInfo.def;
      _classPrivateFieldBase(this, _isBasic)[_isBasic] = defInfo.isBasic;
      _classPrivateFieldBase(this, _isIndexed)[_isIndexed] = defInfo.isIndexed;
      _classPrivateFieldBase(this, _indexes)[_indexes] = Object.values(defInfo.def).map(({
        index
      }) => index);
      _classPrivateFieldBase(this, _entryIndex)[_entryIndex] = _classPrivateFieldBase(this, _indexes)[_indexes].indexOf(decoded.index) || 0;
      _classPrivateFieldBase(this, _raw$2)[_raw$2] = decoded.value;
      if (_classPrivateFieldBase(this, _raw$2)[_raw$2].initialU8aLength) {
        this.initialU8aLength = 1 + _classPrivateFieldBase(this, _raw$2)[_raw$2].initialU8aLength;
      }
    }
    static with(Types) {
      const keys = Array.isArray(Types) ? Types : Object.keys(Types);
      const asKeys = new Array(keys.length);
      const isKeys = new Array(keys.length);
      for (let i = 0; i < keys.length; i++) {
        const name = stringUpperFirst(stringCamelCase(keys[i].replace(' ', '_')));
        asKeys[i] = `as${name}`;
        isKeys[i] = `is${name}`;
      }
      return class extends Enum {
        constructor(registry, value, index) {
          super(registry, Types, value, index);
          objectProperties(this, isKeys, (_, i) => this.type === keys[i]);
          objectProperties(this, asKeys, (k, i) => {
            assert$h(this[isKeys[i]], () => `Cannot convert '${this.type}' via ${k}`);
            return this.value;
          });
        }
      };
    }
    get encodedLength() {
      return 1 + _classPrivateFieldBase(this, _raw$2)[_raw$2].encodedLength;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get index() {
      return _classPrivateFieldBase(this, _indexes)[_indexes][_classPrivateFieldBase(this, _entryIndex)[_entryIndex]];
    }
    get isBasic() {
      return _classPrivateFieldBase(this, _isBasic)[_isBasic];
    }
    get isEmpty() {
      return _classPrivateFieldBase(this, _raw$2)[_raw$2].isEmpty;
    }
    get isNone() {
      return _classPrivateFieldBase(this, _raw$2)[_raw$2] instanceof Null;
    }
    get isNull() {
      return _classPrivateFieldBase(this, _raw$2)[_raw$2] instanceof Null;
    }
    get defIndexes() {
      return _classPrivateFieldBase(this, _indexes)[_indexes];
    }
    get defKeys() {
      return Object.keys(_classPrivateFieldBase(this, _def2)[_def2]);
    }
    get type() {
      return this.defKeys[_classPrivateFieldBase(this, _entryIndex)[_entryIndex]];
    }
    get value() {
      return _classPrivateFieldBase(this, _raw$2)[_raw$2];
    }
    eq(other) {
      if (isU8a$1(other)) {
        return !this.toU8a().some((entry, index) => entry !== other[index]);
      } else if (isNumber$1(other)) {
        return this.toNumber() === other;
      } else if (_classPrivateFieldBase(this, _isBasic)[_isBasic] && isString$1(other)) {
        return this.type === other;
      } else if (isHex$1(other)) {
        return this.toHex() === other;
      } else if (other instanceof Enum) {
        return this.index === other.index && this.value.eq(other.value);
      } else if (isObject(other)) {
        return this.value.eq(other[this.type]);
      }
      return this.value.eq(other);
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toHuman(isExtended) {
      return _classPrivateFieldBase(this, _isBasic)[_isBasic] || this.isNone ? this.type : {
        [this.type]: _classPrivateFieldBase(this, _raw$2)[_raw$2].toHuman(isExtended)
      };
    }
    toJSON() {
      return _classPrivateFieldBase(this, _isBasic)[_isBasic] ? this.type : {
        [stringCamelCase(this.type)]: _classPrivateFieldBase(this, _raw$2)[_raw$2].toJSON()
      };
    }
    toNumber() {
      return this.index;
    }
    _toRawStruct() {
      if (_classPrivateFieldBase(this, _isBasic)[_isBasic]) {
        return _classPrivateFieldBase(this, _isIndexed)[_isIndexed] ? this.defKeys.reduce((out, key, index) => {
          out[key] = _classPrivateFieldBase(this, _indexes)[_indexes][index];
          return out;
        }, {}) : this.defKeys;
      }
      const typeMap = Object.entries(_classPrivateFieldBase(this, _def2)[_def2]).reduce((out, [key, {
        Type
      }]) => {
        out[key] = Type;
        return out;
      }, {});
      return typesToMap(this.registry, typeMap);
    }
    toRawType() {
      return stringify({
        _enum: this._toRawStruct()
      });
    }
    toString() {
      return this.isNull ? this.type : stringify(this.toJSON());
    }
    toU8a(isBare) {
      return u8aConcat$1(new Uint8Array(isBare ? [] : [this.index]), _classPrivateFieldBase(this, _raw$2)[_raw$2].toU8a(isBare));
    }
  }

  function decodeStructFromObject(registry, Types, value, jsonMap) {
    let jsonObj;
    const inputKeys = Object.keys(Types);
    const typeofArray = Array.isArray(value);
    const typeofMap = value instanceof Map;
    assert$h(typeofArray || typeofMap || isObject(value), () => `Struct: Cannot decode value ${stringify(value)} (typeof ${typeof value}), expected an input object, map or array`);
    assert$h(!typeofArray || value.length === inputKeys.length, () => `Struct: Unable to map ${stringify(value)} array to object with known keys ${inputKeys.join(', ')}`);
    const raw = new Array(inputKeys.length);
    for (let i = 0; i < inputKeys.length; i++) {
      const key = inputKeys[i];
      const jsonKey = jsonMap.get(key) || key;
      const Type = Types[key];
      let assign;
      try {
        if (typeofArray) {
          assign = value[i];
        } else if (typeofMap) {
          assign = jsonKey && value.get(jsonKey);
        } else {
          assign = jsonKey && value[jsonKey];
          if (isUndefined(assign)) {
            if (isUndefined(jsonObj)) {
              const entries = Object.entries(value);
              jsonObj = {};
              for (let e = 0; e < entries.length; e++) {
                jsonObj[stringCamelCase(entries[e][0])] = entries[e][1];
              }
            }
            assign = jsonKey && jsonObj[jsonKey];
          }
        }
        raw[i] = [key, assign instanceof Type ? assign : new Type(registry, assign)];
      } catch (error) {
        let type = Type.name;
        try {
          type = new Type(registry).toRawType();
        } catch (error) {
        }
        throw new Error(`Struct: failed on ${jsonKey}: ${type}:: ${error.message}`);
      }
    }
    return raw;
  }
  function decodeZip(k, v) {
    return [k, v];
  }
  function decodeStruct(registry, Types, value, jsonMap) {
    if (isU8a$1(value)) {
      return decodeU8a$3(registry, value, Types, decodeZip);
    } else if (value instanceof Struct) {
      return [value, 0];
    } else if (isHex$1(value)) {
      return decodeStruct(registry, Types, hexToU8a$1(value), jsonMap);
    }
    return [decodeStructFromObject(registry, Types, value || {}, jsonMap), 0];
  }
  var _jsonMap = _classPrivateFieldKey("jsonMap");
  var _Types = _classPrivateFieldKey("Types");
  class Struct extends Map {
    constructor(registry, Types, value, jsonMap = new Map()) {
      const [decoded, decodedLength] = decodeStruct(registry, mapToTypeMap(registry, Types), value, jsonMap);
      super(decoded);
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.initialU8aLength = void 0;
      Object.defineProperty(this, _jsonMap, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _Types, {
        writable: true,
        value: void 0
      });
      this.registry = registry;
      this.initialU8aLength = decodedLength;
      _classPrivateFieldBase(this, _jsonMap)[_jsonMap] = jsonMap;
      _classPrivateFieldBase(this, _Types)[_Types] = mapToTypeMap(registry, Types);
    }
    static with(Types, jsonMap) {
      const keys = Object.keys(Types);
      return class extends Struct {
        constructor(registry, value) {
          super(registry, Types, value, jsonMap);
          objectProperties(this, keys, k => this.get(k));
        }
      };
    }
    get defKeys() {
      return Object.keys(_classPrivateFieldBase(this, _Types)[_Types]);
    }
    get isEmpty() {
      for (const v of this.values()) {
        if (!v.isEmpty) {
          return false;
        }
      }
      return true;
    }
    get Type() {
      const result = {};
      const defs = Object.entries(_classPrivateFieldBase(this, _Types)[_Types]);
      for (let i = 0; i < defs.length; i++) {
        const [key, Type] = defs[i];
        result[key] = new Type(this.registry).toRawType();
      }
      return result;
    }
    get encodedLength() {
      let total = 0;
      for (const v of this.values()) {
        total += v.encodedLength;
      }
      return total;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    eq(other) {
      return compareMap(this, other);
    }
    get(name) {
      return super.get(name);
    }
    getAtIndex(index) {
      return this.toArray()[index];
    }
    toArray() {
      return [...this.values()];
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toHuman(isExtended) {
      const json = {};
      for (const [k, v] of this.entries()) {
        json[k] = v && v.toHuman(isExtended);
      }
      return json;
    }
    toJSON() {
      const json = {};
      for (const [k, v] of this.entries()) {
        const jsonKey = _classPrivateFieldBase(this, _jsonMap)[_jsonMap].get(k) || k;
        json[jsonKey] = v && v.toJSON();
      }
      return json;
    }
    toRawType() {
      return stringify(typesToMap(this.registry, _classPrivateFieldBase(this, _Types)[_Types]));
    }
    toString() {
      return stringify(this.toJSON());
    }
    toU8a(isBare) {
      const encoded = [];
      for (const [k, v] of this.entries()) {
        if (v && isFunction$1(v.toU8a)) {
          encoded.push(v.toU8a(!isBare || isBoolean$1(isBare) ? isBare : isBare[k]));
        }
      }
      return u8aConcat$1(...encoded);
    }
  }

  const l$4 = logger('Map');
  function decodeMapFromU8a(registry, KeyClass, ValClass, u8a) {
    const output = new Map();
    const [offset, length] = compactFromU8a(u8a);
    const count = length.toNumber();
    const types = [];
    for (let i = 0; i < count; i++) {
      types.push(KeyClass, ValClass);
    }
    const [values, decodedLength] = decodeU8a$3(registry, u8a.subarray(offset), types);
    for (let i = 0; i < values.length; i += 2) {
      output.set(values[i], values[i + 1]);
    }
    return [output, offset + decodedLength];
  }
  function decodeMapFromMap(registry, KeyClass, ValClass, value) {
    const output = new Map();
    for (const [key, val] of value.entries()) {
      const isComplex = KeyClass.prototype instanceof AbstractArray || KeyClass.prototype instanceof Struct || KeyClass.prototype instanceof Enum;
      try {
        output.set(key instanceof KeyClass ? key : new KeyClass(registry, isComplex ? JSON.parse(key) : key), val instanceof ValClass ? val : new ValClass(registry, val));
      } catch (error) {
        l$4.error('Failed to decode key or value:', error.message);
        throw error;
      }
    }
    return [output, 0];
  }
  function decodeMap(registry, keyType, valType, value) {
    const KeyClass = typeToConstructor(registry, keyType);
    const ValClass = typeToConstructor(registry, valType);
    if (!value) {
      return [new Map(), 0];
    } else if (isU8a$1(value) || isHex$1(value)) {
      return decodeMapFromU8a(registry, KeyClass, ValClass, u8aToU8a$1(value));
    } else if (value instanceof Map) {
      return decodeMapFromMap(registry, KeyClass, ValClass, value);
    } else if (isObject(value)) {
      return decodeMapFromMap(registry, KeyClass, ValClass, new Map(Object.entries(value)));
    }
    throw new Error('Map: cannot decode type');
  }
  var _KeyClass = _classPrivateFieldKey("KeyClass");
  var _ValClass$1 = _classPrivateFieldKey("ValClass");
  var _type = _classPrivateFieldKey("type");
  class CodecMap extends Map {
    constructor(registry, keyType, valType, rawValue, type = 'HashMap') {
      const [decoded, decodedLength] = decodeMap(registry, keyType, valType, rawValue);
      super(type === 'BTreeMap' ? sortMap(decoded) : decoded);
      this.registry = void 0;
      this.createdAtHash = void 0;
      Object.defineProperty(this, _KeyClass, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _ValClass$1, {
        writable: true,
        value: void 0
      });
      this.initialU8aLength = void 0;
      Object.defineProperty(this, _type, {
        writable: true,
        value: void 0
      });
      this.registry = registry;
      this.initialU8aLength = decodedLength;
      _classPrivateFieldBase(this, _KeyClass)[_KeyClass] = typeToConstructor(registry, keyType);
      _classPrivateFieldBase(this, _ValClass$1)[_ValClass$1] = typeToConstructor(registry, valType);
      _classPrivateFieldBase(this, _type)[_type] = type;
    }
    get encodedLength() {
      let len = compactToU8a(this.size).length;
      for (const [k, v] of this.entries()) {
        len += v.encodedLength + k.encodedLength;
      }
      return len;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this.size === 0;
    }
    eq(other) {
      return compareMap(this, other);
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toHuman(isExtended) {
      const json = {};
      for (const [k, v] of this.entries()) {
        json[k.toString()] = v.toHuman(isExtended);
      }
      return json;
    }
    toJSON() {
      const json = {};
      for (const [k, v] of this.entries()) {
        json[k.toString()] = v.toJSON();
      }
      return json;
    }
    toRawType() {
      return `${_classPrivateFieldBase(this, _type)[_type]}<${this.registry.getClassName(_classPrivateFieldBase(this, _KeyClass)[_KeyClass]) || new (_classPrivateFieldBase(this, _KeyClass)[_KeyClass])(this.registry).toRawType()},${this.registry.getClassName(_classPrivateFieldBase(this, _ValClass$1)[_ValClass$1]) || new (_classPrivateFieldBase(this, _ValClass$1)[_ValClass$1])(this.registry).toRawType()}>`;
    }
    toString() {
      return stringify(this.toJSON());
    }
    toU8a(isBare) {
      const encoded = new Array();
      if (!isBare) {
        encoded.push(compactToU8a(this.size));
      }
      for (const [k, v] of this.entries()) {
        encoded.push(k.toU8a(isBare), v.toU8a(isBare));
      }
      return u8aConcat$1(...encoded);
    }
  }

  class BTreeMap extends CodecMap {
    static with(keyType, valType) {
      return class extends BTreeMap {
        constructor(registry, value) {
          super(registry, keyType, valType, value, 'BTreeMap');
        }
      };
    }
  }

  const l$3 = logger('BTreeSet');
  function decodeSetFromU8a(registry, ValClass, u8a) {
    const output = new Set();
    const [offset, length] = compactFromU8a(u8a);
    const [values, decodedLength] = decodeU8a$3(registry, u8a.subarray(offset), new Array(length.toNumber()).fill(ValClass));
    for (let i = 0; i < values.length; i++) {
      output.add(values[i]);
    }
    return [output, decodedLength + offset];
  }
  function decodeSetFromSet(registry, ValClass, value) {
    const output = new Set();
    value.forEach(val => {
      try {
        output.add(val instanceof ValClass ? val : new ValClass(registry, val));
      } catch (error) {
        l$3.error('Failed to decode key or value:', error.message);
        throw error;
      }
    });
    return [output, 0];
  }
  function decodeSet$1(registry, valType, value) {
    if (!value) {
      return [new Set(), 0];
    }
    const ValClass = typeToConstructor(registry, valType);
    if (isU8a$1(value) || isHex$1(value)) {
      return decodeSetFromU8a(registry, ValClass, u8aToU8a$1(value));
    } else if (Array.isArray(value) || value instanceof Set) {
      return decodeSetFromSet(registry, ValClass, value);
    }
    throw new Error('BTreeSet: cannot decode type');
  }
  var _ValClass = _classPrivateFieldKey("ValClass");
  class BTreeSet extends Set {
    constructor(registry, valType, rawValue) {
      const [values, decodedLength] = decodeSet$1(registry, valType, rawValue);
      super(sortSet(values));
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.initialU8aLength = void 0;
      Object.defineProperty(this, _ValClass, {
        writable: true,
        value: void 0
      });
      this.registry = registry;
      this.initialU8aLength = decodedLength;
      _classPrivateFieldBase(this, _ValClass)[_ValClass] = typeToConstructor(registry, valType);
    }
    static with(valType) {
      return class extends BTreeSet {
        constructor(registry, value) {
          super(registry, valType, value);
        }
      };
    }
    get encodedLength() {
      let len = compactToU8a(this.size).length;
      for (const v of this.values()) {
        len += v.encodedLength;
      }
      return len;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this.size === 0;
    }
    get strings() {
      return [...super.values()].map(v => v.toString());
    }
    eq(other) {
      return compareSet(this, other);
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toHuman(isExtended) {
      const json = [];
      for (const v of this.values()) {
        json.push(v.toHuman(isExtended));
      }
      return json;
    }
    toJSON() {
      const json = [];
      for (const v of this.values()) {
        json.push(v.toJSON());
      }
      return json;
    }
    toRawType() {
      return `BTreeSet<${this.registry.getClassName(_classPrivateFieldBase(this, _ValClass)[_ValClass]) || new (_classPrivateFieldBase(this, _ValClass)[_ValClass])(this.registry).toRawType()}>`;
    }
    toString() {
      return stringify(this.toJSON());
    }
    toU8a(isBare) {
      const encoded = new Array();
      if (!isBare) {
        encoded.push(compactToU8a(this.size));
      }
      for (const v of this.values()) {
        encoded.push(v.toU8a(isBare));
      }
      return u8aConcat$1(...encoded);
    }
  }

  var _Type$3 = _classPrivateFieldKey("Type");
  var _raw$1 = _classPrivateFieldKey("raw");
  class Compact {
    constructor(registry, Type, value = 0) {
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.initialU8aLength = void 0;
      Object.defineProperty(this, _Type$3, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _raw$1, {
        writable: true,
        value: void 0
      });
      this.registry = registry;
      _classPrivateFieldBase(this, _Type$3)[_Type$3] = typeToConstructor(registry, Type);
      const [raw, decodedLength] = Compact.decodeCompact(registry, _classPrivateFieldBase(this, _Type$3)[_Type$3], value);
      this.initialU8aLength = decodedLength;
      _classPrivateFieldBase(this, _raw$1)[_raw$1] = raw;
    }
    static with(Type) {
      return class extends Compact {
        constructor(registry, value) {
          super(registry, Type, value);
        }
      };
    }
    static decodeCompact(registry, Type, value) {
      if (value instanceof Compact) {
        return [new Type(registry, _classPrivateFieldBase(value, _raw$1)[_raw$1]), 0];
      } else if (value instanceof Type) {
        return [value, 0];
      } else if (isString$1(value) || isNumber$1(value) || isBn(value) || isBigInt$1(value)) {
        return [new Type(registry, value), 0];
      }
      const [decodedLength, bn] = compactFromU8a(value);
      return [new Type(registry, bn), decodedLength];
    }
    get encodedLength() {
      return this.toU8a().length;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].isEmpty;
    }
    bitLength() {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].bitLength();
    }
    eq(other) {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].eq(other instanceof Compact ? _classPrivateFieldBase(other, _raw$1)[_raw$1] : other);
    }
    toBigInt() {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].toBigInt();
    }
    toBn() {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].toBn();
    }
    toHex(isLe) {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].toHex(isLe);
    }
    toHuman(isExtended) {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].toHuman(isExtended);
    }
    toJSON() {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].toJSON();
    }
    toNumber() {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].toNumber();
    }
    toRawType() {
      return `Compact<${this.registry.getClassName(_classPrivateFieldBase(this, _Type$3)[_Type$3]) || _classPrivateFieldBase(this, _raw$1)[_raw$1].toRawType()}>`;
    }
    toString() {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1].toString();
    }
    toU8a(isBare) {
      return compactToU8a(_classPrivateFieldBase(this, _raw$1)[_raw$1].toBn());
    }
    unwrap() {
      return _classPrivateFieldBase(this, _raw$1)[_raw$1];
    }
  }

  var _neverError = _classPrivateFieldKey("neverError");
  class DoNotConstruct {
    constructor(registry, typeName = 'DoNotConstruct') {
      this.registry = void 0;
      this.createdAtHash = void 0;
      Object.defineProperty(this, _neverError, {
        writable: true,
        value: void 0
      });
      this.registry = registry;
      _classPrivateFieldBase(this, _neverError)[_neverError] = new Error(`DoNotConstruct: Cannot construct unknown type ${typeName}`);
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    static with(typeName) {
      return class extends DoNotConstruct {
        constructor(registry) {
          super(registry, typeName);
        }
      };
    }
    get encodedLength() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    get hash() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    get isEmpty() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    eq() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    toHex() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    toHuman() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    toJSON() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    toRawType() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    toString() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
    toU8a() {
      throw _classPrivateFieldBase(this, _neverError)[_neverError];
    }
  }

  class HashMap extends CodecMap {
    static with(keyType, valType) {
      return class extends HashMap {
        constructor(registry, value) {
          super(registry, keyType, valType, value);
        }
      };
    }
  }

  const DEFAULT_UINT_BITS = 64;
  const MAX_NUMBER_BITS = 52;
  const MUL_P = new BN$8(10000);
  const FORMATTERS = [['Perquintill', BN_QUINTILL], ['Perbill', BN_BILLION], ['Permill', BN_MILLION], ['Percent', BN_HUNDRED]];
  function toPercentage(value, divisor) {
    return `${(value.mul(MUL_P).div(divisor).toNumber() / 100).toFixed(2)}%`;
  }
  function decodeAbstractInt(value, bitLength, isNegative) {
    if (isU8a$1(value)) {
      if (!value.length) {
        return '0';
      }
      try {
        return u8aToBn(value.subarray(0, bitLength / 8), {
          isLe: true,
          isNegative
        }).toString();
      } catch (error) {
        throw new Error(`AbstractInt: failed on ${stringify(value)}:: ${error.message}`);
      }
    } else if (isBn(value)) {
      return value.toString();
    } else if (isHex$1(value, -1, true)) {
      return hexToBn$1(value, {
        isLe: false,
        isNegative
      }).toString();
    }
    return bnToBn$1(value).toString();
  }
  var _bitLength = _classPrivateFieldKey("bitLength");
  var _isSigned = _classPrivateFieldKey("isSigned");
  class AbstractInt extends BN$8 {
    constructor(registry, value = 0, bitLength = DEFAULT_UINT_BITS, isSigned = false) {
      super(decodeAbstractInt(value, bitLength, isSigned));
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.encodedLength = void 0;
      Object.defineProperty(this, _bitLength, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _isSigned, {
        writable: true,
        value: void 0
      });
      this.registry = registry;
      _classPrivateFieldBase(this, _bitLength)[_bitLength] = bitLength;
      this.encodedLength = _classPrivateFieldBase(this, _bitLength)[_bitLength] / 8;
      _classPrivateFieldBase(this, _isSigned)[_isSigned] = isSigned;
      const isPositive = this.gte(BN_ZERO);
      const maxBits = bitLength - (isSigned && isPositive ? 1 : 0);
      assert$h(isSigned || isPositive, () => `${this.toRawType()}: Negative number passed to unsigned type`);
      assert$h(super.bitLength() <= maxBits, () => `${this.toRawType()}: Input too large. Found input with ${super.bitLength()} bits, expected ${maxBits}`);
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this.isZero();
    }
    get isUnsigned() {
      return !_classPrivateFieldBase(this, _isSigned)[_isSigned];
    }
    bitLength() {
      return _classPrivateFieldBase(this, _bitLength)[_bitLength];
    }
    eq(other) {
      return super.eq(isHex$1(other) ? hexToBn$1(other.toString(), {
        isLe: false,
        isNegative: _classPrivateFieldBase(this, _isSigned)[_isSigned]
      }) : bnToBn$1(other));
    }
    isMax() {
      const u8a = this.toU8a().filter(b => b === 0xff);
      return u8a.length === _classPrivateFieldBase(this, _bitLength)[_bitLength] / 8;
    }
    toBigInt() {
      return BigInt(this.toString());
    }
    toBn() {
      return this;
    }
    toHex(isLe = false) {
      return bnToHex(this, {
        bitLength: this.bitLength(),
        isLe,
        isNegative: !this.isUnsigned
      });
    }
    toHuman(isExpanded) {
      const rawType = this.toRawType();
      if (rawType === 'Balance') {
        return this.isMax() ? 'everything'
        : formatBalance(this, {
          decimals: this.registry.chainDecimals[0],
          withSi: true,
          withUnit: this.registry.chainTokens[0]
        });
      }
      const [, divisor] = FORMATTERS.find(([type]) => type === rawType) || [];
      return divisor ? toPercentage(this, divisor) : formatNumber(this);
    }
    toJSON(onlyHex = false) {
      return onlyHex || super.bitLength() > MAX_NUMBER_BITS ? this.toHex() : this.toNumber();
    }
    toRawType() {
      return this instanceof this.registry.createClass('Balance') ? 'Balance' : `${this.isUnsigned ? 'u' : 'i'}${this.bitLength()}`;
    }
    toString(base) {
      return super.toString(base);
    }
    toU8a(isBare) {
      return bnToU8a$1(this, {
        bitLength: this.bitLength(),
        isLe: true,
        isNegative: !this.isUnsigned
      });
    }
  }

  class Int extends AbstractInt {
    constructor(registry, value = 0, bitLength) {
      super(registry, value, bitLength, true);
    }
    static with(bitLength, typeName) {
      return class extends Int {
        constructor(registry, value) {
          super(registry, value, bitLength);
        }
        toRawType() {
          return typeName || super.toRawType();
        }
      };
    }
  }

  function decodeJson(value) {
    return Object.entries(value || {});
  }
  class Json extends Map {
    constructor(registry, value) {
      const decoded = decodeJson(value);
      super(decoded);
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.registry = registry;
      objectProperties(this, decoded.map(([k]) => k), k => this.get(k));
    }
    get encodedLength() {
      return 0;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return [...this.keys()].length === 0;
    }
    eq(other) {
      return compareMap(this, other);
    }
    toHex() {
      throw new Error('Unimplemented');
    }
    toHuman() {
      return [...this.entries()].reduce((json, [key, value]) => {
        json[key] = isFunction$1(value.toHuman) ? value.toHuman() : value;
        return json;
      }, {});
    }
    toJSON() {
      return [...this.entries()].reduce((json, [key, value]) => {
        json[key] = value;
        return json;
      }, {});
    }
    toRawType() {
      return 'Json';
    }
    toString() {
      return stringify(this.toJSON());
    }
    toU8a(isBare) {
      throw new Error('Unimplemented');
    }
  }

  function decodeOption(registry, typeName, value) {
    if (isNull(value) || isUndefined(value) || value instanceof Null || value === '0x') {
      return new Null(registry);
    }
    const Type = typeToConstructor(registry, typeName);
    if (value instanceof Option) {
      return decodeOption(registry, Type, value.value);
    } else if (value instanceof Type) {
      return value;
    } else if (isU8a$1(value)) {
      return !value.length || value[0] === 0 ? new Null(registry) : new Type(registry, value.subarray(1));
    }
    return new Type(registry, value);
  }
  var _Type$2 = _classPrivateFieldKey("Type");
  var _initialU8aLength$1 = _classPrivateFieldKey("initialU8aLength");
  var _raw = _classPrivateFieldKey("raw");
  class Option {
    constructor(registry, typeName, value) {
      this.registry = void 0;
      this.createdAtHash = void 0;
      Object.defineProperty(this, _Type$2, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _initialU8aLength$1, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _raw, {
        writable: true,
        value: void 0
      });
      this.registry = registry;
      _classPrivateFieldBase(this, _Type$2)[_Type$2] = typeToConstructor(registry, typeName);
      _classPrivateFieldBase(this, _raw)[_raw] = decodeOption(registry, typeName, value);
      if (_classPrivateFieldBase(this, _raw)[_raw].initialU8aLength) {
        _classPrivateFieldBase(this, _initialU8aLength$1)[_initialU8aLength$1] = 1 + _classPrivateFieldBase(this, _raw)[_raw].initialU8aLength;
      }
    }
    static with(Type) {
      return class extends Option {
        constructor(registry, value) {
          super(registry, Type, value);
        }
      };
    }
    get encodedLength() {
      return 1 + _classPrivateFieldBase(this, _raw)[_raw].encodedLength;
    }
    get initialU8aLength() {
      return _classPrivateFieldBase(this, _initialU8aLength$1)[_initialU8aLength$1];
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this.isNone;
    }
    get isNone() {
      return _classPrivateFieldBase(this, _raw)[_raw] instanceof Null;
    }
    get isSome() {
      return !this.isNone;
    }
    get value() {
      return _classPrivateFieldBase(this, _raw)[_raw];
    }
    eq(other) {
      if (other instanceof Option) {
        return this.isSome === other.isSome && this.value.eq(other.value);
      }
      return this.value.eq(other);
    }
    toHex() {
      return this.isNone ? '0x' : u8aToHex$1(this.toU8a().subarray(1));
    }
    toHuman(isExtended) {
      return _classPrivateFieldBase(this, _raw)[_raw].toHuman(isExtended);
    }
    toJSON() {
      return _classPrivateFieldBase(this, _raw)[_raw].toJSON();
    }
    toRawType(isBare) {
      const wrapped = this.registry.getClassName(_classPrivateFieldBase(this, _Type$2)[_Type$2]) || new (_classPrivateFieldBase(this, _Type$2)[_Type$2])(this.registry).toRawType();
      return isBare ? wrapped : `Option<${wrapped}>`;
    }
    toString() {
      return _classPrivateFieldBase(this, _raw)[_raw].toString();
    }
    toU8a(isBare) {
      if (isBare) {
        return _classPrivateFieldBase(this, _raw)[_raw].toU8a(true);
      }
      const u8a = new Uint8Array(this.encodedLength);
      if (this.isSome) {
        u8a.set([1]);
        u8a.set(_classPrivateFieldBase(this, _raw)[_raw].toU8a(), 1);
      }
      return u8a;
    }
    unwrap() {
      assert$h(this.isSome, 'Option: unwrapping a None value');
      return _classPrivateFieldBase(this, _raw)[_raw];
    }
    unwrapOr(defaultValue) {
      return this.isSome ? this.unwrap() : defaultValue;
    }
    unwrapOrDefault() {
      return this.isSome ? this.unwrap() : new (_classPrivateFieldBase(this, _Type$2)[_Type$2])(this.registry);
    }
  }

  function decodeTuple(registry, _Types, value) {
    if (isU8a$1(value) || isHex$1(value)) {
      return decodeU8a$3(registry, u8aToU8a$1(value), _Types);
    }
    const Types = Array.isArray(_Types) ? _Types : Object.values(_Types);
    return [Types.map((Type, index) => {
      try {
        const entry = value === null || value === void 0 ? void 0 : value[index];
        if (entry instanceof Type) {
          return entry;
        }
        return new Type(registry, entry);
      } catch (error) {
        throw new Error(`Tuple: failed on ${index}:: ${error.message}`);
      }
    }), 0];
  }
  var _Types2 = _classPrivateFieldKey("Types");
  class Tuple extends AbstractArray {
    constructor(registry, Types, value) {
      const Clazzes = Array.isArray(Types) ? Types.map(t => typeToConstructor(registry, t)) : isFunction$1(Types) || isString$1(Types) ? [typeToConstructor(registry, Types)] : mapToTypeMap(registry, Types);
      const [values, decodedLength] = decodeTuple(registry, Clazzes, value);
      super(registry, values, decodedLength);
      Object.defineProperty(this, _Types2, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldBase(this, _Types2)[_Types2] = Clazzes;
    }
    static with(Types) {
      return class extends Tuple {
        constructor(registry, value) {
          super(registry, Types, value);
        }
      };
    }
    get encodedLength() {
      let total = 0;
      for (let i = 0; i < this.length; i++) {
        total += this[i].encodedLength;
      }
      return total;
    }
    get Types() {
      return Array.isArray(_classPrivateFieldBase(this, _Types2)[_Types2]) ? _classPrivateFieldBase(this, _Types2)[_Types2].map(T => new T(this.registry).toRawType()) : Object.keys(_classPrivateFieldBase(this, _Types2)[_Types2]);
    }
    toRawType() {
      const types = (Array.isArray(_classPrivateFieldBase(this, _Types2)[_Types2]) ? _classPrivateFieldBase(this, _Types2)[_Types2] : Object.values(_classPrivateFieldBase(this, _Types2)[_Types2])).map(T => this.registry.getClassName(T) || new T(this.registry).toRawType());
      return `(${types.join(',')})`;
    }
    toString() {
      return stringify(this.toJSON());
    }
    toU8a(isBare) {
      const encoded = new Array(this.length);
      for (let i = 0; i < this.length; i++) {
        encoded[i] = this[i].toU8a(isBare);
      }
      return u8aConcat$1(...encoded);
    }
  }

  const MAX_LENGTH$2 = 64 * 1024;
  const l$2 = logger('Vec');
  function decodeVec(registry, Type, value, length = -1) {
    if (Array.isArray(value)) {
      const result = new Array(value.length);
      for (let i = 0; i < value.length; i++) {
        const entry = value[i];
        try {
          result[i] = entry instanceof Type ? entry : new Type(registry, entry);
        } catch (error) {
          l$2.error(`Unable to decode on index ${i}`, error.message);
          throw error;
        }
      }
      return [result, 0, 0];
    }
    const u8a = u8aToU8a$1(value);
    let offset = 0;
    if (length === -1) {
      const [_offset, _length] = compactFromU8a(u8a);
      assert$h(_length.lten(MAX_LENGTH$2), () => `Vec length ${_length.toString()} exceeds ${MAX_LENGTH$2}`);
      length = _length.toNumber();
      offset = _offset;
    }
    return decodeU8aVec(registry, u8a, offset, Type, length);
  }
  var _Type$1 = _classPrivateFieldKey("Type");
  class Vec extends AbstractArray {
    constructor(registry, Type, value = []) {
      const Clazz = typeToConstructor(registry, Type);
      const [values, decodedLength] = decodeVec(registry, Clazz, value);
      super(registry, values, decodedLength);
      Object.defineProperty(this, _Type$1, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldBase(this, _Type$1)[_Type$1] = Clazz;
    }
    static with(Type) {
      return class extends Vec {
        constructor(registry, value) {
          super(registry, Type, value);
        }
      };
    }
    get Type() {
      return _classPrivateFieldBase(this, _Type$1)[_Type$1].name;
    }
    indexOf(_other) {
      const other = _other instanceof _classPrivateFieldBase(this, _Type$1)[_Type$1] ? _other : new (_classPrivateFieldBase(this, _Type$1)[_Type$1])(this.registry, _other);
      for (let i = 0; i < this.length; i++) {
        if (other.eq(this[i])) {
          return i;
        }
      }
      return -1;
    }
    toRawType() {
      return `Vec<${this.registry.getClassName(_classPrivateFieldBase(this, _Type$1)[_Type$1]) || new (_classPrivateFieldBase(this, _Type$1)[_Type$1])(this.registry).toRawType()}>`;
    }
  }

  const EMPTY = new Uint8Array();
  class Linkage extends Struct {
    constructor(registry, Type, value) {
      super(registry, {
        previous: Option.with(Type),
        next: Option.with(Type)
      }, value);
    }
    static withKey(Type) {
      return class extends Linkage {
        constructor(registry, value) {
          super(registry, Type, value);
        }
      };
    }
    get previous() {
      return this.get('previous');
    }
    get next() {
      return this.get('next');
    }
    toRawType() {
      return `Linkage<${this.next.toRawType(true)}>`;
    }
    toU8a() {
      return this.isEmpty ? EMPTY : super.toU8a();
    }
  }

  var _rangeName = _classPrivateFieldKey("rangeName");
  class Range extends Tuple {
    constructor(registry, Type, value, rangeName = 'Range') {
      super(registry, {
        end: Type,
        start: Type
      }, value);
      Object.defineProperty(this, _rangeName, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldBase(this, _rangeName)[_rangeName] = rangeName;
    }
    static with(Types) {
      return class extends Range {
        constructor(registry, value) {
          super(registry, Types, value);
        }
      };
    }
    get start() {
      return this[0];
    }
    get end() {
      return this[1];
    }
    toRawType() {
      return `${_classPrivateFieldBase(this, _rangeName)[_rangeName]}<${this.start.toRawType()}>`;
    }
  }
  class RangeInclusive extends Range {
    constructor(registry, type, value) {
      super(registry, type, value, 'RangeInclusive');
    }
    static with(Types) {
      return class extends RangeInclusive {
        constructor(registry, value) {
          super(registry, Types, value);
        }
      };
    }
  }

  class Raw extends Uint8Array {
    constructor(registry, value, initialU8aLength) {
      super(u8aToU8a$1(value));
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.initialU8aLength = void 0;
      this.registry = registry;
      this.initialU8aLength = initialU8aLength;
    }
    get encodedLength() {
      return this.length;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isAscii() {
      return isAscii(this);
    }
    get isEmpty() {
      return !this.length || isUndefined(this.find(b => !!b));
    }
    get isUtf8() {
      return isUtf8(this);
    }
    get length() {
      return super.length;
    }
    bitLength() {
      return this.length * 8;
    }
    eq(other) {
      if (other instanceof Uint8Array) {
        return this.length === other.length && !this.some((b, index) => b !== other[index]);
      }
      return this.eq(u8aToU8a$1(other));
    }
    slice(start, end) {
      return Uint8Array.from(this).slice(start, end);
    }
    subarray(begin, end) {
      return Uint8Array.from(this).subarray(begin, end);
    }
    toHex() {
      return u8aToHex$1(this);
    }
    toHuman() {
      if (this.isAscii) {
        const text = this.toUtf8();
        if (isAscii(text)) {
          return text;
        }
      }
      return this.toJSON();
    }
    toJSON() {
      return this.toHex();
    }
    toRawType() {
      return 'Raw';
    }
    toString() {
      return this.toHex();
    }
    toU8a(isBare) {
      return Uint8Array.from(this);
    }
    toUtf8() {
      assert$h(this.isUtf8, 'The character sequence is not a valid Utf8 string');
      return u8aToString$1(this);
    }
  }

  class Result extends Enum {
    constructor(registry, Ok, Err, value) {
      super(registry, {
        Ok,
        Err
      }, value);
    }
    static with(Types) {
      return class extends Result {
        constructor(registry, value) {
          super(registry, Types.Ok, Types.Err, value);
        }
      };
    }
    get asErr() {
      assert$h(this.isErr, 'Cannot extract Err value from Ok result, check isErr first');
      return this.value;
    }
    get asError() {
      return this.asErr;
    }
    get asOk() {
      assert$h(this.isOk, 'Cannot extract Ok value from Err result, check isOk first');
      return this.value;
    }
    get isEmpty() {
      return this.isOk && this.value.isEmpty;
    }
    get isErr() {
      return !this.isOk;
    }
    get isError() {
      return this.isErr;
    }
    get isOk() {
      return this.index === 0;
    }
    toRawType() {
      const Types = this._toRawStruct();
      return `Result<${Types.Ok},${Types.Err}>`;
    }
  }

  function encodeSet(setValues, values) {
    const encoded = new BN$8(0);
    for (let i = 0; i < values.length; i++) {
      encoded.ior(bnToBn$1(setValues[values[i]] || 0));
    }
    return encoded;
  }
  function decodeSetArray(setValues, values) {
    const result = new Array(values.length);
    for (let i = 0; i < values.length; i++) {
      const key = values[i];
      assert$h(!isUndefined(setValues[key]), () => `Set: Invalid key '${key}' passed to Set, allowed ${Object.keys(setValues).join(', ')}`);
      result[i] = key;
    }
    return result;
  }
  function decodeSetNumber(setValues, _value) {
    const bn = bnToBn$1(_value);
    const keys = Object.keys(setValues);
    const result = [];
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (bn.and(bnToBn$1(setValues[key])).eq(bnToBn$1(setValues[key]))) {
        result.push(key);
      }
    }
    const computed = encodeSet(setValues, result);
    assert$h(bn.eq(computed), () => `Set: Mismatch decoding '${bn.toString()}', computed as '${computed.toString()}' with ${result.join(', ')}`);
    return result;
  }
  function decodeSet(setValues, value = 0, bitLength) {
    assert$h(bitLength % 8 === 0, () => `Expected valid bitLength, power of 8, found ${bitLength}`);
    const byteLength = bitLength / 8;
    if (isU8a$1(value)) {
      return value.length === 0 ? [] : decodeSetNumber(setValues, u8aToBn(value.subarray(0, byteLength), {
        isLe: true
      }));
    } else if (isString$1(value)) {
      return decodeSet(setValues, u8aToU8a$1(value), byteLength);
    } else if (value instanceof Set || Array.isArray(value)) {
      const input = Array.isArray(value) ? value : [...value.values()];
      return decodeSetArray(setValues, input);
    }
    return decodeSetNumber(setValues, value);
  }
  var _allowed = _classPrivateFieldKey("allowed");
  var _byteLength = _classPrivateFieldKey("byteLength");
  class CodecSet extends Set {
    constructor(registry, setValues, value, bitLength = 8) {
      super(decodeSet(setValues, value, bitLength));
      this.registry = void 0;
      this.createdAtHash = void 0;
      Object.defineProperty(this, _allowed, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _byteLength, {
        writable: true,
        value: void 0
      });
      this.add = key => {
        assert$h(isUndefined(_classPrivateFieldBase(this, _allowed)[_allowed]) || !isUndefined(_classPrivateFieldBase(this, _allowed)[_allowed][key]), () => `Set: Invalid key '${key}' on add`);
        super.add(key);
        return this;
      };
      this.registry = registry;
      _classPrivateFieldBase(this, _allowed)[_allowed] = setValues;
      _classPrivateFieldBase(this, _byteLength)[_byteLength] = bitLength / 8;
    }
    static with(values, bitLength) {
      const keys = Object.keys(values);
      const isKeys = new Array(keys.length);
      for (let i = 0; i < keys.length; i++) {
        isKeys[i] = `is${stringUpperFirst(stringCamelCase(keys[i]))}`;
      }
      return class extends CodecSet {
        constructor(registry, value) {
          super(registry, values, value, bitLength);
          objectProperties(this, isKeys, (_, i) => this.strings.includes(keys[i]));
        }
      };
    }
    get encodedLength() {
      return _classPrivateFieldBase(this, _byteLength)[_byteLength];
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this.size === 0;
    }
    get strings() {
      return [...super.values()];
    }
    get valueEncoded() {
      return encodeSet(_classPrivateFieldBase(this, _allowed)[_allowed], this.strings);
    }
    eq(other) {
      if (Array.isArray(other)) {
        return compareArray(this.strings.sort(), other.sort());
      } else if (other instanceof Set) {
        return this.eq([...other.values()]);
      } else if (isNumber$1(other) || isBn(other)) {
        return this.valueEncoded.eq(bnToBn$1(other));
      }
      return false;
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toHuman() {
      return this.toJSON();
    }
    toJSON() {
      return this.strings;
    }
    toNumber() {
      return this.valueEncoded.toNumber();
    }
    toRawType() {
      return stringify({
        _set: _classPrivateFieldBase(this, _allowed)[_allowed]
      });
    }
    toString() {
      return `[${this.strings.join(', ')}]`;
    }
    toU8a(isBare) {
      return bnToU8a$1(this.valueEncoded, {
        bitLength: _classPrivateFieldBase(this, _byteLength)[_byteLength] * 8,
        isLe: true
      });
    }
  }

  class UInt extends AbstractInt {
    static with(bitLength, typeName) {
      return class extends UInt {
        constructor(registry, value) {
          super(registry, value, bitLength);
        }
        toRawType() {
          return typeName || super.toRawType();
        }
      };
    }
  }

  function decodeU8aFixed(value, bitLength) {
    if (isU8a$1(value)) {
      const byteLength = bitLength / 8;
      if (!value || !value.length) {
        return [new Uint8Array(byteLength), 0];
      }
      assert$h(value.length >= byteLength, () => `Expected at least ${byteLength} bytes (${bitLength} bits), found ${value.length} bytes`);
      return [value.subarray(0, byteLength), byteLength];
    }
    return decodeU8aFixed(u8aToU8a$1(value), bitLength);
  }
  class U8aFixed extends Raw {
    constructor(registry, value = new Uint8Array(), bitLength = 256) {
      const [u8a, decodedLength] = decodeU8aFixed(value, bitLength);
      super(registry, u8a, decodedLength);
    }
    static with(bitLength, typeName) {
      return class extends U8aFixed {
        constructor(registry, value) {
          super(registry, value, bitLength);
        }
        toRawType() {
          return typeName || super.toRawType();
        }
      };
    }
    toRawType() {
      return `[u8;${this.length}]`;
    }
  }

  function decodeVecFixed(registry, Type, length, value) {
    const [values,, decodedLengthNoOffset] = decodeVec(registry, Type, value, length);
    while (values.length < length) {
      values.push(new Type(registry));
    }
    assert$h(values.length === length, () => `Expected a length of exactly ${length} entries`);
    return [values, decodedLengthNoOffset];
  }
  var _Type = _classPrivateFieldKey("Type");
  class VecFixed extends AbstractArray {
    constructor(registry, Type, length, value = []) {
      const Clazz = typeToConstructor(registry, Type);
      const [values, decodedLength] = decodeVecFixed(registry, Clazz, length, value);
      super(registry, values, decodedLength);
      Object.defineProperty(this, _Type, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldBase(this, _Type)[_Type] = Clazz;
    }
    static with(Type, length) {
      return class extends VecFixed {
        constructor(registry, value) {
          super(registry, Type, length, value);
        }
      };
    }
    get Type() {
      return new (_classPrivateFieldBase(this, _Type)[_Type])(this.registry).toRawType();
    }
    get encodedLength() {
      let total = 0;
      for (let i = 0; i < this.length; i++) {
        total += this[i].encodedLength;
      }
      return total;
    }
    toU8a() {
      const encoded = new Array(this.length);
      for (let i = 0; i < this.length; i++) {
        encoded[i] = this[i].toU8a();
      }
      return encoded.length ? u8aConcat$1(...encoded) : new Uint8Array([]);
    }
    toRawType() {
      return `[${this.Type};${this.length}]`;
    }
  }

  class Base$3 {
    constructor(registry, value, initialU8aLength) {
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.initialU8aLength = void 0;
      this._raw = void 0;
      this.registry = registry;
      this._raw = value;
      this.initialU8aLength = initialU8aLength;
    }
    get encodedLength() {
      return this.toU8a().length;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this._raw.isEmpty;
    }
    eq(other) {
      return this._raw.eq(other);
    }
    toHex(isLe) {
      return this._raw.toHex(isLe);
    }
    toHuman(isExtended) {
      return this._raw.toHuman(isExtended);
    }
    toJSON() {
      return this._raw.toJSON();
    }
    toString() {
      return this._raw.toString();
    }
    toU8a(isBare) {
      return this._raw.toU8a(isBare);
    }
    toRawType() {
      return 'Base';
    }
  }

  function decodeRaw(registry, Type, value) {
    const Clazz = typeToConstructor(registry, Type);
    if (isU8a$1(value)) {
      const [, u8a] = compactStripLength(value);
      return new Clazz(registry, u8a);
    }
    return new Clazz(registry, value);
  }
  class WrapperOpaque extends Base$3 {
    constructor(registry, Type, value) {
      super(registry, decodeRaw(registry, Type, value));
    }
    static with(Type) {
      return class extends WrapperOpaque {
        constructor(registry, value) {
          super(registry, Type, value);
        }
      };
    }
    toRawType() {
      return `WrapperOpaque<${this._raw.toRawType()}>`;
    }
    toU8a(isBare) {
      const u8a = super.toU8a(isBare);
      return isBare ? u8a : compactAddLength(u8a);
    }
    unwrap() {
      return this._raw;
    }
  }

  function decodeBitVecU8a(value) {
    if (!value || !value.length) {
      return [0, new Uint8Array()];
    }
    const [offset, length] = compactFromU8a(value);
    const total = offset + Math.ceil(length.toNumber() / 8);
    assert$h(total <= value.length, () => `BitVec: required length less than remainder, expected at least ${total}, found ${value.length}`);
    return [length.toNumber(), value.subarray(offset, total)];
  }
  function decodeBitVec(value) {
    if (Array.isArray(value) || isString$1(value)) {
      const u8a = u8aToU8a$1(value);
      return [u8a.length / 8, u8a];
    }
    return decodeBitVecU8a(value);
  }
  class BitVec extends Raw {
    constructor(registry, value) {
      const [decodedLength, u8a] = decodeBitVec(value);
      super(registry, u8a);
      this._decodedLength = void 0;
      this._decodedLength = decodedLength;
    }
    get encodedLength() {
      return this.length + compactToU8a(this._decodedLength).length;
    }
    toHuman() {
      return `0b${[...this.toU8a(true)].map(d => `00000000${d.toString(2)}`.slice(-8)).join('_')}`;
    }
    toRawType() {
      return 'BitVec';
    }
    toU8a(isBare) {
      const bitVec = super.toU8a();
      return isBare ? bitVec : u8aConcat$1(compactToU8a(this._decodedLength), bitVec);
    }
  }

  function decodeBool(value) {
    if (isU8a$1(value)) {
      return value[0] === 1;
    } else if (value instanceof Boolean) {
      return value.valueOf();
    }
    return !!value;
  }
  class bool extends Boolean {
    constructor(registry, value = false) {
      super(decodeBool(value));
      this.registry = void 0;
      this.createdAtHash = void 0;
      this.registry = registry;
    }
    get encodedLength() {
      return 1;
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this.isFalse;
    }
    get isFalse() {
      return !this.isTrue;
    }
    get isTrue() {
      return this.valueOf();
    }
    eq(other) {
      return this.valueOf() === (other instanceof Boolean ? other.valueOf() : other);
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toHuman() {
      return this.toJSON();
    }
    toJSON() {
      return this.valueOf();
    }
    toRawType() {
      return 'bool';
    }
    toString() {
      return this.toJSON().toString();
    }
    toU8a(isBare) {
      return new Uint8Array([this.valueOf() ? 1 : 0]);
    }
  }

  const MAX_LENGTH$1 = 10 * 1024 * 1024;
  function decodeBytesU8a(value) {
    if (!value.length) {
      return [new Uint8Array(), 0];
    }
    const [offset, length] = compactFromU8a(value);
    const total = offset + length.toNumber();
    assert$h(length.lten(MAX_LENGTH$1), () => `Bytes length ${length.toString()} exceeds ${MAX_LENGTH$1}`);
    assert$h(total <= value.length, () => `Bytes: required length less than remainder, expected at least ${total}, found ${value.length}`);
    return [value.subarray(offset, total), total];
  }
  function decodeBytes(value) {
    if (Array.isArray(value) || isString$1(value)) {
      return [u8aToU8a$1(value), 0];
    } else if (!(value instanceof Raw) && isU8a$1(value)) {
      return decodeBytesU8a(value);
    }
    return [value, 0];
  }
  class Bytes extends Raw {
    constructor(registry, value) {
      const [u8a, decodedLength] = decodeBytes(value);
      super(registry, u8a, decodedLength);
    }
    get encodedLength() {
      return this.length + compactToU8a(this.length).length;
    }
    toRawType() {
      return 'Bytes';
    }
    toU8a(isBare) {
      return isBare ? super.toU8a(isBare) : compactAddLength(this);
    }
  }

  function decodeDataU8a(registry, value) {
    const indicator = value[0];
    if (!indicator) {
      return [undefined, undefined];
    } else if (indicator >= 1 && indicator <= 33) {
      const length = indicator - 1;
      const data = value.subarray(1, length + 1);
      return [registry.createType('Raw', data), 1];
    } else if (indicator >= 34 && indicator <= 37) {
      return [value.subarray(1, 32 + 1), indicator - 32];
    }
    throw new Error(`Unable to decode Data, invalid indicator byte ${indicator}`);
  }
  function decodeData(registry, value) {
    if (isU8a$1(value) || isString$1(value)) {
      return decodeDataU8a(registry, u8aToU8a$1(value));
    } else if (!value) {
      return [undefined, undefined];
    }
    return [value, undefined];
  }
  class Data extends Enum {
    constructor(registry, value) {
      super(registry, {
        None: 'Null',
        Raw: 'Bytes',
        BlakeTwo256: 'H256',
        Sha256: 'H256',
        Keccak256: 'H256',
        ShaThree256: 'H256'
      }, ...decodeData(registry, value));
      assert$h(!this.isRaw || this.asRaw.length <= 32, 'Data.Raw values are limited to a maximum length of 32 bytes');
    }
    get asBlakeTwo256() {
      return this.value;
    }
    get asKeccak256() {
      return this.value;
    }
    get asRaw() {
      return this.value;
    }
    get asSha256() {
      return this.value;
    }
    get asShaThree256() {
      return this.value;
    }
    get isBlakeTwo256() {
      return this.index === 2;
    }
    get isKeccak256() {
      return this.index === 4;
    }
    get isNone() {
      return this.index === 0;
    }
    get isRaw() {
      return this.index === 1;
    }
    get isSha256() {
      return this.index === 3;
    }
    get isShaThree256() {
      return this.index === 5;
    }
    get encodedLength() {
      return this.toU8a().length;
    }
    toU8a() {
      if (this.index === 0) {
        return new Uint8Array(1);
      } else if (this.index === 1) {
        const data = this.value.toU8a(true);
        const length = Math.min(data.length, 32);
        const u8a = new Uint8Array(length + 1);
        u8a.set([length + 1], 0);
        u8a.set(data.subarray(0, length), 1);
        return u8a;
      }
      const u8a = new Uint8Array(33);
      u8a.set([this.index + 32], 0);
      u8a.set(this.value.toU8a(), 1);
      return u8a;
    }
  }

  class i8 extends Int.with(8) {
    constructor(...args) {
      super(...args);
      this.__IntType = 'i8';
    }
  }

  class i16 extends Int.with(16) {
    constructor(...args) {
      super(...args);
      this.__IntType = 'i16';
    }
  }

  class i32 extends Int.with(32) {
    constructor(...args) {
      super(...args);
      this.__IntType = 'i32';
    }
  }

  class i64 extends Int.with(64) {
    constructor(...args) {
      super(...args);
      this.__IntType = 'i64';
    }
  }

  class i128 extends Int.with(128) {
    constructor(...args) {
      super(...args);
      this.__IntType = 'i128';
    }
  }

  class i256 extends Int.with(256) {
    constructor(...args) {
      super(...args);
      this.__IntType = 'i256';
    }
  }

  function flattenUniq(list, result = []) {
    for (let i = 0; i < list.length; i++) {
      const entry = list[i];
      if (Array.isArray(entry)) {
        flattenUniq(entry, result);
      } else {
        result.push(entry);
      }
    }
    return [...new Set(result)];
  }

  function getSiName(lookup, type) {
    const typeDef = lookup.getTypeDef(type);
    return typeDef.lookupName || typeDef.type;
  }

  const BOUNDED = ['BTreeMap', 'BTreeSet', 'HashMap', 'Vec'];
  const ALLOWED_BOXES = BOUNDED.concat(['Compact', 'DoNotConstruct', 'Int', 'Linkage', 'Range', 'RangeInclusive', 'Result', 'Option', 'UInt', 'WrapperOpaque']);
  const BOX_PRECEDING = ['<', '(', '[', '"', ',', ' '];
  const mappings = [
  alias('<T::InherentOfflineReport as InherentOfflineReport>::Inherent', 'InherentOfflineReport', false), alias('VecDeque<', 'Vec<', false),
  cleanupCompact(),
  removeExtensions('Bounded', true),
  removeExtensions('Weak', false),
  removeTraits(),
  removePairOf(),
  removeWrap('Box<'),
  removeGenerics(),
  alias('String', 'Text'),
  alias('Vec<u8>', 'Bytes'), alias('&\\[u8\\]', 'Bytes'), alias("&'static\\[u8\\]", 'Bytes'),
  alias('RawAddress', 'Address'),
  alias('Lookup::Source', 'LookupSource'), alias('Lookup::Target', 'LookupTarget'),
  alias('exec::StorageKey', 'ContractStorageKey'),
  flattenSingleTuple(),
  removeColons()];
  function findClosing(value, start) {
    let depth = 0;
    for (let index = start; index < value.length; index++) {
      if (value[index] === '>') {
        if (!depth) {
          return index;
        }
        depth--;
      } else if (value[index] === '<') {
        depth++;
      }
    }
    throw new Error(`Unable to find closing matching <> on '${value}' (start ${start})`);
  }
  function alias(src, dest, withChecks = true) {
    const from = new RegExp(`(^${src}|${BOX_PRECEDING.map(box => `\\${box}${src}`).join('|')})`, 'g');
    const to = src => {
      from.lastIndex = 0;
      return withChecks && BOX_PRECEDING.includes(src[0]) ? `${src[0]}${dest}` : dest;
    };
    return value => value.replace(from, to);
  }
  function cleanupCompact() {
    return value => {
      for (let index = 0; index < value.length; index++) {
        if (value[index] === '<') {
          const end = findClosing(value, index + 1) - 14;
          if (value.substr(end, 14) === ' as HasCompact') {
            value = `Compact<${value.substr(index + 1, end - index - 1)}>`;
          }
        }
      }
      return value;
    };
  }
  function flattenSingleTuple() {
    const from1 = /,\)/g;
    const from2 = /\(([^,]+)\)/;
    return value => {
      from1.lastIndex = 0;
      return value
      .replace(from1, ')')
      .replace(from2, '$1');
    };
  }
  function replaceTagWith(value, matcher, replacer) {
    let index = -1;
    while (true) {
      index = value.indexOf(matcher, index + 1);
      if (index === -1) {
        return value;
      }
      const start = index + matcher.length;
      const end = findClosing(value, start);
      value = `${value.substr(0, index)}${replacer(value.substr(start, end - start))}${value.substr(end + 1)}`;
    }
  }
  function removeExtensions(type, isSized) {
    return value => BOUNDED.reduce((value, tag) => replaceTagWith(value, `${type}${tag}<`, inner => {
      const parts = inner.split(',').map(s => s.trim()).filter(s => s);
      if (isSized) {
        parts.pop();
      }
      return `${tag}<${parts.join(',')}>`;
    }), value);
  }
  function removeColons() {
    return (value, {
      allowNamespaces
    } = {}) => {
      let index = 0;
      while (index !== -1) {
        index = value.indexOf('::');
        if (index === 0) {
          value = value.substr(2);
        } else if (index !== -1) {
          if (allowNamespaces) {
            return value;
          }
          let start = index;
          while (start !== -1 && !BOX_PRECEDING.includes(value[start])) {
            start--;
          }
          value = `${value.substr(0, start + 1)}${value.substr(index + 2)}`;
        }
      }
      return value;
    };
  }
  function removeGenerics() {
    return value => {
      for (let index = 0; index < value.length; index++) {
        if (value[index] === '<') {
          const box = ALLOWED_BOXES.find(box => {
            const start = index - box.length;
            return start >= 0 && value.substr(start, box.length) === box && (
            start === 0 || BOX_PRECEDING.includes(value[start - 1]));
          });
          if (!box) {
            const end = findClosing(value, index + 1);
            value = `${value.substr(0, index)}${value.substr(end + 1)}`;
          }
        }
      }
      return value;
    };
  }
  function removePairOf() {
    const replacer = inner => `(${inner},${inner})`;
    return value => replaceTagWith(value, 'PairOf<', replacer);
  }
  function removeTraits() {
    const from1 = /\s/g;
    const from2 = /(T|Self)::/g;
    const from3 = /<(T|Self)asTrait>::/g;
    const from4 = /<Tas[a-z]+::Trait>::/g;
    const from5 = /<LookupasStaticLookup>/g;
    const from6 = /::Type/g;
    return value => {
      from1.lastIndex = 0;
      from2.lastIndex = 0;
      from3.lastIndex = 0;
      from4.lastIndex = 0;
      from5.lastIndex = 0;
      from6.lastIndex = 0;
      return value
      .replace(from1, '')
      .replace(from2, '')
      .replace(from3, '')
      .replace(from4, '')
      .replace(from5, 'Lookup')
      .replace(from6, '');
    };
  }
  function removeWrap(check) {
    const replacer = inner => inner;
    return value => replaceTagWith(value, check, replacer);
  }
  const sanitizeMap = new Map();
  function sanitize(value, options) {
    let result = value.toString();
    if (!options) {
      const memoized = sanitizeMap.get(result);
      if (memoized) {
        return memoized;
      }
    }
    for (let i = 0; i < mappings.length; i++) {
      result = mappings[i](result, options);
    }
    result = result.trim();
    if (!options) {
      sanitizeMap.set(value.toString(), result);
    }
    return result;
  }

  exports.TypeDefInfo = void 0;
  (function (TypeDefInfo) {
    TypeDefInfo[TypeDefInfo["BTreeMap"] = 0] = "BTreeMap";
    TypeDefInfo[TypeDefInfo["BTreeSet"] = 1] = "BTreeSet";
    TypeDefInfo[TypeDefInfo["Compact"] = 2] = "Compact";
    TypeDefInfo[TypeDefInfo["DoNotConstruct"] = 3] = "DoNotConstruct";
    TypeDefInfo[TypeDefInfo["Enum"] = 4] = "Enum";
    TypeDefInfo[TypeDefInfo["HashMap"] = 5] = "HashMap";
    TypeDefInfo[TypeDefInfo["Int"] = 6] = "Int";
    TypeDefInfo[TypeDefInfo["Linkage"] = 7] = "Linkage";
    TypeDefInfo[TypeDefInfo["Null"] = 8] = "Null";
    TypeDefInfo[TypeDefInfo["Option"] = 9] = "Option";
    TypeDefInfo[TypeDefInfo["Plain"] = 10] = "Plain";
    TypeDefInfo[TypeDefInfo["Range"] = 11] = "Range";
    TypeDefInfo[TypeDefInfo["Result"] = 12] = "Result";
    TypeDefInfo[TypeDefInfo["Set"] = 13] = "Set";
    TypeDefInfo[TypeDefInfo["Si"] = 14] = "Si";
    TypeDefInfo[TypeDefInfo["Struct"] = 15] = "Struct";
    TypeDefInfo[TypeDefInfo["Tuple"] = 16] = "Tuple";
    TypeDefInfo[TypeDefInfo["UInt"] = 17] = "UInt";
    TypeDefInfo[TypeDefInfo["Vec"] = 18] = "Vec";
    TypeDefInfo[TypeDefInfo["VecFixed"] = 19] = "VecFixed";
    TypeDefInfo[TypeDefInfo["WrapperOpaque"] = 20] = "WrapperOpaque";
  })(exports.TypeDefInfo || (exports.TypeDefInfo = {}));

  function isNotNested(...counters) {
    return !counters.some(counter => counter !== 0);
  }
  function typeSplit(type) {
    let [cDepth, fDepth, sDepth, tDepth, start] = [0, 0, 0, 0, 0];
    const result = [];
    const extract = index => {
      if (isNotNested(cDepth, fDepth, sDepth, tDepth)) {
        result.push(type.substr(start, index - start).trim());
        start = index + 1;
      }
    };
    for (let index = 0; index < type.length; index++) {
      switch (type[index]) {
        case ',':
          extract(index);
          break;
        case '<':
          cDepth++;
          break;
        case '>':
          cDepth--;
          break;
        case '[':
          fDepth++;
          break;
        case ']':
          fDepth--;
          break;
        case '{':
          sDepth++;
          break;
        case '}':
          sDepth--;
          break;
        case '(':
          tDepth++;
          break;
        case ')':
          tDepth--;
          break;
      }
    }
    assert$h(isNotNested(cDepth, fDepth, sDepth, tDepth), () => `Invalid definition (missing terminators) found in ${type}`);
    result.push(type.substr(start, type.length - start).trim());
    return result;
  }

  const MAX_NESTED = 64;
  const KNOWN_INTERNALS = ['_alias', '_fallback'];
  function getTypeString(typeOrObj) {
    return isString$1(typeOrObj) ? typeOrObj.toString() : JSON.stringify(typeOrObj);
  }
  function isRustEnum(details) {
    const values = Object.values(details);
    if (values.some(v => isNumber$1(v))) {
      assert$h(values.every(v => isNumber$1(v) && v >= 0 && v <= 255), 'Invalid number-indexed enum definition');
      return false;
    }
    return true;
  }
  function _decodeEnum(value, details, count) {
    value.info = exports.TypeDefInfo.Enum;
    if (Array.isArray(details)) {
      value.sub = details.map((name, index) => ({
        index,
        info: exports.TypeDefInfo.Plain,
        name,
        type: 'Null'
      }));
    } else if (isRustEnum(details)) {
      value.sub = Object.entries(details).map(([name, typeOrObj], index) => objectSpread$1({}, getTypeDef(getTypeString(typeOrObj || 'Null'), {
        name
      }, count), {
        index
      }));
    } else {
      value.sub = Object.entries(details).map(([name, index]) => ({
        index,
        info: exports.TypeDefInfo.Plain,
        name,
        type: 'Null'
      }));
    }
    return value;
  }
  function _decodeSet(value, details) {
    value.info = exports.TypeDefInfo.Set;
    value.length = details._bitLength;
    value.sub = Object.entries(details).filter(([name]) => !name.startsWith('_')).map(([name, index]) => ({
      index,
      info: exports.TypeDefInfo.Plain,
      name,
      type: 'Null'
    }));
    return value;
  }
  function _decodeStruct(value, type, _, count) {
    const parsed = JSON.parse(type);
    const keys = Object.keys(parsed);
    if (keys.length === 1 && keys[0] === '_enum') {
      return _decodeEnum(value, parsed[keys[0]], count);
    } else if (keys.length === 1 && keys[0] === '_set') {
      return _decodeSet(value, parsed[keys[0]]);
    }
    value.alias = parsed._alias ? new Map(Object.entries(parsed._alias)) : undefined;
    value.fallbackType = parsed._fallback;
    value.sub = keys.filter(name => !KNOWN_INTERNALS.includes(name)).map(name => getTypeDef(getTypeString(parsed[name]), {
      name
    }, count));
    return value;
  }
  function _decodeFixedVec(value, type, _, count) {
    const max = type.length - 1;
    let index = -1;
    let inner = 0;
    for (let i = 1; i < max && index === -1; i++) {
      if (type[i] === ';' && inner === 0) {
        index = i;
      } else if (['[', '(', '<'].includes(type[i])) {
        inner++;
      } else if ([']', ')', '>'].includes(type[i])) {
        inner--;
      }
    }
    assert$h(index !== -1, () => `${type}: Unable to extract location of ';'`);
    const vecType = type.substr(1, index - 1);
    const [strLength, displayName] = type.substr(index + 1, max - index - 1).split(';');
    const length = parseInt(strLength.trim(), 10);
    assert$h(length <= 256, () => `${type}: Only support for [Type; <length>], where length <= 256`);
    value.displayName = displayName;
    value.length = length;
    value.sub = getTypeDef(vecType, {}, count);
    return value;
  }
  function _decodeRange(value, _, subType) {
    const Type = getTypeDef(subType);
    value.sub = [Type, Type];
    return value;
  }
  function _decodeTuple(value, _, subType, count) {
    value.sub = subType.length === 0 ? [] : typeSplit(subType).map(inner => getTypeDef(inner, {}, count));
    return value;
  }
  function _decodeAnyInt(value, type, _, clazz) {
    const [strLength, displayName] = type.substr(clazz.length + 1, type.length - clazz.length - 1 - 1).split(',');
    const length = parseInt(strLength.trim(), 10);
    assert$h(length <= 8192 && length % 8 === 0, () => `${type}: Only support for ${clazz}<bitLength>, where length <= 8192 and a power of 8, found ${length}`);
    value.displayName = displayName;
    value.length = length;
    return value;
  }
  function _decodeInt(value, type, subType) {
    return _decodeAnyInt(value, type, subType, 'Int');
  }
  function _decodeUInt(value, type, subType) {
    return _decodeAnyInt(value, type, subType, 'UInt');
  }
  function _decodeDoNotConstruct(value, type, _) {
    const NAME_LENGTH = 'DoNotConstruct'.length;
    value.displayName = type.substr(NAME_LENGTH + 1, type.length - NAME_LENGTH - 1 - 1);
    return value;
  }
  function hasWrapper(type, [start, end]) {
    return type.substr(0, start.length) === start && type.substr(-1 * end.length) === end;
  }
  const nestedExtraction = [['[', ']', exports.TypeDefInfo.VecFixed, _decodeFixedVec], ['{', '}', exports.TypeDefInfo.Struct, _decodeStruct], ['(', ')', exports.TypeDefInfo.Tuple, _decodeTuple],
  ['BTreeMap<', '>', exports.TypeDefInfo.BTreeMap, _decodeTuple], ['HashMap<', '>', exports.TypeDefInfo.HashMap, _decodeTuple], ['Int<', '>', exports.TypeDefInfo.Int, _decodeInt],
  ['Range<', '>', exports.TypeDefInfo.Tuple, _decodeRange], ['RangeInclusive<', '>', exports.TypeDefInfo.Tuple, _decodeRange], ['Result<', '>', exports.TypeDefInfo.Result, _decodeTuple], ['UInt<', '>', exports.TypeDefInfo.UInt, _decodeUInt], ['DoNotConstruct<', '>', exports.TypeDefInfo.DoNotConstruct, _decodeDoNotConstruct]];
  const wrappedExtraction = [['BTreeSet<', '>', exports.TypeDefInfo.BTreeSet], ['Compact<', '>', exports.TypeDefInfo.Compact], ['Linkage<', '>', exports.TypeDefInfo.Linkage], ['Option<', '>', exports.TypeDefInfo.Option], ['Vec<', '>', exports.TypeDefInfo.Vec], ['WrapperOpaque<', '>', exports.TypeDefInfo.WrapperOpaque]];
  function extractSubType(type, [start, end]) {
    return type.substr(start.length, type.length - start.length - end.length);
  }
  function getTypeDef(_type, {
    displayName,
    name
  } = {}, count = 0) {
    const type = sanitize(_type);
    const value = {
      displayName,
      info: exports.TypeDefInfo.Plain,
      name,
      type
    };
    assert$h(++count !== MAX_NESTED, 'getTypeDef: Maximum nested limit reached');
    const nested = nestedExtraction.find(nested => hasWrapper(type, nested));
    if (nested) {
      value.info = nested[2];
      return nested[3](value, type, extractSubType(type, nested), count);
    }
    const wrapped = wrappedExtraction.find(wrapped => hasWrapper(type, wrapped));
    if (wrapped) {
      value.info = wrapped[2];
      value.sub = getTypeDef(extractSubType(type, wrapped), {}, count);
    }
    return value;
  }

  function extractSubSingle({
    lookupName,
    type
  }) {
    return extractTypes$1([lookupName || type]);
  }
  function extractSubArray(types) {
    return extractTypes$1(types.map(({
      lookupName,
      type
    }) => lookupName || type));
  }
  function extractTypes$1(types) {
    return types.map(type => {
      const decoded = getTypeDef(type);
      switch (decoded.info) {
        case exports.TypeDefInfo.Plain:
          return decoded.lookupName || decoded.type;
        case exports.TypeDefInfo.BTreeSet:
        case exports.TypeDefInfo.Compact:
        case exports.TypeDefInfo.Option:
        case exports.TypeDefInfo.Vec:
        case exports.TypeDefInfo.VecFixed:
        case exports.TypeDefInfo.WrapperOpaque:
          return extractSubSingle(decoded.sub);
        case exports.TypeDefInfo.BTreeMap:
        case exports.TypeDefInfo.Enum:
        case exports.TypeDefInfo.HashMap:
        case exports.TypeDefInfo.Result:
        case exports.TypeDefInfo.Set:
        case exports.TypeDefInfo.Struct:
        case exports.TypeDefInfo.Tuple:
          return extractSubArray(decoded.sub);
        default:
          throw new Error(`Unhandled: Unable to create and validate type from ${type} (info=${exports.TypeDefInfo[decoded.info]})`);
      }
    });
  }

  const l$1 = logger('metadata');
  function validateTypes(registry, throwError, types) {
    const missing = flattenUniq(extractTypes$1(types)).filter(type => !registry.hasType(type)).sort();
    if (missing.length !== 0) {
      const message = `Unknown types found, no types for ${missing.join(', ')}`;
      if (throwError) {
        throw new Error(message);
      } else {
        l$1.warn(message);
      }
    }
    return types;
  }

  function extractTypes(lookup, types) {
    return types.map(({
      type
    }) => lookup.getTypeDef(type).type);
  }
  function extractFieldTypes(lookup, type) {
    return lookup.getSiType(type).def.asVariant.variants.map(({
      fields
    }) => extractTypes(lookup, fields));
  }
  function getPalletNames({
    lookup,
    pallets
  }) {
    return pallets.reduce((all, {
      calls,
      constants,
      events,
      storage
    }) => {
      all.push([extractTypes(lookup, constants)]);
      if (calls.isSome) {
        all.push(extractFieldTypes(lookup, calls.unwrap().type));
      }
      if (events.isSome) {
        all.push(extractFieldTypes(lookup, events.unwrap().type));
      }
      if (storage.isSome) {
        all.push(storage.unwrap().items.map(({
          type
        }) => {
          if (type.isPlain) {
            return [lookup.getTypeDef(type.asPlain).type];
          }
          const {
            hashers,
            key,
            value
          } = type.asMap;
          return hashers.length === 1 ? [lookup.getTypeDef(value).type, lookup.getTypeDef(key).type] : [lookup.getTypeDef(value).type, ...lookup.getSiType(key).def.asTuple.map(t => lookup.getTypeDef(t).type)];
        }));
      }
      return all;
    }, []);
  }
  function getUniqTypes(registry, meta, throwError) {
    return validateTypes(registry, throwError, flattenUniq(getPalletNames(meta)));
  }

  function trimDocs(docs) {
    const strings = docs.map(d => d.toString().trim());
    const firstEmpty = strings.findIndex(d => !d.length);
    return firstEmpty === -1 ? strings : strings.slice(0, firstEmpty);
  }
  function toCallsOnly(registry, {
    extrinsic,
    lookup,
    pallets
  }) {
    return registry.createType('MetadataLatest', {
      extrinsic,
      lookup: {
        types: lookup.types.map(({
          id,
          type
        }) => registry.createType('PortableType', {
          id,
          type: { ...type,
            docs: trimDocs(type.docs)
          }
        }))
      },
      pallets: pallets.map(({
        calls,
        index,
        name
      }) => ({
        calls: registry.createType('Option<PalletCallMetadataLatest>', calls.unwrapOr(null)),
        index,
        name
      }))
    }).toJSON();
  }

  const HASHER_MAP = {
    Blake2_128: [16, false],
    Blake2_128Concat: [16, true],
    Blake2_256: [32, false],
    Identity: [0, true],
    Twox128: [16, false],
    Twox256: [32, false],
    Twox64Concat: [8, true]
  };
  function unwrapStorageSi(type) {
    return type.isPlain ? type.asPlain : type.asMap.value;
  }
  function unwrapStorageType(registry, type, isOptional) {
    const outputType = getSiName(registry.lookup, unwrapStorageSi(type));
    return isOptional ? `Option<${outputType}>` : outputType;
  }
  function decodeStorageKey(value) {
    if (isU8a$1(value) || !value || isString$1(value)) {
      return {
        key: value
      };
    } else if (value instanceof StorageKey) {
      return {
        key: value,
        method: value.method,
        section: value.section
      };
    } else if (isFunction$1(value)) {
      return {
        key: value(),
        method: value.method,
        section: value.section
      };
    } else if (Array.isArray(value)) {
      const [fn, args = []] = value;
      assert$h(isFunction$1(fn), 'Expected function input for key construction');
      if (fn.meta && fn.meta.type.isMap) {
        const map = fn.meta.type.asMap;
        assert$h(Array.isArray(args) && args.length === map.hashers.length, () => `Expected an array of ${map.hashers.length} values as params to a Map query`);
      }
      return {
        key: fn(...args),
        method: fn.method,
        section: fn.section
      };
    }
    throw new Error(`Unable to convert input ${value} to StorageKey`);
  }
  function decodeHashers(registry, value, hashers) {
    let offset = 32;
    const result = new Array(hashers.length);
    for (let i = 0; i < hashers.length; i++) {
      const [hasher, type] = hashers[i];
      const [hashLen, canDecode] = HASHER_MAP[hasher.type];
      const decoded = canDecode ? registry.createType(registry.createLookupType(type), value.subarray(offset + hashLen)) : registry.createType('Raw', value.subarray(offset, offset + hashLen));
      offset += hashLen + (canDecode ? decoded.encodedLength : 0);
      result[i] = decoded;
    }
    return result;
  }
  function decodeArgsFromMeta(registry, value, meta) {
    if (!meta || !meta.type.isMap) {
      return [];
    }
    const {
      hashers,
      key
    } = meta.type.asMap;
    const keys = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;
    return decodeHashers(registry, value, hashers.map((h, i) => [h, keys[i]]));
  }
  function getMeta(value) {
    if (value instanceof StorageKey) {
      return value.meta;
    } else if (isFunction$1(value)) {
      return value.meta;
    } else if (Array.isArray(value)) {
      const [fn] = value;
      return fn.meta;
    }
    return undefined;
  }
  function getType(registry, value) {
    if (value instanceof StorageKey) {
      return value.outputType;
    } else if (isFunction$1(value)) {
      return unwrapStorageType(registry, value.meta.type);
    } else if (Array.isArray(value)) {
      const [fn] = value;
      if (fn.meta) {
        return unwrapStorageType(registry, fn.meta.type);
      }
    }
    return 'Raw';
  }
  class StorageKey extends Bytes {
    constructor(registry, value, override = {}) {
      const {
        key,
        method,
        section
      } = decodeStorageKey(value);
      super(registry, key);
      this._args = void 0;
      this._meta = void 0;
      this._outputType = void 0;
      this._method = void 0;
      this._section = void 0;
      this._outputType = getType(registry, value);
      this.setMeta(getMeta(value), override.section || section, override.method || method);
    }
    get args() {
      return this._args;
    }
    get meta() {
      return this._meta;
    }
    get method() {
      return this._method;
    }
    get outputType() {
      return this._outputType;
    }
    get section() {
      return this._section;
    }
    is(key) {
      return key.section === this.section && key.method === this.method;
    }
    setMeta(meta, section, method) {
      this._meta = meta;
      this._method = method || this._method;
      this._section = section || this._section;
      if (meta) {
        this._outputType = unwrapStorageType(this.registry, meta.type);
      }
      try {
        this._args = decodeArgsFromMeta(this.registry, this.toU8a(true), this.meta);
      } catch (error) {
      }
      return this;
    }
    toHuman() {
      return this._args.length ? this._args.map(arg => arg.toHuman()) : super.toHuman();
    }
    toRawType() {
      return 'StorageKey';
    }
  }

  const MAX_LENGTH = 128 * 1024;
  function decodeText(value) {
    if (isU8a$1(value)) {
      if (!value.length) {
        return ['', 0];
      }
      if (value instanceof Raw) {
        return [u8aToString$1(value), 0];
      }
      const [offset, length] = compactFromU8a(value);
      const total = offset + length.toNumber();
      assert$h(length.lten(MAX_LENGTH), () => `Text: length ${length.toString()} exceeds ${MAX_LENGTH}`);
      assert$h(total <= value.length, () => `Text: required length less than remainder, expected at least ${total}, found ${value.length}`);
      return [u8aToString$1(value.subarray(offset, total)), total];
    } else if (isHex$1(value)) {
      return [u8aToString$1(hexToU8a$1(value)), 0];
    }
    return [value ? value.toString() : '', 0];
  }
  var _initialU8aLength = _classPrivateFieldKey("initialU8aLength");
  var _override = _classPrivateFieldKey("override");
  class Text extends String {
    constructor(registry, value) {
      const [str, decodedLength] = decodeText(value);
      super(str);
      this.registry = void 0;
      this.createdAtHash = void 0;
      Object.defineProperty(this, _initialU8aLength, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _override, {
        writable: true,
        value: null
      });
      this.registry = registry;
      _classPrivateFieldBase(this, _initialU8aLength)[_initialU8aLength] = decodedLength;
    }
    get encodedLength() {
      return this.toU8a().length;
    }
    get initialU8aLength() {
      return _classPrivateFieldBase(this, _initialU8aLength)[_initialU8aLength];
    }
    get hash() {
      return this.registry.hash(this.toU8a());
    }
    get isEmpty() {
      return this.length === 0;
    }
    get length() {
      return super.length;
    }
    eq(other) {
      return isString$1(other) ? this.toString() === other.toString() : false;
    }
    setOverride(override) {
      _classPrivateFieldBase(this, _override)[_override] = override;
    }
    toHex() {
      return u8aToHex$1(this.toU8a(true));
    }
    toHuman() {
      return this.toJSON();
    }
    toJSON() {
      return this.toString();
    }
    toRawType() {
      return 'Text';
    }
    toString() {
      return _classPrivateFieldBase(this, _override)[_override] || super.toString();
    }
    toU8a(isBare) {
      const encoded = stringToU8a$1(super.toString());
      return isBare ? encoded : compactAddLength(encoded);
    }
  }

  class Type extends Text {
    constructor(registry, value = '') {
      super(registry, value);
      this.setOverride(sanitize(this.toString()));
    }
    toRawType() {
      return 'Type';
    }
  }

  class u8$1 extends UInt.with(8) {
    constructor(...args) {
      super(...args);
      this.__UIntType = 'u8';
    }
  }

  class u16$1 extends UInt.with(16) {
    constructor(...args) {
      super(...args);
      this.__UIntType = 'u16';
    }
  }

  class u32$1 extends UInt.with(32) {
    constructor(...args) {
      super(...args);
      this.__UIntType = 'u32';
    }
  }

  class u64 extends UInt.with(64) {
    constructor(...args) {
      super(...args);
      this.__UIntType = 'u64';
    }
  }

  class u128 extends UInt.with(128) {
    constructor(...args) {
      super(...args);
      this.__UIntType = 'u128';
    }
  }

  class u256 extends UInt.with(256) {
    constructor(...args) {
      super(...args);
      this.__UIntType = 'u256';
    }
  }

  class usize extends u32$1 {
    constructor(registry, value) {
      super(registry, value);
      throw new Error('The `usize` type should not be used. Since it is platform-specific, it creates incompatibilities between native (generally u64) and WASM (always u32) code. Use one of the `u32` or `u64` types explicitly.');
    }
  }

  function getTypeDefType({
    lookupName,
    type
  }) {
    return lookupName || type;
  }
  function getSubDefArray(value) {
    assert$h(value.sub && Array.isArray(value.sub), () => `Expected subtype as TypeDef[] in ${stringify(value)}`);
    return value.sub;
  }
  function getSubDef(value) {
    assert$h(value.sub && !Array.isArray(value.sub), () => `Expected subtype as TypeDef in ${stringify(value)}`);
    return value.sub;
  }
  function getSubType(value) {
    return getTypeDefType(getSubDef(value));
  }
  function getTypeClassMap(value) {
    const subs = getSubDefArray(value);
    const map = {};
    for (let i = 0; i < subs.length; i++) {
      map[subs[i].name] = getTypeDefType(subs[i]);
    }
    return map;
  }
  function getTypeClassArray(value) {
    return getSubDefArray(value).map(getTypeDefType);
  }
  function createInt({
    displayName,
    length
  }, Clazz) {
    assert$h(isNumber$1(length), () => `Expected bitLength information for ${displayName || Clazz.constructor.name}<bitLength>`);
    return Clazz.with(length, displayName);
  }
  function createHashMap(value, Clazz) {
    const [keyType, valueType] = getTypeClassArray(value);
    return Clazz.with(keyType, valueType);
  }
  const infoMapping = {
    [exports.TypeDefInfo.BTreeMap]: (registry, value) => createHashMap(value, BTreeMap),
    [exports.TypeDefInfo.BTreeSet]: (registry, value) => BTreeSet.with(getSubType(value)),
    [exports.TypeDefInfo.Compact]: (registry, value) => Compact.with(getSubType(value)),
    [exports.TypeDefInfo.DoNotConstruct]: (registry, value) => DoNotConstruct.with(value.displayName || value.type),
    [exports.TypeDefInfo.Enum]: (registry, value) => {
      const subs = getSubDefArray(value);
      return Enum.with(subs.every(({
        type
      }) => type === 'Null') ? subs.reduce((out, {
        index,
        name
      }, count) => {
        out[name] = index || count;
        return out;
      }, {}) : getTypeClassMap(value));
    },
    [exports.TypeDefInfo.HashMap]: (registry, value) => createHashMap(value, HashMap),
    [exports.TypeDefInfo.Int]: (registry, value) => createInt(value, Int),
    [exports.TypeDefInfo.Linkage]: (registry, value) => {
      const type = `Option<${getSubType(value)}>`;
      const Clazz = Struct.with({
        previous: type,
        next: type
      });
      Clazz.prototype.toRawType = function () {
        return `Linkage<${this.next.toRawType(true)}>`;
      };
      return Clazz;
    },
    [exports.TypeDefInfo.Null]: (registry, _) => Null,
    [exports.TypeDefInfo.Option]: (registry, value) => Option.with(getSubType(value)),
    [exports.TypeDefInfo.Plain]: (registry, value) => registry.getOrUnknown(value.type),
    [exports.TypeDefInfo.Range]: (registry, value) => (value.type.includes('RangeInclusive') ? RangeInclusive : Range).with(getSubType(value)),
    [exports.TypeDefInfo.Result]: (registry, value) => {
      const [Ok, Err] = getTypeClassArray(value);
      return Result.with({
        Err,
        Ok
      });
    },
    [exports.TypeDefInfo.Set]: (registry, value) => CodecSet.with(getSubDefArray(value).reduce((result, {
      index,
      name
    }) => {
      result[name] = index;
      return result;
    }, {}), value.length),
    [exports.TypeDefInfo.Si]: (registry, value) => getTypeClass(registry, registry.lookup.getTypeDef(value.type)),
    [exports.TypeDefInfo.Struct]: (registry, value) => Struct.with(getTypeClassMap(value), value.alias),
    [exports.TypeDefInfo.Tuple]: (registry, value) => Tuple.with(getTypeClassArray(value)),
    [exports.TypeDefInfo.UInt]: (registry, value) => createInt(value, UInt),
    [exports.TypeDefInfo.Vec]: (registry, {
      sub
    }) => {
      assert$h(sub && !Array.isArray(sub), 'Expected type information for vector');
      return sub.type === 'u8' ? Bytes : Vec.with(getTypeDefType(sub));
    },
    [exports.TypeDefInfo.VecFixed]: (registry, {
      displayName,
      length,
      sub
    }) => {
      assert$h(sub && isNumber$1(length) && !Array.isArray(sub), 'Expected length & type information for fixed vector');
      return sub.type === 'u8' ? U8aFixed.with(length * 8, displayName) : VecFixed.with(getTypeDefType(sub), length);
    },
    [exports.TypeDefInfo.WrapperOpaque]: (registry, value) => WrapperOpaque.with(getSubType(value))
  };
  function constructTypeClass(registry, typeDef) {
    try {
      const Type = infoMapping[typeDef.info](registry, typeDef);
      assert$h(Type, 'No class created');
      if (!Type.__fallbackType && typeDef.fallbackType) {
        Type.__fallbackType = typeDef.fallbackType;
      }
      return Type;
    } catch (error) {
      throw new Error(`Unable to construct class from ${stringify(typeDef)}: ${error.message}`);
    }
  }
  function getTypeClass(registry, typeDef) {
    return registry.get(typeDef.type, false, typeDef);
  }
  function createClass(registry, type) {
    return getTypeClass(registry, registry.isLookupType(type) ? registry.lookup.getTypeDef(type) : getTypeDef(type));
  }

  function checkInstance(created, matcher) {
    const u8a = created.toU8a();
    const rawType = created.toRawType();
    const isOk =
    u8aEq(u8a, matcher) ||
    ['Bytes', 'Text', 'Type'].includes(rawType) && matcher.length === created.length ||
    created.isEmpty && matcher.every(v => !v);
    assert$h(isOk, () => `${rawType}:: Decoded input doesn't match input, received ${u8aToHex$1(matcher, 512)} (${matcher.length} bytes), created ${u8aToHex$1(u8a, 512)} (${u8a.length} bytes)`);
  }
  function checkPedantic(created, [value], isPedantic = false) {
    if (isPedantic) {
      if (isU8a$1(value)) {
        checkInstance(created, value);
      } else if (isHex$1(value)) {
        checkInstance(created, u8aToU8a$1(value));
      }
    }
  }
  function initType(registry, Type, params = [], {
    blockHash,
    isOptional,
    isPedantic
  } = {}) {
    const created = new (isOptional ? Option.with(Type) : Type)(registry, ...params);
    checkPedantic(created, params, isPedantic);
    if (blockHash) {
      created.createdAtHash = createType(registry, 'Hash', blockHash);
    }
    return created;
  }
  function createTypeUnsafe(registry, type, params = [], options = {}) {
    let Clazz = null;
    let firstError = null;
    try {
      Clazz = createClass(registry, type);
      return initType(registry, Clazz, params, options);
    } catch (error) {
      firstError = new Error(`createType(${type}):: ${error.message}`);
    }
    if (Clazz && Clazz.__fallbackType) {
      try {
        Clazz = createClass(registry, Clazz.__fallbackType);
        return initType(registry, Clazz, params, options);
      } catch {
      }
    }
    throw firstError;
  }
  function createType(registry, type, ...params) {
    return createTypeUnsafe(registry, type, params);
  }

  const stringIdentity = value => value.toString();
  const INFO_WRAP = ['BTreeMap', 'BTreeSet', 'Compact', 'HashMap', 'Option', 'Result', 'Vec'];
  function paramsNotation(outer, inner, transform = stringIdentity) {
    return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;
  }
  function encodeWithParams(registry, typeDef, outer) {
    const {
      info,
      sub
    } = typeDef;
    switch (info) {
      case exports.TypeDefInfo.BTreeMap:
      case exports.TypeDefInfo.BTreeSet:
      case exports.TypeDefInfo.Compact:
      case exports.TypeDefInfo.HashMap:
      case exports.TypeDefInfo.Linkage:
      case exports.TypeDefInfo.Option:
      case exports.TypeDefInfo.Result:
      case exports.TypeDefInfo.Vec:
      case exports.TypeDefInfo.WrapperOpaque:
        return paramsNotation(outer, sub, p => encodeTypeDef(registry, p));
    }
    throw new Error(`Unable to encode ${stringify(typeDef)} with params`);
  }
  function encodeSubTypes(registry, sub, asEnum, extra) {
    const names = sub.map(({
      name
    }) => name);
    assert$h(names.every(n => !!n), () => `Subtypes does not have consistent names, ${names.join(', ')}`);
    const inner = objectSpread$1({}, extra);
    for (let i = 0; i < sub.length; i++) {
      const def = sub[i];
      inner[def.name] = encodeTypeDef(registry, def);
    }
    return stringify(asEnum ? {
      _enum: inner
    } : inner);
  }
  const encoders = {
    [exports.TypeDefInfo.BTreeMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeMap'),
    [exports.TypeDefInfo.BTreeSet]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'BTreeSet'),
    [exports.TypeDefInfo.Compact]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Compact'),
    [exports.TypeDefInfo.DoNotConstruct]: (registry, {
      displayName,
      lookupIndex,
      lookupName
    }) => `DoNotConstruct<${lookupName || displayName || (isUndefined(lookupIndex) ? 'Unknown' : registry.createLookupType(lookupIndex))}>`,
    [exports.TypeDefInfo.Enum]: (registry, {
      sub
    }) => {
      assert$h(sub && Array.isArray(sub), 'Unable to encode Enum type');
      return sub.every(({
        type
      }) => type === 'Null') ? stringify({
        _enum: sub.map(({
          name
        }, index) => `${name || `Empty${index}`}`)
      }) : encodeSubTypes(registry, sub, true);
    },
    [exports.TypeDefInfo.HashMap]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'HashMap'),
    [exports.TypeDefInfo.Int]: (registry, {
      length = 32
    }) => `Int<${length}>`,
    [exports.TypeDefInfo.Linkage]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Linkage'),
    [exports.TypeDefInfo.Null]: (registry, typeDef) => 'Null',
    [exports.TypeDefInfo.Option]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Option'),
    [exports.TypeDefInfo.Plain]: (registry, {
      displayName,
      type
    }) => displayName || type,
    [exports.TypeDefInfo.Range]: (registry, typeDef) => encodeWithParams(registry, typeDef, typeDef.type.includes('RangeInclusive') ? 'RangeInclusive' : 'Range'),
    [exports.TypeDefInfo.Result]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Result'),
    [exports.TypeDefInfo.Set]: (registry, {
      length = 8,
      sub
    }) => {
      assert$h(sub && Array.isArray(sub), 'Unable to encode Set type');
      return stringify({
        _set: sub.reduce((all, {
          index,
          name
        }, count) => objectSpread$1(all, {
          [`${name || `Unknown${index || count}`}`]: index || count
        }), {
          _bitLength: length || 8
        })
      });
    },
    [exports.TypeDefInfo.Si]: (registry, {
      lookupName,
      type
    }) => lookupName || type,
    [exports.TypeDefInfo.Struct]: (registry, {
      alias,
      sub
    }) => {
      assert$h(sub && Array.isArray(sub), 'Unable to encode Struct type');
      return encodeSubTypes(registry, sub, false, alias ? {
        _alias: [...alias.entries()].reduce((all, [k, v]) => objectSpread$1(all, {
          [k]: v
        }), {})
      } : {});
    },
    [exports.TypeDefInfo.Tuple]: (registry, {
      sub
    }) => {
      assert$h(sub && Array.isArray(sub), 'Unable to encode Tuple type');
      return `(${sub.map(type => encodeTypeDef(registry, type)).join(',')})`;
    },
    [exports.TypeDefInfo.UInt]: (registry, {
      length = 32
    }) => `UInt<${length}>`,
    [exports.TypeDefInfo.Vec]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'Vec'),
    [exports.TypeDefInfo.VecFixed]: (registry, {
      length,
      sub
    }) => {
      assert$h(isNumber$1(length) && !isUndefined(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');
      return `[${sub.type};${length}]`;
    },
    [exports.TypeDefInfo.WrapperOpaque]: (registry, typeDef) => encodeWithParams(registry, typeDef, 'WrapperOpaque')
  };
  function encodeType(registry, typeDef, withLookup = true) {
    return withLookup && typeDef.lookupName ? typeDef.lookupName : encoders[typeDef.info](registry, typeDef);
  }
  function encodeTypeDef(registry, typeDef) {
    return typeDef.displayName && !INFO_WRAP.some(i => typeDef.displayName === i) ? typeDef.displayName : encodeType(registry, typeDef);
  }
  function withTypeString(registry, typeDef) {
    return objectSpread$1({}, typeDef, {
      type: encodeType(registry, typeDef, false)
    });
  }

  function lazyVariants(lookup, {
    type
  }, getName, creator) {
    const result = {};
    const variants = lookup.getSiType(type).def.asVariant.variants;
    for (let i = 0; i < variants.length; i++) {
      lazyMethod(result, variants[i], creator, getName);
    }
    return result;
  }

  class TextDecoder$1 {
    constructor(_) {
    }
    decode(value) {
      let result = '';
      for (const c of value) {
        result += String.fromCharCode(c);
      }
      return result;
    }
  }

  const TextDecoder = typeof xglobal.TextDecoder === 'undefined' ? TextDecoder$1 : xglobal.TextDecoder;

  class TextEncoder$1 {
    encode(value) {
      const u8a = new Uint8Array(value.length);
      for (let i = 0; i < value.length; i++) {
        u8a[i] = value.charCodeAt(i);
      }
      return u8a;
    }
  }

  const TextEncoder = typeof xglobal.TextEncoder === 'undefined' ? TextEncoder$1 : xglobal.TextEncoder;

  function isFunction(value) {
    return typeof value === 'function';
  }

  function isString(value) {
    return typeof value === 'string' || value instanceof String;
  }

  function assert$g(condition, message) {
    if (!condition) {
      throw new Error(isFunction(message) ? message() : message);
    }
  }

  function arrayRange(size, startAt = 0) {
    assert$g(size > 0, 'Expected non-zero, positive number as a range size');
    const result = new Array(size).fill(0);
    for (let i = 0; i < result.length; i++) {
      result[i] = i + startAt;
    }
    return result;
  }

  function isBoolean(value) {
    return typeof value === 'boolean';
  }

  function objectSpread(dest, ...sources) {
    for (let i = 0; i < sources.length; i++) {
      const src = sources[i];
      if (src) {
        const keys = Object.keys(src);
        for (let j = 0; j < keys.length; j++) {
          const key = keys[j];
          dest[key] = src[key];
        }
      }
    }
    return dest;
  }

  const HEX_REGEX = /^0x[a-fA-F0-9]+$/;
  function isHex(value, bitLength = -1, ignoreLength = false) {
    return typeof value === 'string' && (value === '0x' || HEX_REGEX.test(value)) ? bitLength === -1 ? value.length % 2 === 0 || ignoreLength : value.length === 2 + Math.ceil(bitLength / 4) : false;
  }

  function hexHasPrefix(value) {
    return !!(value && isHex(value, -1, true) && value.substr(0, 2) === '0x');
  }

  const UNPREFIX_HEX_REGEX = /^[a-fA-F0-9]+$/;
  function hexStripPrefix(value) {
    if (!value) {
      return '';
    } else if (hexHasPrefix(value)) {
      return value.substr(2);
    } else if (UNPREFIX_HEX_REGEX.test(value)) {
      return value;
    }
    throw new Error(`Invalid hex ${value} passed to hexStripPrefix`);
  }

  function reverse(value) {
    return (value.match(/.{1,2}/g) || []).reverse().join('');
  }
  function hexToBn(value, options = {
    isLe: false,
    isNegative: false
  }) {
    if (!value) {
      return new BN$8(0);
    }
    const _options = objectSpread({
      isLe: false,
      isNegative: false
    }, isBoolean(options) ? {
      isLe: options
    } : options);
    const _value = hexStripPrefix(value);
    const bn = new BN$8((_options.isLe ? reverse(_value) : _value) || '00', 16);
    return _options.isNegative ? bn.fromTwos(_value.length * 4) : bn;
  }

  function isBigInt(value) {
    return typeof value === 'bigint';
  }

  function isToBn(value) {
    return !!value && isFunction(value.toBn);
  }

  function bnToBn(value) {
    if (!value) {
      return new BN$8(0);
    } else if (isHex(value)) {
      return hexToBn(value.toString());
    } else if (isBigInt(value)) {
      return new BN$8(value.toString());
    }
    return BN$8.isBN(value) ? value : isToBn(value) ? value.toBn() : new BN$8(value);
  }

  function isNumber(value) {
    return typeof value === 'number';
  }

  function hexToU8a(_value, bitLength = -1) {
    if (!_value) {
      return new Uint8Array();
    }
    assert$g(isHex(_value), () => `Expected hex value to convert, found '${_value}'`);
    const value = hexStripPrefix(_value);
    const valLength = value.length / 2;
    const bufLength = Math.ceil(bitLength === -1 ? valLength : bitLength / 8);
    const result = new Uint8Array(bufLength);
    const offset = Math.max(0, bufLength - valLength);
    for (let index = 0; index < bufLength; index++) {
      result[index + offset] = parseInt(value.substr(index * 2, 2), 16);
    }
    return result;
  }

  function isBuffer(value) {
    return typeof Buffer !== 'undefined' && Buffer.isBuffer(value);
  }

  function isU8a(value) {
    return value instanceof Uint8Array;
  }

  const encoder = new TextEncoder();
  function stringToU8a(value) {
    return value ? encoder.encode(value.toString()) : new Uint8Array();
  }

  function u8aToU8a(value) {
    if (!value) {
      return new Uint8Array();
    } else if (isHex(value)) {
      return hexToU8a(value);
    } else if (isString(value)) {
      return stringToU8a(value);
    } else if (Array.isArray(value) || isBuffer(value)) {
      return new Uint8Array(value);
    }
    assert$g(isU8a(value), () => `Unable to convert ${value.toString()} (typeof ${typeof value}) to a Uint8Array`);
    return value;
  }

  function u8aConcat(...list) {
    let length = 0;
    let offset = 0;
    const u8as = new Array(list.length);
    for (let i = 0; i < list.length; i++) {
      u8as[i] = u8aToU8a(list[i]);
      length += u8as[i].length;
    }
    const result = new Uint8Array(length);
    for (let i = 0; i < u8as.length; i++) {
      result.set(u8as[i], offset);
      offset += u8as[i].length;
    }
    return result;
  }

  const ALPHABET = arrayRange(256).map(n => n.toString(16).padStart(2, '0'));
  function extract(value) {
    const result = new Array(value.length);
    for (let i = 0; i < value.length; i++) {
      result[i] = ALPHABET[value[i]];
    }
    return result.join('');
  }
  function unprefixed(value, bitLength = -1) {
    const byteLength = Math.ceil(bitLength / 8);
    return byteLength > 0 && value.length > byteLength ? trim(value, Math.ceil(byteLength / 2)) : extract(value);
  }
  function trim(value, halfLength) {
    return `${unprefixed(value.subarray(0, halfLength))}…${unprefixed(value.subarray(value.length - halfLength))}`;
  }
  function u8aToHex(value, bitLength = -1, isPrefixed = true) {
    return `${isPrefixed ? '0x' : ''}${!value || !value.length ? '' : unprefixed(value, bitLength)}`;
  }

  const decoder = new TextDecoder('utf-8');
  function u8aToString(value) {
    return !(value !== null && value !== void 0 && value.length) ? '' : decoder.decode(value);
  }

  function createEmpty(byteLength, options) {
    return options.bitLength === -1 ? new Uint8Array() : new Uint8Array(byteLength);
  }
  function createValue$1(valueBn, byteLength, {
    isLe,
    isNegative
  }) {
    const output = new Uint8Array(byteLength);
    const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
    output.set(bn.toArray(isLe ? 'le' : 'be', byteLength), 0);
    return output;
  }
  function bnToU8a(value, arg1 = {
    bitLength: -1,
    isLe: true,
    isNegative: false
  }, arg2) {
    const options = objectSpread({
      bitLength: -1,
      isLe: true,
      isNegative: false
    }, isNumber(arg1) ? {
      bitLength: arg1,
      isLe: arg2
    } : arg1);
    const valueBn = bnToBn(value);
    const byteLength = options.bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((options.bitLength || 0) / 8);
    return value ? createValue$1(valueBn, byteLength, options) : createEmpty(byteLength, options);
  }

  function bufferToU8a(buffer) {
    return new Uint8Array(buffer || []);
  }

  function getRandomValues(arr) {
    return crypto.getRandomValues(arr);
  }

  const asmJsInit = null;

  const CODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  const lookup = [];
  const revLookup = [];
  for (let i = 0; i < CODE.length; ++i) {
    lookup[i] = CODE[i];
    revLookup[CODE.charCodeAt(i)] = i;
  }
  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
  function getLens(b64) {
    const len = b64.length;
    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }
    const validLen = b64.indexOf('=');
    return validLen === -1 ? [len, 0] : [validLen, 4 - validLen % 4];
  }
  function toByteArray(b64) {
    const [validLen, placeHoldersLen] = getLens(b64);
    const arr = new Uint8Array((validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen);
    let curByte = 0;
    let i;
    let tmp;
    const len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    } else if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }
    return arr;
  }

  const sizeCompressed = 152872;
  const sizeUncompressed$1 = 300043;
  const bytes$1 = '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';
  var bytes_1 = { bytes: bytes$1, sizeCompressed, sizeUncompressed: sizeUncompressed$1 };

  const bytes = bytes_1.bytes;
  const sizeUncompressed = bytes_1.sizeUncompressed;

  const u8 = Uint8Array,
        u16 = Uint16Array,
        u32 = Uint32Array;
  const clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  const fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,
  0, 0,
  0]);
  const fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
  0, 0]);
  const freb = (eb, start) => {
    const b = new u16(31);
    for (let i = 0; i < 31; ++i) {
      b[i] = start += 1 << eb[i - 1];
    }
    const r = new u32(b[30]);
    for (let i = 1; i < 30; ++i) {
      for (let j = b[i]; j < b[i + 1]; ++j) {
        r[j] = j - b[i] << 5 | i;
      }
    }
    return [b, r];
  };
  const [fl, revfl] = freb(fleb, 2);
  fl[28] = 258, revfl[258] = 28;
  const [fd] = freb(fdeb, 0);
  const rev = new u16(32768);
  for (let i = 0; i < 32768; ++i) {
    let x = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;
    x = (x & 0xCCCC) >>> 2 | (x & 0x3333) << 2;
    x = (x & 0xF0F0) >>> 4 | (x & 0x0F0F) << 4;
    rev[i] = ((x & 0xFF00) >>> 8 | (x & 0x00FF) << 8) >>> 1;
  }
  const hMap = (cd, mb, r) => {
    const s = cd.length;
    let i = 0;
    const l = new u16(mb);
    for (; i < s; ++i) ++l[cd[i] - 1];
    const le = new u16(mb);
    for (i = 0; i < mb; ++i) {
      le[i] = le[i - 1] + l[i - 1] << 1;
    }
    let co;
    if (r) {
      co = new u16(1 << mb);
      const rvb = 15 - mb;
      for (i = 0; i < s; ++i) {
        if (cd[i]) {
          const sv = i << 4 | cd[i];
          const r = mb - cd[i];
          let v = le[cd[i] - 1]++ << r;
          for (const m = v | (1 << r) - 1; v <= m; ++v) {
            co[rev[v] >>> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s);
      for (i = 0; i < s; ++i) co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
    }
    return co;
  };
  const flt = new u8(288);
  for (let i = 0; i < 144; ++i) flt[i] = 8;
  for (let i = 144; i < 256; ++i) flt[i] = 9;
  for (let i = 256; i < 280; ++i) flt[i] = 7;
  for (let i = 280; i < 288; ++i) flt[i] = 8;
  const fdt = new u8(32);
  for (let i = 0; i < 32; ++i) fdt[i] = 5;
  const flrm = hMap(flt, 9, 1);
  const fdrm = hMap(fdt, 5, 1);
  const bits = (d, p, m) => {
    const o = p >>> 3;
    return (d[o] | d[o + 1] << 8) >>> (p & 7) & m;
  };
  const bits16 = (d, p) => {
    const o = p >>> 3;
    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >>> (p & 7);
  };
  const shft = p => (p >>> 3) + (p & 7 && 1);
  const slc = (v, s, e) => {
    if (s == null || s < 0) s = 0;
    if (e == null || e > v.length) e = v.length;
    const n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
    n.set(v.subarray(s, e));
    return n;
  };
  const max = a => {
    let m = a[0];
    for (let i = 1; i < a.length; ++i) {
      if (a[i] > m) m = a[i];
    }
    return m;
  };
  const inflt = (dat, buf, st) => {
    const noSt = !st || st.i;
    if (!st) st = {};
    const sl = dat.length;
    const noBuf = !buf || !noSt;
    if (!buf) buf = new u8(sl * 3);
    const cbuf = l => {
      let bl = buf.length;
      if (l > bl) {
        const nbuf = new u8(Math.max(bl << 1, l));
        nbuf.set(buf);
        buf = nbuf;
      }
    };
    let final = st.f || 0,
        pos = st.p || 0,
        bt = st.b || 0,
        lm = st.l,
        dm = st.d,
        lbt = st.m,
        dbt = st.n;
    if (final && !lm) return buf;
    const tbts = sl << 3;
    do {
      if (!lm) {
        st.f = final = bits(dat, pos, 1);
        const type = bits(dat, pos + 1, 3);
        pos += 3;
        if (!type) {
          const s = shft(pos) + 4,
                l = dat[s - 4] | dat[s - 3] << 8,
                t = s + l;
          if (t > sl) {
            if (noSt) throw 'unexpected EOF';
            break;
          }
          if (noBuf) cbuf(bt + l);
          buf.set(dat.subarray(s, t), bt);
          st.b = bt += l, st.p = pos = t << 3;
          continue;
        } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {
          const hLit = bits(dat, pos, 31) + 257,
                hcLen = bits(dat, pos + 10, 15) + 4;
          const tl = hLit + bits(dat, pos + 5, 31) + 1;
          pos += 14;
          const ldt = new u8(tl);
          const clt = new u8(19);
          for (let i = 0; i < hcLen; ++i) {
            clt[clim[i]] = bits(dat, pos + i * 3, 7);
          }
          pos += hcLen * 3;
          const clb = max(clt),
                clbmsk = (1 << clb) - 1;
          if (!noSt && pos + tl * (clb + 7) > tbts) break;
          const clm = hMap(clt, clb, 1);
          for (let i = 0; i < tl;) {
            const r = clm[bits(dat, pos, clbmsk)];
            pos += r & 15;
            const s = r >>> 4;
            if (s < 16) {
              ldt[i++] = s;
            } else {
              let c = 0,
                  n = 0;
              if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;
              while (n--) ldt[i++] = c;
            }
          }
          const lt = ldt.subarray(0, hLit),
                dt = ldt.subarray(hLit);
          lbt = max(lt);
          dbt = max(dt);
          lm = hMap(lt, lbt, 1);
          dm = hMap(dt, dbt, 1);
        } else throw 'invalid block type';
        if (pos > tbts) throw 'unexpected EOF';
      }
      if (noBuf) cbuf(bt + 131072);
      const lms = (1 << lbt) - 1,
            dms = (1 << dbt) - 1;
      const mxa = lbt + dbt + 18;
      while (noSt || pos + mxa < tbts) {
        const c = lm[bits16(dat, pos) & lms],
              sym = c >>> 4;
        pos += c & 15;
        if (pos > tbts) throw 'unexpected EOF';
        if (!c) throw 'invalid length/literal';
        if (sym < 256) buf[bt++] = sym;else if (sym == 256) {
          lm = undefined;
          break;
        } else {
          let add = sym - 254;
          if (sym > 264) {
            const i = sym - 257,
                  b = fleb[i];
            add = bits(dat, pos, (1 << b) - 1) + fl[i];
            pos += b;
          }
          const d = dm[bits16(dat, pos) & dms],
                dsym = d >>> 4;
          if (!d) throw 'invalid distance';
          pos += d & 15;
          let dt = fd[dsym];
          if (dsym > 3) {
            const b = fdeb[dsym];
            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
          }
          if (pos > tbts) throw 'unexpected EOF';
          if (noBuf) cbuf(bt + 131072);
          const end = bt + add;
          for (; bt < end; bt += 4) {
            buf[bt] = buf[bt - dt];
            buf[bt + 1] = buf[bt + 1 - dt];
            buf[bt + 2] = buf[bt + 2 - dt];
            buf[bt + 3] = buf[bt + 3 - dt];
          }
          bt = end;
        }
      }
      st.l = lm, st.p = pos, st.b = bt;
      if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
    } while (!final);
    return bt == buf.length ? buf : slc(buf, 0, bt);
  };
  const zlv = d => {
    if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';
    if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
  };
  function unzlibSync(data, out) {
    return inflt((zlv(data), data.subarray(2, -4)), out);
  }

  const wasmBytes = unzlibSync(toByteArray(bytes), new Uint8Array(sizeUncompressed));

  let wasm = null;
  let cachegetInt32 = null;
  let cachegetUint8 = null;
  async function initWasm(wasmBytes, asmFn, wbg) {
    try {
      assert$g(typeof WebAssembly !== 'undefined' && wasmBytes && wasmBytes.length, 'WebAssembly is not available in your environment');
      const source = await WebAssembly.instantiate(wasmBytes, {
        wbg
      });
      wasm = source.instance.exports;
    } catch (error) {
      if (asmFn) {
        wasm = asmFn(wbg);
      } else {
        console.error('FATAL: Unable to initialize @polkadot/wasm-crypto');
        console.error(error);
        wasm = null;
      }
    }
  }
  function withWasm(fn) {
    return (...params) => {
      assert$g(wasm, 'The WASM interface has not been initialized. Ensure that you wait for the initialization Promise with waitReady() from @polkadot/wasm-crypto (or cryptoWaitReady() from @polkadot/util-crypto) before attempting to use WASM-only interfaces.');
      return fn(wasm)(...params);
    };
  }
  function getWasm() {
    return wasm;
  }
  function getInt32() {
    if (cachegetInt32 === null || cachegetInt32.buffer !== wasm.memory.buffer) {
      cachegetInt32 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32;
  }
  function getUint8() {
    if (cachegetUint8 === null || cachegetUint8.buffer !== wasm.memory.buffer) {
      cachegetUint8 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8;
  }
  function getU8a(ptr, len) {
    return getUint8().subarray(ptr / 1, ptr / 1 + len);
  }
  function getString(ptr, len) {
    return u8aToString(getU8a(ptr, len));
  }
  function allocU8a(arg) {
    const ptr = wasm.__wbindgen_malloc(arg.length * 1);
    getUint8().set(arg, ptr / 1);
    return [ptr, arg.length];
  }
  function resultU8a() {
    const r0 = getInt32()[8 / 4 + 0];
    const r1 = getInt32()[8 / 4 + 1];
    const ret = getU8a(r0, r1).slice();
    wasm.__wbindgen_free(r0, r1 * 1);
    return ret;
  }

  const DEFAULT_CRYPTO = {
    getRandomValues
  };
  const DEFAULT_SELF = {
    crypto: DEFAULT_CRYPTO
  };
  const heap = new Array(32).fill(undefined).concat(undefined, null, true, false);
  let heapNext = heap.length;
  function getObject(idx) {
    return heap[idx];
  }
  function dropObject(idx) {
    if (idx < 36) {
      return;
    }
    heap[idx] = heapNext;
    heapNext = idx;
  }
  function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
  }
  function addObject(obj) {
    if (heapNext === heap.length) {
      heap.push(heap.length + 1);
    }
    const idx = heapNext;
    heapNext = heap[idx];
    heap[idx] = obj;
    return idx;
  }
  function __wbindgen_is_undefined(idx) {
    return getObject(idx) === undefined;
  }
  function __wbg_self_1b7a39e3a92c949c() {
    return addObject(DEFAULT_SELF);
  }
  function __wbg_require_604837428532a733(ptr, len) {
    throw new Error(`Unable to require ${getString(ptr, len)}`);
  }
  function __wbg_crypto_968f1772287e2df0(_idx) {
    return addObject(DEFAULT_CRYPTO);
  }
  function __wbg_getRandomValues_a3d34b4fee3c2869(_idx) {
    return addObject(DEFAULT_CRYPTO.getRandomValues);
  }
  function __wbg_getRandomValues_f5e14ab7ac8e995d(_arg0, ptr, len) {
    DEFAULT_CRYPTO.getRandomValues(getU8a(ptr, len));
  }
  function __wbg_randomFillSync_d5bd2d655fdf256a(_idx, _ptr, _len) {
    throw new Error('randomFillsync is not available');
  }
  function __wbindgen_object_drop_ref(idx) {
    takeObject(idx);
  }
  function abort() {
    throw new Error('abort');
  }

  const imports = /*#__PURE__*/Object.freeze({
    __proto__: null,
    __wbindgen_is_undefined: __wbindgen_is_undefined,
    __wbg_self_1b7a39e3a92c949c: __wbg_self_1b7a39e3a92c949c,
    __wbg_require_604837428532a733: __wbg_require_604837428532a733,
    __wbg_crypto_968f1772287e2df0: __wbg_crypto_968f1772287e2df0,
    __wbg_getRandomValues_a3d34b4fee3c2869: __wbg_getRandomValues_a3d34b4fee3c2869,
    __wbg_getRandomValues_f5e14ab7ac8e995d: __wbg_getRandomValues_f5e14ab7ac8e995d,
    __wbg_randomFillSync_d5bd2d655fdf256a: __wbg_randomFillSync_d5bd2d655fdf256a,
    __wbindgen_object_drop_ref: __wbindgen_object_drop_ref,
    abort: abort
  });

  initWasm(wasmBytes, asmJsInit, imports).catch(() => null);
  const blake2b$1 = withWasm(wasm => (data, key, size) => {
    const [ptr0, len0] = allocU8a(data);
    const [ptr1, len1] = allocU8a(key);
    wasm.ext_blake2b(8, ptr0, len0, ptr1, len1, size);
    return resultU8a();
  });
  const keccak256 = withWasm(wasm => data => {
    const [ptr0, len0] = allocU8a(data);
    wasm.ext_keccak256(8, ptr0, len0);
    return resultU8a();
  });
  const twox = withWasm(wasm => (data, rounds) => {
    const [ptr0, len0] = allocU8a(data);
    wasm.ext_twox(8, ptr0, len0, rounds);
    return resultU8a();
  });
  function isReady() {
    return !!getWasm();
  }

  var safeBuffer = {exports: {}};

  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  (function (module, exports) {
  var buffer = require$$0__default["default"];
  var Buffer = buffer.Buffer;
  function copyProps (src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer (arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length)
  }
  SafeBuffer.prototype = Object.create(Buffer.prototype);
  copyProps(Buffer, SafeBuffer);
  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
      throw new TypeError('Argument must not be a number')
    }
    return Buffer(arg, encodingOrOffset, length)
  };
  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
      if (typeof encoding === 'string') {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf
  };
  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return Buffer(size)
  };
  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
      throw new TypeError('Argument must be a number')
    }
    return buffer.SlowBuffer(size)
  };
  }(safeBuffer, safeBuffer.exports));

  var _Buffer = safeBuffer.exports.Buffer;
  function base$1 (ALPHABET) {
    if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode (source) {
      if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source); }
      if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }
      if (source.length === 0) { return '' }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i = 0;
        for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {
          carry += (256 * b58[it1]) >>> 0;
          b58[it1] = (carry % BASE) >>> 0;
          carry = (carry / BASE) >>> 0;
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }
      return str
    }
    function decodeUnsafe (source) {
      if (typeof source !== 'string') { throw new TypeError('Expected String') }
      if (source.length === 0) { return _Buffer.alloc(0) }
      var psz = 0;
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (((source.length - psz) * FACTOR) + 1) >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) { return }
        var i = 0;
        for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {
          carry += (BASE * b256[it3]) >>> 0;
          b256[it3] = (carry % 256) >>> 0;
          carry = (carry / 256) >>> 0;
        }
        if (carry !== 0) { throw new Error('Non-zero carry') }
        length = i;
        psz++;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));
      vch.fill(0x00, 0, zeroes);
      var j = zeroes;
      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }
      return vch
    }
    function decode (string) {
      var buffer = decodeUnsafe(string);
      if (buffer) { return buffer }
      throw new Error('Non-base' + BASE + ' character')
    }
    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    }
  }
  var src = base$1;
  const baseX = src;

  const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  const bs58 = baseX(BASE58_ALPHABET);

  function createValidateFn({
    alphabet,
    ipfsChar,
    type
  }) {
    return (value, ipfsCompat) => {
      assert$g(value && typeof value === 'string', () => `Expected non-null, non-empty ${type} string input`);
      assert$g(!ipfsCompat || value[0] === ipfsChar, () => `Expected ${type} to start with '${ipfsChar}'`);
      for (let i = ipfsCompat ? 1 : 0; i < value.length; i++) {
        assert$g(alphabet.includes(value[i]), () => `Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
      }
      return true;
    };
  }
  const base58Validate = createValidateFn({
    alphabet: BASE58_ALPHABET,
    ipfsChar: 'z',
    type: 'base58'
  });

  function base58Decode(value, ipfsCompat) {
    base58Validate(value, ipfsCompat);
    return bufferToU8a(bs58.decode(value.substr(ipfsCompat ? 1 : 0)));
  }

  const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array';
  function normalizeInput (input) {
    let ret;
    if (input instanceof Uint8Array) {
      ret = input;
    } else if (input instanceof Buffer) {
      ret = new Uint8Array(input);
    } else if (typeof input === 'string') {
      ret = new Uint8Array(Buffer.from(input, 'utf8'));
    } else {
      throw new Error(ERROR_MSG_INPUT)
    }
    return ret
  }
  function toHex$1 (bytes) {
    return Array.prototype.map
      .call(bytes, function (n) {
        return (n < 16 ? '0' : '') + n.toString(16)
      })
      .join('')
  }
  function uint32ToHex (val) {
    return (0x100000000 + val).toString(16).substring(1)
  }
  function debugPrint (label, arr, size) {
    let msg = '\n' + label + ' = ';
    for (let i = 0; i < arr.length; i += 2) {
      if (size === 32) {
        msg += uint32ToHex(arr[i]).toUpperCase();
        msg += ' ';
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
      } else if (size === 64) {
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
        msg += uint32ToHex(arr[i]).toUpperCase();
      } else throw new Error('Invalid size ' + size)
      if (i % 6 === 4) {
        msg += '\n' + new Array(label.length + 4).join(' ');
      } else if (i < arr.length - 2) {
        msg += ' ';
      }
    }
    console.log(msg);
  }
  function testSpeed (hashFn, N, M) {
    let startMs = new Date().getTime();
    const input = new Uint8Array(N);
    for (let i = 0; i < N; i++) {
      input[i] = i % 256;
    }
    const genMs = new Date().getTime();
    console.log('Generated random input in ' + (genMs - startMs) + 'ms');
    startMs = genMs;
    for (let i = 0; i < M; i++) {
      const hashHex = hashFn(input);
      const hashMs = new Date().getTime();
      const ms = hashMs - startMs;
      startMs = hashMs;
      console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...');
      console.log(
        Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'
      );
    }
  }
  var util$2 = {
    normalizeInput: normalizeInput,
    toHex: toHex$1,
    debugPrint: debugPrint,
    testSpeed: testSpeed
  };

  const util$1 = util$2;
  function ADD64AA (v, a, b) {
    const o0 = v[a] + v[b];
    let o1 = v[a + 1] + v[b + 1];
    if (o0 >= 0x100000000) {
      o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
  }
  function ADD64AC (v, a, b0, b1) {
    let o0 = v[a] + b0;
    if (b0 < 0) {
      o0 += 0x100000000;
    }
    let o1 = v[a + 1] + b1;
    if (o0 >= 0x100000000) {
      o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
  }
  function B2B_GET32 (arr, i) {
    return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
  }
  function B2B_G (a, b, c, d, ix, iy) {
    const x0 = m$1[ix];
    const x1 = m$1[ix + 1];
    const y0 = m$1[iy];
    const y1 = m$1[iy + 1];
    ADD64AA(v$1, a, b);
    ADD64AC(v$1, a, x0, x1);
    let xor0 = v$1[d] ^ v$1[a];
    let xor1 = v$1[d + 1] ^ v$1[a + 1];
    v$1[d] = xor1;
    v$1[d + 1] = xor0;
    ADD64AA(v$1, c, d);
    xor0 = v$1[b] ^ v$1[c];
    xor1 = v$1[b + 1] ^ v$1[c + 1];
    v$1[b] = (xor0 >>> 24) ^ (xor1 << 8);
    v$1[b + 1] = (xor1 >>> 24) ^ (xor0 << 8);
    ADD64AA(v$1, a, b);
    ADD64AC(v$1, a, y0, y1);
    xor0 = v$1[d] ^ v$1[a];
    xor1 = v$1[d + 1] ^ v$1[a + 1];
    v$1[d] = (xor0 >>> 16) ^ (xor1 << 16);
    v$1[d + 1] = (xor1 >>> 16) ^ (xor0 << 16);
    ADD64AA(v$1, c, d);
    xor0 = v$1[b] ^ v$1[c];
    xor1 = v$1[b + 1] ^ v$1[c + 1];
    v$1[b] = (xor1 >>> 31) ^ (xor0 << 1);
    v$1[b + 1] = (xor0 >>> 31) ^ (xor1 << 1);
  }
  const BLAKE2B_IV32 = new Uint32Array([
    0xf3bcc908,
    0x6a09e667,
    0x84caa73b,
    0xbb67ae85,
    0xfe94f82b,
    0x3c6ef372,
    0x5f1d36f1,
    0xa54ff53a,
    0xade682d1,
    0x510e527f,
    0x2b3e6c1f,
    0x9b05688c,
    0xfb41bd6b,
    0x1f83d9ab,
    0x137e2179,
    0x5be0cd19
  ]);
  const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ];
  const SIGMA82 = new Uint8Array(
    SIGMA8.map(function (x) {
      return x * 2
    })
  );
  const v$1 = new Uint32Array(32);
  const m$1 = new Uint32Array(32);
  function blake2bCompress (ctx, last) {
    let i = 0;
    for (i = 0; i < 16; i++) {
      v$1[i] = ctx.h[i];
      v$1[i + 16] = BLAKE2B_IV32[i];
    }
    v$1[24] = v$1[24] ^ ctx.t;
    v$1[25] = v$1[25] ^ (ctx.t / 0x100000000);
    if (last) {
      v$1[28] = ~v$1[28];
      v$1[29] = ~v$1[29];
    }
    for (i = 0; i < 32; i++) {
      m$1[i] = B2B_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 12; i++) {
      B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
      B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
      B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
      B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
      B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
      B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
      B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
      B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    for (i = 0; i < 16; i++) {
      ctx.h[i] = ctx.h[i] ^ v$1[i] ^ v$1[i + 16];
    }
  }
  function blake2bInit (outlen, key) {
    if (outlen === 0 || outlen > 64) {
      throw new Error('Illegal output length, expected 0 < length <= 64')
    }
    if (key && key.length > 64) {
      throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
    }
    const ctx = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0,
      c: 0,
      outlen: outlen
    };
    for (let i = 0; i < 16; i++) {
      ctx.h[i] = BLAKE2B_IV32[i];
    }
    const keylen = key ? key.length : 0;
    ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;
    if (key) {
      blake2bUpdate(ctx, key);
      ctx.c = 128;
    }
    return ctx
  }
  function blake2bUpdate (ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 128) {
        ctx.t += ctx.c;
        blake2bCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2bFinal (ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 128) {
      ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> (8 * (i & 3));
    }
    return out
  }
  function blake2b (input, key, outlen) {
    outlen = outlen || 64;
    input = util$1.normalizeInput(input);
    const ctx = blake2bInit(outlen, key);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx)
  }
  function blake2bHex (input, key, outlen) {
    const output = blake2b(input, key, outlen);
    return util$1.toHex(output)
  }
  var blake2b_1 = {
    blake2b: blake2b,
    blake2bHex: blake2bHex,
    blake2bInit: blake2bInit,
    blake2bUpdate: blake2bUpdate,
    blake2bFinal: blake2bFinal
  };

  const util = util$2;
  function B2S_GET32 (v, i) {
    return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)
  }
  function B2S_G (a, b, c, d, x, y) {
    v[a] = v[a] + v[b] + x;
    v[d] = ROTR32(v[d] ^ v[a], 16);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 12);
    v[a] = v[a] + v[b] + y;
    v[d] = ROTR32(v[d] ^ v[a], 8);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 7);
  }
  function ROTR32 (x, y) {
    return (x >>> y) ^ (x << (32 - y))
  }
  const BLAKE2S_IV = new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
  ]);
  const SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);
  const v = new Uint32Array(16);
  const m = new Uint32Array(16);
  function blake2sCompress (ctx, last) {
    let i = 0;
    for (i = 0; i < 8; i++) {
      v[i] = ctx.h[i];
      v[i + 8] = BLAKE2S_IV[i];
    }
    v[12] ^= ctx.t;
    v[13] ^= ctx.t / 0x100000000;
    if (last) {
      v[14] = ~v[14];
    }
    for (i = 0; i < 16; i++) {
      m[i] = B2S_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 10; i++) {
      B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
      B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
      B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
      B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
      B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
      B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
      B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
      B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
    }
    for (i = 0; i < 8; i++) {
      ctx.h[i] ^= v[i] ^ v[i + 8];
    }
  }
  function blake2sInit (outlen, key) {
    if (!(outlen > 0 && outlen <= 32)) {
      throw new Error('Incorrect output length, should be in [1, 32]')
    }
    const keylen = key ? key.length : 0;
    if (key && !(keylen > 0 && keylen <= 32)) {
      throw new Error('Incorrect key length, should be in [1, 32]')
    }
    const ctx = {
      h: new Uint32Array(BLAKE2S_IV),
      b: new Uint8Array(64),
      c: 0,
      t: 0,
      outlen: outlen
    };
    ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;
    if (keylen > 0) {
      blake2sUpdate(ctx, key);
      ctx.c = 64;
    }
    return ctx
  }
  function blake2sUpdate (ctx, input) {
    for (let i = 0; i < input.length; i++) {
      if (ctx.c === 64) {
        ctx.t += ctx.c;
        blake2sCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2sFinal (ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 64) {
      ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true);
    const out = new Uint8Array(ctx.outlen);
    for (let i = 0; i < ctx.outlen; i++) {
      out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xff;
    }
    return out
  }
  function blake2s (input, key, outlen) {
    outlen = outlen || 32;
    input = util.normalizeInput(input);
    const ctx = blake2sInit(outlen, key);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx)
  }
  function blake2sHex (input, key, outlen) {
    const output = blake2s(input, key, outlen);
    return util.toHex(output)
  }
  var blake2s_1 = {
    blake2s: blake2s,
    blake2sHex: blake2sHex,
    blake2sInit: blake2sInit,
    blake2sUpdate: blake2sUpdate,
    blake2sFinal: blake2sFinal
  };

  const b2b = blake2b_1;
  const b2s = blake2s_1;
  var blakejs = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
  };
  const js$1 = blakejs;

  function blake2AsU8a(data, bitLength = 256, key, onlyJs = false) {
    const byteLength = Math.ceil(bitLength / 8);
    return isReady() && !onlyJs ? blake2b$1(u8aToU8a(data), u8aToU8a(key), byteLength) : js$1.blake2b(u8aToU8a(data), key || undefined, byteLength);
  }

  const SS58_PREFIX = stringToU8a('SS58PRE');
  function sshash(key) {
    return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);
  }

  function checkAddressChecksum(decoded) {
    const ss58Length = decoded[0] & 0b01000000 ? 2 : 1;
    const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 0b00111111) << 2 | decoded[1] >> 6 | (decoded[1] & 0b00111111) << 8;
    const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
    const length = decoded.length - (isPublicKey ? 2 : 1);
    const hash = sshash(decoded.subarray(0, length));
    const isValid = (decoded[0] & 0b10000000) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);
    return [isValid, length, ss58Length, ss58Decoded];
  }

  const knownGenesis = {
    acala: ['0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c'],
    bifrost: ['0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed'],
    centrifuge: ['0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5'],
    'dock-mainnet': ['0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9'],
    edgeware: ['0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b'],
    equilibrium: ['0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925'],
    genshiro: ['0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243'],
    hydradx: ['0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc',
    '0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9',
    '0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047',
    '0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2'
    ],
    karura: ['0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b'],
    kulupu: ['0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba'],
    kusama: ['0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe',
    '0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636',
    '0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf'
    ],
    'nodle-chain': ['0xa3d114c2b8d0627c1aa9b134eafcf7d05ca561fdc19fb388bb9457f81809fb23'],
    plasm: ['0x3e86364d4b4894021cb2a0390bcf2feb5517d5292f2de2bb9404227e908b0b8b'],
    polkadot: ['0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3'],
    polymesh: ['0x9deeb940c92ae02111c3bd5baca89970384f4c9849f02a1b2e53e66414d30f9f'],
    stafi: ['0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80'],
    statemine: ['0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a'],
    subsocial: ['0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8']
  };
  const knownIcon = {
    centrifuge: 'polkadot',
    kusama: 'polkadot',
    polkadot: 'polkadot',
    statemine: 'polkadot',
    statemint: 'polkadot',
    westmint: 'polkadot'
  };
  const knownLedger = {
    centrifuge: 0x000002eb,
    'dock-mainnet': 0x00000252,
    edgeware: 0x0000020b,
    equilibrium: 0x05f5e0fd,
    genshiro: 0x05f5e0fc,
    kusama: 0x000001b2,
    'nodle-chain': 0x000003eb,
    polkadot: 0x00000162,
    polymesh: 0x00000253,
    statemine: 0x000001b2
  };
  const knownTestnet = {
    '': true,
    'cess-testnet': true,
    'dock-testnet': true,
    jupiter: true,
    'mathchain-testnet': true,
    'zero-alphaville': true
  };

  const knownSubstrate = [{
    decimals: [10],
    displayName: 'Polkadot Relay Chain',
    network: 'polkadot',
    prefix: 0,
    standardAccount: '*25519',
    symbols: ['DOT'],
    website: 'https://polkadot.network'
  }, {
    decimals: null,
    displayName: 'Bare 32-bit Schnorr/Ristretto (S/R 25519) public key.',
    network: 'BareSr25519',
    prefix: 1,
    standardAccount: 'Sr25519',
    symbols: null,
    website: null
  }, {
    decimals: [12],
    displayName: 'Kusama Relay Chain',
    network: 'kusama',
    prefix: 2,
    standardAccount: '*25519',
    symbols: ['KSM'],
    website: 'https://kusama.network'
  }, {
    decimals: null,
    displayName: 'Bare 32-bit Ed25519 public key.',
    network: 'BareEd25519',
    prefix: 3,
    standardAccount: 'Ed25519',
    symbols: null,
    website: null
  }, {
    decimals: null,
    displayName: 'Katal Chain',
    network: 'katalchain',
    prefix: 4,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [15],
    displayName: 'Plasm Network',
    network: 'plasm',
    prefix: 5,
    standardAccount: '*25519',
    symbols: ['PLM'],
    website: 'https://plasmnet.io'
  }, {
    decimals: [12],
    displayName: 'Bifrost',
    network: 'bifrost',
    prefix: 6,
    standardAccount: '*25519',
    symbols: ['BNC'],
    website: 'https://bifrost.finance/'
  }, {
    decimals: [18],
    displayName: 'Edgeware',
    network: 'edgeware',
    prefix: 7,
    standardAccount: '*25519',
    symbols: ['EDG'],
    website: 'https://edgewa.re'
  }, {
    decimals: [12],
    displayName: 'Karura',
    network: 'karura',
    prefix: 8,
    standardAccount: '*25519',
    symbols: ['KAR'],
    website: 'https://karura.network/'
  }, {
    decimals: [18],
    displayName: 'Laminar Reynolds Canary',
    network: 'reynolds',
    prefix: 9,
    standardAccount: '*25519',
    symbols: ['REY'],
    website: 'http://laminar.network/'
  }, {
    decimals: [12],
    displayName: 'Acala',
    network: 'acala',
    prefix: 10,
    standardAccount: '*25519',
    symbols: ['ACA'],
    website: 'https://acala.network/'
  }, {
    decimals: [18],
    displayName: 'Laminar',
    network: 'laminar',
    prefix: 11,
    standardAccount: '*25519',
    symbols: ['LAMI'],
    website: 'http://laminar.network/'
  }, {
    decimals: [6],
    displayName: 'Polymesh',
    network: 'polymesh',
    prefix: 12,
    standardAccount: '*25519',
    symbols: ['POLYX'],
    website: 'https://polymath.network/'
  }, {
    decimals: [12],
    displayName: 'Integritee',
    network: 'integritee',
    prefix: 13,
    standardAccount: '*25519',
    symbols: ['TEER'],
    website: 'https://integritee.network'
  }, {
    decimals: [0],
    displayName: 'Totem',
    network: 'totem',
    prefix: 14,
    standardAccount: '*25519',
    symbols: ['XTX'],
    website: 'https://totemaccounting.com'
  }, {
    decimals: [12],
    displayName: 'Synesthesia',
    network: 'synesthesia',
    prefix: 15,
    standardAccount: '*25519',
    symbols: ['SYN'],
    website: 'https://synesthesia.network/'
  }, {
    decimals: [12],
    displayName: 'Kulupu',
    network: 'kulupu',
    prefix: 16,
    standardAccount: '*25519',
    symbols: ['KLP'],
    website: 'https://kulupu.network/'
  }, {
    decimals: null,
    displayName: 'Dark Mainnet',
    network: 'dark',
    prefix: 17,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [9, 9],
    displayName: 'Darwinia Network',
    network: 'darwinia',
    prefix: 18,
    standardAccount: '*25519',
    symbols: ['RING', 'KTON'],
    website: 'https://darwinia.network/'
  }, {
    decimals: [12],
    displayName: 'GeekCash',
    network: 'geek',
    prefix: 19,
    standardAccount: '*25519',
    symbols: ['GEEK'],
    website: 'https://geekcash.org'
  }, {
    decimals: [12],
    displayName: 'Stafi',
    network: 'stafi',
    prefix: 20,
    standardAccount: '*25519',
    symbols: ['FIS'],
    website: 'https://stafi.io'
  }, {
    decimals: [6],
    displayName: 'Dock Testnet',
    network: 'dock-testnet',
    prefix: 21,
    standardAccount: '*25519',
    symbols: ['DCK'],
    website: 'https://dock.io'
  }, {
    decimals: [6],
    displayName: 'Dock Mainnet',
    network: 'dock-mainnet',
    prefix: 22,
    standardAccount: '*25519',
    symbols: ['DCK'],
    website: 'https://dock.io'
  }, {
    decimals: null,
    displayName: 'ShiftNrg',
    network: 'shift',
    prefix: 23,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [18],
    displayName: 'ZERO',
    network: 'zero',
    prefix: 24,
    standardAccount: '*25519',
    symbols: ['PLAY'],
    website: 'https://zero.io'
  }, {
    decimals: [18],
    displayName: 'ZERO Alphaville',
    network: 'zero-alphaville',
    prefix: 25,
    standardAccount: '*25519',
    symbols: ['PLAY'],
    website: 'https://zero.io'
  }, {
    decimals: [10],
    displayName: 'Jupiter',
    network: 'jupiter',
    prefix: 26,
    standardAccount: '*25519',
    symbols: ['jDOT'],
    website: 'https://jupiter.patract.io'
  }, {
    decimals: null,
    displayName: 'Subsocial',
    network: 'subsocial',
    prefix: 28,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [12, 12],
    displayName: 'CORD Network',
    network: 'cord',
    prefix: 29,
    standardAccount: '*25519',
    symbols: ['DHI', 'WAY'],
    website: 'https://cord.network/'
  }, {
    decimals: [12],
    displayName: 'Phala Network',
    network: 'phala',
    prefix: 30,
    standardAccount: '*25519',
    symbols: ['PHA'],
    website: 'https://phala.network'
  }, {
    decimals: [12],
    displayName: 'Litentry Network',
    network: 'litentry',
    prefix: 31,
    standardAccount: '*25519',
    symbols: ['LIT'],
    website: 'https://litentry.com/'
  }, {
    decimals: [9],
    displayName: 'Robonomics',
    network: 'robonomics',
    prefix: 32,
    standardAccount: '*25519',
    symbols: ['XRT'],
    website: 'https://robonomics.network'
  }, {
    decimals: null,
    displayName: 'DataHighway',
    network: 'datahighway',
    prefix: 33,
    standardAccount: '*25519',
    symbols: null,
    website: null
  }, {
    decimals: [12],
    displayName: 'Ares Protocol',
    network: 'ares',
    prefix: 34,
    standardAccount: '*25519',
    symbols: ['ARES'],
    website: 'https://www.aresprotocol.com/'
  }, {
    decimals: [15],
    displayName: 'Valiu Liquidity Network',
    network: 'vln',
    prefix: 35,
    standardAccount: '*25519',
    symbols: ['USDv'],
    website: 'https://valiu.com/'
  }, {
    decimals: [18],
    displayName: 'Centrifuge Chain',
    network: 'centrifuge',
    prefix: 36,
    standardAccount: '*25519',
    symbols: ['CFG'],
    website: 'https://centrifuge.io/'
  }, {
    decimals: [18],
    displayName: 'Nodle Chain',
    network: 'nodle',
    prefix: 37,
    standardAccount: '*25519',
    symbols: ['NODL'],
    website: 'https://nodle.io/'
  }, {
    decimals: [18],
    displayName: 'KILT Chain',
    network: 'kilt',
    prefix: 38,
    standardAccount: '*25519',
    symbols: ['KILT'],
    website: 'https://kilt.io/'
  }, {
    decimals: [18],
    displayName: 'MathChain mainnet',
    network: 'mathchain',
    prefix: 39,
    standardAccount: '*25519',
    symbols: ['MATH'],
    website: 'https://mathwallet.org'
  }, {
    decimals: [18],
    displayName: 'MathChain testnet',
    network: 'mathchain-testnet',
    prefix: 40,
    standardAccount: '*25519',
    symbols: ['MATH'],
    website: 'https://mathwallet.org'
  }, {
    decimals: null,
    displayName: 'Polimec Chain',
    network: 'poli',
    prefix: 41,
    standardAccount: '*25519',
    symbols: null,
    website: 'https://polimec.io/'
  }, {
    decimals: null,
    displayName: 'Substrate',
    network: 'substrate',
    prefix: 42,
    standardAccount: '*25519',
    symbols: null,
    website: 'https://substrate.io/'
  }, {
    decimals: null,
    displayName: 'Bare 32-bit ECDSA SECP-256k1 public key.',
    network: 'BareSecp256k1',
    prefix: 43,
    standardAccount: 'secp256k1',
    symbols: null,
    website: null
  }, {
    decimals: [8],
    displayName: 'ChainX',
    network: 'chainx',
    prefix: 44,
    standardAccount: '*25519',
    symbols: ['PCX'],
    website: 'https://chainx.org/'
  }, {
    decimals: [12, 12],
    displayName: 'UniArts Network',
    network: 'uniarts',
    prefix: 45,
    standardAccount: '*25519',
    symbols: ['UART', 'UINK'],
    website: 'https://uniarts.me'
  }, {
    decimals: null,
    displayName: 'This prefix is reserved.',
    network: 'reserved46',
    prefix: 46,
    standardAccount: null,
    symbols: null,
    website: null
  }, {
    decimals: null,
    displayName: 'This prefix is reserved.',
    network: 'reserved47',
    prefix: 47,
    standardAccount: null,
    symbols: null,
    website: null
  }, {
    decimals: [12],
    displayName: 'Neatcoin Mainnet',
    network: 'neatcoin',
    prefix: 48,
    standardAccount: '*25519',
    symbols: ['NEAT'],
    website: 'https://neatcoin.org'
  }, {
    decimals: [12],
    displayName: 'Picasso',
    network: 'picasso',
    prefix: 49,
    standardAccount: '*25519',
    symbols: ['PICA'],
    website: 'https://picasso.composable.finance'
  }, {
    decimals: [12],
    displayName: 'Composable',
    network: 'composable',
    prefix: 50,
    standardAccount: '*25519',
    symbols: ['LAYR'],
    website: 'https://composable.finance'
  }, {
    decimals: [12],
    displayName: 'HydraDX',
    network: 'hydradx',
    prefix: 63,
    standardAccount: '*25519',
    symbols: ['HDX'],
    website: 'https://hydradx.io'
  }, {
    decimals: [18],
    displayName: 'AvN Mainnet',
    network: 'aventus',
    prefix: 65,
    standardAccount: '*25519',
    symbols: ['AVT'],
    website: 'https://aventus.io'
  }, {
    decimals: [12],
    displayName: 'Crust Network',
    network: 'crust',
    prefix: 66,
    standardAccount: '*25519',
    symbols: ['CRU'],
    website: 'https://crust.network'
  }, {
    decimals: [0, 9, 9, 9, 9, 9, 9, 9],
    displayName: 'Equilibrium Network',
    network: 'equilibrium',
    prefix: 67,
    standardAccount: '*25519',
    symbols: ['Unknown', 'USD', 'EQ', 'ETH', 'BTC', 'EOS', 'DOT', 'CRV'],
    website: 'https://equilibrium.io'
  }, {
    decimals: [18],
    displayName: 'SORA Network',
    network: 'sora',
    prefix: 69,
    standardAccount: '*25519',
    symbols: ['XOR'],
    website: 'https://sora.org'
  }, {
    decimals: [10],
    displayName: 'Zeitgeist',
    network: 'zeitgeist',
    prefix: 73,
    standardAccount: '*25519',
    symbols: ['ZTG'],
    website: 'https://zeitgeist.pm'
  }, {
    decimals: [12],
    displayName: 'Manta network',
    network: 'manta',
    prefix: 77,
    standardAccount: '*25519',
    symbols: ['MA'],
    website: 'https://manta.network'
  }, {
    decimals: [12],
    displayName: 'Calamari: Manta Canary Network',
    network: 'calamari',
    prefix: 78,
    standardAccount: '*25519',
    symbols: ['KMA'],
    website: 'https://manta.network'
  }, {
    decimals: [12],
    displayName: 'Polkadex Mainnet',
    network: 'polkadex',
    prefix: 88,
    standardAccount: '*25519',
    symbols: ['PDEX'],
    website: 'https://polkadex.trade'
  }, {
    decimals: [18],
    displayName: 'PolkaSmith Canary Network',
    network: 'polkasmith',
    prefix: 98,
    standardAccount: '*25519',
    symbols: ['PKS'],
    website: 'https://polkafoundry.com'
  }, {
    decimals: [18],
    displayName: 'PolkaFoundry Network',
    network: 'polkafoundry',
    prefix: 99,
    standardAccount: '*25519',
    symbols: ['PKF'],
    website: 'https://polkafoundry.com'
  }, {
    decimals: [18],
    displayName: 'OriginTrail Parachain',
    network: 'origintrail-parachain',
    prefix: 101,
    standardAccount: 'secp256k1',
    symbols: ['TRAC'],
    website: 'https://origintrail.io'
  }, {
    decimals: [12],
    displayName: 'Heiko',
    network: 'heiko',
    prefix: 110,
    standardAccount: '*25519',
    symbols: ['HKO'],
    website: 'https://parallel.fi/'
  }, {
    decimals: null,
    displayName: 'Integritee Incognito',
    network: 'integritee-incognito',
    prefix: 113,
    standardAccount: '*25519',
    symbols: null,
    website: 'https://integritee.network'
  }, {
    decimals: [18],
    displayName: 'Clover Finance',
    network: 'clover',
    prefix: 128,
    standardAccount: '*25519',
    symbols: ['CLV'],
    website: 'https://clover.finance'
  }, {
    decimals: [18],
    displayName: 'Altair',
    network: 'altair',
    prefix: 136,
    standardAccount: '*25519',
    symbols: ['AIR'],
    website: 'https://centrifuge.io/'
  }, {
    decimals: [12],
    displayName: 'Parallel',
    network: 'parallel',
    prefix: 172,
    standardAccount: '*25519',
    symbols: ['PARA'],
    website: 'https://parallel.fi/'
  }, {
    decimals: [18],
    displayName: 'Social Network',
    network: 'social-network',
    prefix: 252,
    standardAccount: '*25519',
    symbols: ['NET'],
    website: 'https://social.network'
  }, {
    decimals: [15],
    displayName: 'QUARTZ by UNIQUE',
    network: 'quartz_mainnet',
    prefix: 255,
    standardAccount: '*25519',
    symbols: ['QTZ'],
    website: 'https://unique.network'
  }, {
    decimals: [18],
    displayName: 'Pioneer Network by Bit.Country',
    network: 'pioneer_network',
    prefix: 268,
    standardAccount: '*25519',
    symbols: ['NEER'],
    website: 'https://bit.country'
  }, {
    decimals: [18],
    displayName: 'Moonbeam',
    network: 'moonbeam',
    prefix: 1284,
    standardAccount: 'secp256k1',
    symbols: ['GLMR'],
    website: 'https://moonbeam.network'
  }, {
    decimals: [18],
    displayName: 'Moonriver',
    network: 'moonriver',
    prefix: 1285,
    standardAccount: 'secp256k1',
    symbols: ['MOVR'],
    website: 'https://moonbeam.network'
  }, {
    decimals: [12],
    displayName: 'Basilisk',
    network: 'basilisk',
    prefix: 10041,
    standardAccount: '*25519',
    symbols: ['BSX'],
    website: 'https://bsx.fi'
  }, {
    decimals: [12],
    displayName: 'CESS Testnet',
    network: 'cess-testnet',
    prefix: 10042,
    standardAccount: '*25519',
    symbols: ['TCESS'],
    website: 'https://cess.cloud'
  }, {
    decimals: [12],
    displayName: 'CESS',
    network: 'cess',
    prefix: 10043,
    standardAccount: '*25519',
    symbols: ['CESS'],
    website: 'https://cess.cloud'
  }, {
    decimals: [18],
    displayName: 'Automata ContextFree',
    network: 'contextfree',
    prefix: 11820,
    standardAccount: '*25519',
    symbols: ['CTX'],
    website: 'https://ata.network'
  }];

  const UNSORTED = [0, 2, 42];
  const TESTNETS = ['testnet'];
  function toExpanded(o) {
    const network = o.network || '';
    const nameParts = network.replace(/_/g, '-').split('-');
    const n = o;
    n.slip44 = knownLedger[network];
    n.hasLedgerSupport = !!n.slip44;
    n.genesisHash = knownGenesis[network] || [];
    n.icon = knownIcon[network] || 'substrate';
    n.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
    n.isIgnored = n.isTestnet || !(o.standardAccount && o.decimals && o.symbols) && o.prefix !== 42;
    return n;
  }
  function filterSelectable({
    genesisHash,
    prefix
  }) {
    return !!genesisHash.length || prefix === 42;
  }
  function filterAvailable(n) {
    return !n.isIgnored && !!n.network;
  }
  function sortNetworks(a, b) {
    const isUnSortedA = UNSORTED.includes(a.prefix);
    const isUnSortedB = UNSORTED.includes(b.prefix);
    return isUnSortedA === isUnSortedB ? 0 : isUnSortedA ? -1 : isUnSortedB ? 1 : a.displayName.localeCompare(b.displayName);
  }
  const allNetworks = knownSubstrate.map(toExpanded);
  const availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);
  availableNetworks.filter(filterSelectable);

  function networkToPrefix({
    prefix
  }) {
    return prefix;
  }
  const defaults = {
    allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
    allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
    allowedPrefix: availableNetworks.map(networkToPrefix),
    prefix: 42
  };

  function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
    assert$g(encoded, 'Invalid empty address passed');
    if (isU8a(encoded) || isHex(encoded)) {
      return u8aToU8a(encoded);
    }
    try {
      const decoded = base58Decode(encoded);
      assert$g(defaults.allowedEncodedLengths.includes(decoded.length), 'Invalid decoded address length');
      const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
      assert$g(ignoreChecksum || isValid, 'Invalid decoded address checksum');
      assert$g([-1, ss58Decoded].includes(ss58Format), () => `Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
      return decoded.slice(ss58Length, endPos);
    } catch (error) {
      throw new Error(`Decoding ${encoded}: ${error.message}`);
    }
  }

  var elliptic = {};

  var name = "elliptic";
  var version = "6.5.4";
  var description = "EC cryptography";
  var main = "lib/elliptic.js";
  var files = [
  	"lib"
  ];
  var scripts = {
  	lint: "eslint lib test",
  	"lint:fix": "npm run lint -- --fix",
  	unit: "istanbul test _mocha --reporter=spec test/index.js",
  	test: "npm run lint && npm run unit",
  	version: "grunt dist && git add dist/"
  };
  var repository = {
  	type: "git",
  	url: "git@github.com:indutny/elliptic"
  };
  var keywords = [
  	"EC",
  	"Elliptic",
  	"curve",
  	"Cryptography"
  ];
  var author = "Fedor Indutny <fedor@indutny.com>";
  var license = "MIT";
  var bugs = {
  	url: "https://github.com/indutny/elliptic/issues"
  };
  var homepage = "https://github.com/indutny/elliptic";
  var devDependencies = {
  	brfs: "^2.0.2",
  	coveralls: "^3.1.0",
  	eslint: "^7.6.0",
  	grunt: "^1.2.1",
  	"grunt-browserify": "^5.3.0",
  	"grunt-cli": "^1.3.2",
  	"grunt-contrib-connect": "^3.0.0",
  	"grunt-contrib-copy": "^1.0.0",
  	"grunt-contrib-uglify": "^5.0.0",
  	"grunt-mocha-istanbul": "^5.0.2",
  	"grunt-saucelabs": "^9.0.1",
  	istanbul: "^0.4.5",
  	mocha: "^8.0.1"
  };
  var dependencies = {
  	"bn.js": "^4.11.9",
  	brorand: "^1.1.0",
  	"hash.js": "^1.0.0",
  	"hmac-drbg": "^1.0.1",
  	inherits: "^2.0.4",
  	"minimalistic-assert": "^1.0.1",
  	"minimalistic-crypto-utils": "^1.0.1"
  };
  const require$$0 = {
  	name: name,
  	version: version,
  	description: description,
  	main: main,
  	files: files,
  	scripts: scripts,
  	repository: repository,
  	keywords: keywords,
  	author: author,
  	license: license,
  	bugs: bugs,
  	homepage: homepage,
  	devDependencies: devDependencies,
  	dependencies: dependencies
  };

  var utils$m = {};

  var minimalisticAssert = assert$f;
  function assert$f(val, msg) {
    if (!val)
      throw new Error(msg || 'Assertion failed');
  }
  assert$f.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
  };

  var utils$l = {};

  (function (exports) {
  var utils = exports;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== 'string') {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  utils.encode = function encode(arr, enc) {
    if (enc === 'hex')
      return toHex(arr);
    else
      return arr;
  };
  }(utils$l));

  (function (exports) {
  var utils = exports;
  var BN = bn.exports;
  var minAssert = minimalisticAssert;
  var minUtils = utils$l;
  utils.assert = minAssert;
  utils.toArray = minUtils.toArray;
  utils.zero2 = minUtils.zero2;
  utils.toHex = minUtils.toHex;
  utils.encode = minUtils.encode;
  function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << (w + 1);
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF;
  function getJSF(k1, k2) {
    var jsf = [
      [],
      [],
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = (k1.andln(3) + d1) & 3;
      var m24 = (k2.andln(3) + d2) & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = (k1.andln(7) + d1) & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = (k2.andln(7) + d2) & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF;
  function cachedProperty(obj, name, computer) {
    var key = '_' + name;
    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] :
        this[key] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
      bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new BN(bytes, 'hex', 'le');
  }
  utils.intFromLE = intFromLE;
  }(utils$m));

  var brorand = {exports: {}};

  var r$1;
  brorand.exports = function rand(len) {
    if (!r$1)
      r$1 = new Rand(null);
    return r$1.generate(len);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  brorand.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for (var i = 0; i < res.length; i++)
      res[i] = this.rand.getByte();
    return res;
  };
  if (typeof self === 'object') {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if (typeof window === 'object') {
      Rand.prototype._rand = function() {
        throw new Error('Not implemented yet');
      };
    }
  } else {
    try {
      var crypto$1 = require('crypto');
      if (typeof crypto$1.randomBytes !== 'function')
        throw new Error('Not supported');
      Rand.prototype._rand = function _rand(n) {
        return crypto$1.randomBytes(n);
      };
    } catch (e) {
    }
  }

  var curve = {};

  var BN$7 = bn.exports;
  var utils$k = utils$m;
  var getNAF = utils$k.getNAF;
  var getJSF = utils$k.getJSF;
  var assert$e = utils$k.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN$7(conf.p, 16);
    this.red = conf.prime ? BN$7.red(conf.prime) : BN$7.mont(this.p);
    this.zero = new BN$7(0).toRed(this.red);
    this.one = new BN$7(1).toRed(this.red);
    this.two = new BN$7(2).toRed(this.red);
    this.n = conf.n && new BN$7(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  var base = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error('Not implemented');
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error('Not implemented');
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert$e(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    var j;
    var nafW;
    for (j = 0; j < naf.length; j += doubles.step) {
      nafW = 0;
      for (var l = j + doubles.step - 1; l >= j; l--)
        nafW = (nafW << 1) + naf[l];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i = I; i > 0; i--) {
      for (j = 0; j < repr.length; j++) {
        nafW = repr[j];
        if (nafW === i)
          b = b.mixedAdd(doubles.points[j]);
        else if (nafW === -i)
          b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k, w, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1; i >= 0; i--) {
      for (var l = 0; i >= 0 && naf[i] === 0; i--)
        l++;
      if (i >= 0)
        l++;
      acc = acc.dblp(l);
      if (i < 0)
        break;
      var z = naf[i];
      assert$e(z !== 0);
      if (p.type === 'affine') {
        if (z > 0)
          acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
        else
          acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
      } else {
        if (z > 0)
          acc = acc.add(wnd[(z - 1) >> 1]);
        else
          acc = acc.add(wnd[(-z - 1) >> 1].neg());
      }
    }
    return p.type === 'affine' ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
    points,
    coeffs,
    len,
    jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    var i;
    var j;
    var p;
    for (i = 0; i < len; i++) {
      p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    for (i = len - 1; i >= 1; i -= 2) {
      var a = i - 1;
      var b = i;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }
      var comb = [
        points[a],
        null,
        null,
        points[b],
      ];
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
      var index = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3,
      ];
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);
      for (j = 0; j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (i = max; i >= 0; i--) {
      var k = 0;
      while (i >= 0) {
        var zero = true;
        for (j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k++;
        i--;
      }
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
      for (j = 0; j < len; j++) {
        var z = tmp[j];
        if (z === 0)
          continue;
        else if (z > 0)
          p = wnd[j][(z - 1) >> 1];
        else if (z < 0)
          p = wnd[j][(-z - 1) >> 1].neg();
        if (p.type === 'affine')
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    for (i = 0; i < len; i++)
      wnd[i] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error('Not implemented');
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils$k.toArray(bytes, enc);
    var len = this.p.byteLength();
    if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
        bytes.length - 1 === 2 * len) {
      if (bytes[0] === 0x06)
        assert$e(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 0x07)
        assert$e(bytes[bytes.length - 1] % 2 === 1);
      var res =  this.point(bytes.slice(1, 1 + len),
        bytes.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
                bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
    }
    throw new Error('Unknown point format');
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray('be', len);
    if (compact)
      return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);
    return [ 0x04 ].concat(x, this.getY().toArray('be', len));
  };
  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils$k.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null,
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [ this ];
    var acc = this;
    for (var i = 0; i < power; i += step) {
      for (var j = 0; j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step: step,
      points: doubles,
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [ this ];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i = 1; i < max; i++)
      res[i] = res[i - 1].add(dbl);
    return {
      wnd: wnd,
      points: res,
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i = 0; i < k; i++)
      r = r.dbl();
    return r;
  };

  var inherits_browser = {exports: {}};

  if (typeof Object.create === 'function') {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }

  var utils$j = utils$m;
  var BN$6 = bn.exports;
  var inherits$3 = inherits_browser.exports;
  var Base$2 = base;
  var assert$d = utils$j.assert;
  function ShortCurve(conf) {
    Base$2.call(this, 'short', conf);
    this.a = new BN$6(conf.a, 16).toRed(this.red);
    this.b = new BN$6(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits$3(ShortCurve, Base$2);
  var short = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN$6(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN$6(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert$d(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN$6(vec.a, 16),
          b: new BN$6(vec.b, 16),
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta: beta,
      lambda: lambda,
      basis: basis,
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : BN$6.mont(num);
    var tinv = new BN$6(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN$6(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [ l1, l2 ];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN$6(1);
    var y1 = new BN$6(0);
    var x2 = new BN$6(0);
    var y2 = new BN$6(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [
      { a: a1, b: b1 },
      { a: a2, b: b2 },
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return { k1: k1, k2: k2 };
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN$6(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd =
      function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split.k1.negative) {
            split.k1.ineg();
            p = p.neg(true);
          }
          if (split.k2.negative) {
            split.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split.k1;
          ncoeffs[i * 2 + 1] = split.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
  function Point$2(curve, x, y, isRed) {
    Base$2.BasePoint.call(this, curve, 'affine');
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN$6(x, 16);
      this.y = new BN$6(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits$3(Point$2, Base$2.BasePoint);
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point$2(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point$2.fromJSON(this, obj, red);
  };
  Point$2.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul),
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul),
        },
      };
    }
    return beta;
  };
  Point$2.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [ this.x, this.y ];
    return [ this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1),
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1),
      },
    } ];
  };
  Point$2.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === 'string')
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj) {
      return curve.point(obj[0], obj[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [ res ].concat(pre.doubles.points.map(obj2point)),
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [ res ].concat(pre.naf.points.map(obj2point)),
      },
    };
    return res;
  };
  Point$2.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' y: ' + this.y.fromRed().toString(16, 2) + '>';
  };
  Point$2.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point$2.prototype.add = function add(p) {
    if (this.inf)
      return p;
    if (p.inf)
      return this;
    if (this.eq(p))
      return this.dbl();
    if (this.neg().eq(p))
      return this.curve.point(null, null);
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point$2.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point$2.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point$2.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point$2.prototype.mul = function mul(k) {
    k = new BN$6(k, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([ this ], [ k ]);
    else
      return this.curve._wnafMul(this, k);
  };
  Point$2.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [ this, p2 ];
    var coeffs = [ k1, k2 ];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point$2.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [ this, p2 ];
    var coeffs = [ k1, k2 ];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point$2.prototype.eq = function eq(p) {
    return this === p ||
           this.inf === p.inf &&
               (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  Point$2.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate),
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate),
        },
      };
    }
    return res;
  };
  Point$2.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve, x, y, z) {
    Base$2.BasePoint.call(this, curve, 'jacobian');
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN$6(0);
    } else {
      this.x = new BN$6(x, 16);
      this.y = new BN$6(y, 16);
      this.z = new BN$6(z, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits$3(JPoint, Base$2.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    if (this.isInfinity())
      return p.toJ();
    if (p.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    var i;
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (i = 0; i < pow; i++)
        r = r.dbl();
      return r;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (i = 0; i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t = m.redSqr().redISub(s).redISub(s);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = b.redSqr();
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t = m.redSqr().redISub(s).redISub(s);
      nx = t;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN$6(k, kbase);
    return this.curve._wnafMul(this, k);
  };
  JPoint.prototype.eq = function eq(p) {
    if (p.type === 'affine')
      return this.eq(p.toJ());
    if (this === p)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC JPoint Infinity>';
    return '<EC JPoint x: ' + this.x.toString(16, 2) +
        ' y: ' + this.y.toString(16, 2) +
        ' z: ' + this.z.toString(16, 2) + '>';
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };

  var BN$5 = bn.exports;
  var inherits$2 = inherits_browser.exports;
  var Base$1 = base;
  var utils$i = utils$m;
  function MontCurve(conf) {
    Base$1.call(this, 'mont', conf);
    this.a = new BN$5(conf.a, 16).toRed(this.red);
    this.b = new BN$5(conf.b, 16).toRed(this.red);
    this.i4 = new BN$5(4).toRed(this.red).redInvm();
    this.two = new BN$5(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits$2(MontCurve, Base$1);
  var mont = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  function Point$1(curve, x, z) {
    Base$1.BasePoint.call(this, curve, 'projective');
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN$5(x, 16);
      this.z = new BN$5(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits$2(Point$1, Base$1.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils$i.toArray(bytes, enc), 1);
  };
  MontCurve.prototype.point = function point(x, z) {
    return new Point$1(this, x, z);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point$1.fromJSON(this, obj);
  };
  Point$1.prototype.precompute = function precompute() {
  };
  Point$1.prototype._encode = function _encode() {
    return this.getX().toArray('be', this.curve.p.byteLength());
  };
  Point$1.fromJSON = function fromJSON(curve, obj) {
    return new Point$1(curve, obj[0], obj[1] || curve.one);
  };
  Point$1.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  Point$1.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point$1.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b = this.x.redSub(this.z);
    var bb = b.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point$1.prototype.add = function add() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point$1.prototype.diffAdd = function diffAdd(p, diff) {
    var a = this.x.redAdd(this.z);
    var b = this.x.redSub(this.z);
    var c = p.x.redAdd(p.z);
    var d = p.x.redSub(p.z);
    var da = d.redMul(a);
    var cb = c.redMul(b);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point$1.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this;
    var b = this.curve.point(null, null);
    var c = this;
    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
      bits.push(t.andln(1));
    for (var i = bits.length - 1; i >= 0; i--) {
      if (bits[i] === 0) {
        a = a.diffAdd(b, c);
        b = b.dbl();
      } else {
        b = a.diffAdd(b, c);
        a = a.dbl();
      }
    }
    return b;
  };
  Point$1.prototype.mulAdd = function mulAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point$1.prototype.jumlAdd = function jumlAdd() {
    throw new Error('Not supported on Montgomery curve');
  };
  Point$1.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point$1.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point$1.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };

  var utils$h = utils$m;
  var BN$4 = bn.exports;
  var inherits$1 = inherits_browser.exports;
  var Base = base;
  var assert$c = utils$h.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, 'edwards', conf);
    this.a = new BN$4(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN$4(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN$4(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert$c(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits$1(EdwardsCurve, Base);
  var edwards = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN$4(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN$4(y, 16);
    if (!y.red)
      y = y.toRed(this.red);
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error('invalid point');
      else
        return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error('invalid point');
    if (x.fromRed().isOdd() !== odd)
      x = x.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };
  function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, 'projective');
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN$4(x, 16);
      this.y = new BN$4(y, 16);
      this.z = z ? new BN$4(z, 16) : this.curve.one;
      this.t = t && new BN$4(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits$1(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return '<EC Point Infinity>';
    return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
        ' y: ' + this.y.fromRed().toString(16, 2) +
        ' z: ' + this.z.fromRed().toString(16, 2) + '>';
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 &&
      (this.y.cmp(this.z) === 0 ||
      (this.zOne && this.y.cmp(this.curve.c) === 0));
  };
  Point.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    var g = d.redAdd(b);
    var f = g.redSub(c);
    var h = d.redSub(b);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    var e;
    var h;
    var j;
    if (this.curve.twisted) {
      e = this.curve._mulA(c);
      var f = e.redAdd(d);
      if (this.zOne) {
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        ny = f.redMul(e.redSub(d));
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        h = this.z.redSqr();
        j = f.redSub(h).redISub(h);
        nx = b.redSub(c).redISub(d).redMul(j);
        ny = f.redMul(e.redSub(d));
        nz = f.redMul(j);
      }
    } else {
      e = c.redAdd(d);
      h = this.curve._mulC(this.z).redSqr();
      j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p) {
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    var d = this.z.redMul(p.z.redAdd(p.z));
    var e = b.redSub(a);
    var f = d.redSub(c);
    var g = d.redAdd(c);
    var h = b.redAdd(a);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p) {
    var a = this.z.redMul(p.z);
    var b = a.redSqr();
    var c = this.x.redMul(p.x);
    var d = this.y.redMul(p.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f = b.redSub(e);
    var g = b.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      nz = f.redMul(g);
    } else {
      ny = a.redMul(g).redMul(d.redSub(c));
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };
  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
  };
  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg());
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other ||
           this.getX().cmp(other.getX()) === 0 &&
           this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (;;) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;

  (function (exports) {
  var curve = exports;
  curve.base = base;
  curve.short = short;
  curve.mont = mont;
  curve.edwards = edwards;
  }(curve));

  var curves$2 = {};

  var hash$2 = {};

  var utils$g = {};

  var assert$b = minimalisticAssert;
  var inherits = inherits_browser.exports;
  utils$g.inherits = inherits;
  function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
      return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === 'string') {
      if (!enc) {
        var p = 0;
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = (c >> 6) | 192;
            res[p++] = (c & 63) | 128;
          } else if (isSurrogatePair(msg, i)) {
            c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
            res[p++] = (c >> 18) | 240;
            res[p++] = ((c >> 12) & 63) | 128;
            res[p++] = ((c >> 6) & 63) | 128;
            res[p++] = (c & 63) | 128;
          } else {
            res[p++] = (c >> 12) | 224;
            res[p++] = ((c >> 6) & 63) | 128;
            res[p++] = (c & 63) | 128;
          }
        }
      } else if (enc === 'hex') {
        msg = msg.replace(/[^a-z0-9]+/ig, '');
        if (msg.length % 2 !== 0)
          msg = '0' + msg;
        for (i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  }
  utils$g.toArray = toArray;
  function toHex(msg) {
    var res = '';
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils$g.toHex = toHex;
  function htonl(w) {
    var res = (w >>> 24) |
              ((w >>> 8) & 0xff00) |
              ((w << 8) & 0xff0000) |
              ((w & 0xff) << 24);
    return res >>> 0;
  }
  utils$g.htonl = htonl;
  function toHex32(msg, endian) {
    var res = '';
    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === 'little')
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  utils$g.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return '0' + word;
    else
      return word;
  }
  utils$g.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return '0' + word;
    else if (word.length === 6)
      return '00' + word;
    else if (word.length === 5)
      return '000' + word;
    else if (word.length === 4)
      return '0000' + word;
    else if (word.length === 3)
      return '00000' + word;
    else if (word.length === 2)
      return '000000' + word;
    else if (word.length === 1)
      return '0000000' + word;
    else
      return word;
  }
  utils$g.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert$b(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === 'big')
        w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
      else
        w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  }
  utils$g.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === 'big') {
        res[k] = m >>> 24;
        res[k + 1] = (m >>> 16) & 0xff;
        res[k + 2] = (m >>> 8) & 0xff;
        res[k + 3] = m & 0xff;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = (m >>> 16) & 0xff;
        res[k + 1] = (m >>> 8) & 0xff;
        res[k] = m & 0xff;
      }
    }
    return res;
  }
  utils$g.split32 = split32;
  function rotr32$1(w, b) {
    return (w >>> b) | (w << (32 - b));
  }
  utils$g.rotr32 = rotr32$1;
  function rotl32$2(w, b) {
    return (w << b) | (w >>> (32 - b));
  }
  utils$g.rotl32 = rotl32$2;
  function sum32$3(a, b) {
    return (a + b) >>> 0;
  }
  utils$g.sum32 = sum32$3;
  function sum32_3$1(a, b, c) {
    return (a + b + c) >>> 0;
  }
  utils$g.sum32_3 = sum32_3$1;
  function sum32_4$2(a, b, c, d) {
    return (a + b + c + d) >>> 0;
  }
  utils$g.sum32_4 = sum32_4$2;
  function sum32_5$2(a, b, c, d, e) {
    return (a + b + c + d + e) >>> 0;
  }
  utils$g.sum32_5 = sum32_5$2;
  function sum64$1(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  utils$g.sum64 = sum64$1;
  function sum64_hi$1(ah, al, bh, bl) {
    var lo = (al + bl) >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  utils$g.sum64_hi = sum64_hi$1;
  function sum64_lo$1(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  utils$g.sum64_lo = sum64_lo$1;
  function sum64_4_hi$1(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  utils$g.sum64_4_hi = sum64_4_hi$1;
  function sum64_4_lo$1(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  utils$g.sum64_4_lo = sum64_4_lo$1;
  function sum64_5_hi$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = (lo + bl) >>> 0;
    carry += lo < al ? 1 : 0;
    lo = (lo + cl) >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = (lo + dl) >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = (lo + el) >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  utils$g.sum64_5_hi = sum64_5_hi$1;
  function sum64_5_lo$1(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  utils$g.sum64_5_lo = sum64_5_lo$1;
  function rotr64_hi$1(ah, al, num) {
    var r = (al << (32 - num)) | (ah >>> num);
    return r >>> 0;
  }
  utils$g.rotr64_hi = rotr64_hi$1;
  function rotr64_lo$1(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  utils$g.rotr64_lo = rotr64_lo$1;
  function shr64_hi$1(ah, al, num) {
    return ah >>> num;
  }
  utils$g.shr64_hi = shr64_hi$1;
  function shr64_lo$1(ah, al, num) {
    var r = (ah << (32 - num)) | (al >>> num);
    return r >>> 0;
  }
  utils$g.shr64_lo = shr64_lo$1;

  var common$5 = {};

  var utils$f = utils$g;
  var assert$a = minimalisticAssert;
  function BlockHash$4() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  common$5.BlockHash = BlockHash$4;
  BlockHash$4.prototype.update = function update(msg, enc) {
    msg = utils$f.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils$f.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0; i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }
    return this;
  };
  BlockHash$4.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert$a(this.pending === null);
    return this._digest(enc);
  };
  BlockHash$4.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - ((len + this.padLength) % bytes);
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for (var i = 1; i < k; i++)
      res[i] = 0;
    len <<= 3;
    if (this.endian === 'big') {
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = len & 0xff;
    } else {
      res[i++] = len & 0xff;
      res[i++] = (len >>> 8) & 0xff;
      res[i++] = (len >>> 16) & 0xff;
      res[i++] = (len >>> 24) & 0xff;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (t = 8; t < this.padLength; t++)
        res[i++] = 0;
    }
    return res;
  };

  var sha = {};

  var common$4 = {};

  var utils$e = utils$g;
  var rotr32 = utils$e.rotr32;
  function ft_1$1(s, x, y, z) {
    if (s === 0)
      return ch32$1(x, y, z);
    if (s === 1 || s === 3)
      return p32(x, y, z);
    if (s === 2)
      return maj32$1(x, y, z);
  }
  common$4.ft_1 = ft_1$1;
  function ch32$1(x, y, z) {
    return (x & y) ^ ((~x) & z);
  }
  common$4.ch32 = ch32$1;
  function maj32$1(x, y, z) {
    return (x & y) ^ (x & z) ^ (y & z);
  }
  common$4.maj32 = maj32$1;
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  common$4.p32 = p32;
  function s0_256$1(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  common$4.s0_256 = s0_256$1;
  function s1_256$1(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  common$4.s1_256 = s1_256$1;
  function g0_256$1(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
  }
  common$4.g0_256 = g0_256$1;
  function g1_256$1(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
  }
  common$4.g1_256 = g1_256$1;

  var utils$d = utils$g;
  var common$3 = common$5;
  var shaCommon$1 = common$4;
  var rotl32$1 = utils$d.rotl32;
  var sum32$2 = utils$d.sum32;
  var sum32_5$1 = utils$d.sum32_5;
  var ft_1 = shaCommon$1.ft_1;
  var BlockHash$3 = common$3.BlockHash;
  var sha1_K = [
    0x5A827999, 0x6ED9EBA1,
    0x8F1BBCDC, 0xCA62C1D6
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash$3.call(this);
    this.h = [
      0x67452301, 0xefcdab89, 0x98badcfe,
      0x10325476, 0xc3d2e1f0 ];
    this.W = new Array(80);
  }
  utils$d.inherits(SHA1, BlockHash$3);
  var _1 = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for(; i < W.length; i++)
      W[i] = rotl32$1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5$1(rotl32$1(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32$1(b, 30);
      b = a;
      a = t;
    }
    this.h[0] = sum32$2(this.h[0], a);
    this.h[1] = sum32$2(this.h[1], b);
    this.h[2] = sum32$2(this.h[2], c);
    this.h[3] = sum32$2(this.h[3], d);
    this.h[4] = sum32$2(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$d.toHex32(this.h, 'big');
    else
      return utils$d.split32(this.h, 'big');
  };

  var utils$c = utils$g;
  var common$2 = common$5;
  var shaCommon = common$4;
  var assert$9 = minimalisticAssert;
  var sum32$1 = utils$c.sum32;
  var sum32_4$1 = utils$c.sum32_4;
  var sum32_5 = utils$c.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash$2 = common$2.BlockHash;
  var sha256_K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
  ];
  function SHA256$1() {
    if (!(this instanceof SHA256$1))
      return new SHA256$1();
    BlockHash$2.call(this);
    this.h = [
      0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
      0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils$c.inherits(SHA256$1, BlockHash$2);
  var _256 = SHA256$1;
  SHA256$1.blockSize = 512;
  SHA256$1.outSize = 256;
  SHA256$1.hmacStrength = 192;
  SHA256$1.padLength = 64;
  SHA256$1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = sum32_4$1(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert$9(this.k.length === W.length);
    for (i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32$1(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32$1(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32$1(T1, T2);
    }
    this.h[0] = sum32$1(this.h[0], a);
    this.h[1] = sum32$1(this.h[1], b);
    this.h[2] = sum32$1(this.h[2], c);
    this.h[3] = sum32$1(this.h[3], d);
    this.h[4] = sum32$1(this.h[4], e);
    this.h[5] = sum32$1(this.h[5], f);
    this.h[6] = sum32$1(this.h[6], g);
    this.h[7] = sum32$1(this.h[7], h);
  };
  SHA256$1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$c.toHex32(this.h, 'big');
    else
      return utils$c.split32(this.h, 'big');
  };

  var utils$b = utils$g;
  var SHA256 = _256;
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [
      0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
      0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
  }
  utils$b.inherits(SHA224, SHA256);
  var _224 = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$b.toHex32(this.h.slice(0, 7), 'big');
    else
      return utils$b.split32(this.h.slice(0, 7), 'big');
  };

  var utils$a = utils$g;
  var common$1 = common$5;
  var assert$8 = minimalisticAssert;
  var rotr64_hi = utils$a.rotr64_hi;
  var rotr64_lo = utils$a.rotr64_lo;
  var shr64_hi = utils$a.shr64_hi;
  var shr64_lo = utils$a.shr64_lo;
  var sum64 = utils$a.sum64;
  var sum64_hi = utils$a.sum64_hi;
  var sum64_lo = utils$a.sum64_lo;
  var sum64_4_hi = utils$a.sum64_4_hi;
  var sum64_4_lo = utils$a.sum64_4_lo;
  var sum64_5_hi = utils$a.sum64_5_hi;
  var sum64_5_lo = utils$a.sum64_5_lo;
  var BlockHash$1 = common$1.BlockHash;
  var sha512_K = [
    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
  ];
  function SHA512$1() {
    if (!(this instanceof SHA512$1))
      return new SHA512$1();
    BlockHash$1.call(this);
    this.h = [
      0x6a09e667, 0xf3bcc908,
      0xbb67ae85, 0x84caa73b,
      0x3c6ef372, 0xfe94f82b,
      0xa54ff53a, 0x5f1d36f1,
      0x510e527f, 0xade682d1,
      0x9b05688c, 0x2b3e6c1f,
      0x1f83d9ab, 0xfb41bd6b,
      0x5be0cd19, 0x137e2179 ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils$a.inherits(SHA512$1, BlockHash$1);
  var _512 = SHA512$1;
  SHA512$1.blockSize = 1024;
  SHA512$1.outSize = 512;
  SHA512$1.hmacStrength = 192;
  SHA512$1.padLength = 128;
  SHA512$1.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i = 0; i < 32; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];
      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo);
    }
  };
  SHA512$1.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert$8(this.k.length === W.length);
    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo,
        c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(
        c0_hi, c0_lo,
        c1_hi, c1_lo,
        c2_hi, c2_lo,
        c3_hi, c3_lo,
        c4_hi, c4_lo);
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512$1.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$a.toHex32(this.h, 'big');
    else
      return utils$a.split32(this.h, 'big');
  };
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r = (xh & yh) ^ ((~xh) & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ ((~xl) & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 0x100000000;
    return r;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 0x100000000;
    return r;
  }

  var utils$9 = utils$g;
  var SHA512 = _512;
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [
      0xcbbb9d5d, 0xc1059ed8,
      0x629a292a, 0x367cd507,
      0x9159015a, 0x3070dd17,
      0x152fecd8, 0xf70e5939,
      0x67332667, 0xffc00b31,
      0x8eb44a87, 0x68581511,
      0xdb0c2e0d, 0x64f98fa7,
      0x47b5481d, 0xbefa4fa4 ];
  }
  utils$9.inherits(SHA384, SHA512);
  var _384 = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$9.toHex32(this.h.slice(0, 12), 'big');
    else
      return utils$9.split32(this.h.slice(0, 12), 'big');
  };

  sha.sha1 = _1;
  sha.sha224 = _224;
  sha.sha256 = _256;
  sha.sha384 = _384;
  sha.sha512 = _512;

  var ripemd = {};

  var utils$8 = utils$g;
  var common = common$5;
  var rotl32 = utils$8.rotl32;
  var sum32 = utils$8.sum32;
  var sum32_3 = utils$8.sum32_3;
  var sum32_4 = utils$8.sum32_4;
  var BlockHash = common.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
    this.endian = 'little';
  }
  utils$8.inherits(RIPEMD160, BlockHash);
  ripemd.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(
        rotl32(
          sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
          s[j]),
        E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(
        rotl32(
          sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
          sh[j]),
        Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === 'hex')
      return utils$8.toHex32(this.h, 'little');
    else
      return utils$8.split32(this.h, 'little');
  };
  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return (x & y) | ((~x) & z);
    else if (j <= 47)
      return (x | (~y)) ^ z;
    else if (j <= 63)
      return (x & z) | (y & (~z));
    else
      return x ^ (y | (~z));
  }
  function K(j) {
    if (j <= 15)
      return 0x00000000;
    else if (j <= 31)
      return 0x5a827999;
    else if (j <= 47)
      return 0x6ed9eba1;
    else if (j <= 63)
      return 0x8f1bbcdc;
    else
      return 0xa953fd4e;
  }
  function Kh(j) {
    if (j <= 15)
      return 0x50a28be6;
    else if (j <= 31)
      return 0x5c4dd124;
    else if (j <= 47)
      return 0x6d703ef3;
    else if (j <= 63)
      return 0x7a6d76e9;
    else
      return 0x00000000;
  }
  var r = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
    3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
    1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
  ];
  var rh = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
    6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
    15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
    8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
    12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
  ];
  var s = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
    7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
    11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
    11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
    9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
  ];
  var sh = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
    9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
    9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
    15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
    8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
  ];

  var utils$7 = utils$g;
  var assert$7 = minimalisticAssert;
  function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils$7.toArray(key, enc));
  }
  var hmac = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert$7(key.length <= this.blockSize);
    for (var i = key.length; i < this.blockSize; i++)
      key.push(0);
    for (i = 0; i < key.length; i++)
      key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    for (i = 0; i < key.length; i++)
      key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };

  (function (exports) {
  var hash = exports;
  hash.utils = utils$g;
  hash.common = common$5;
  hash.sha = sha;
  hash.ripemd = ripemd;
  hash.hmac = hmac;
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
  }(hash$2));

  (function (exports) {
  var curves = exports;
  var hash = hash$2;
  var curve$1 = curve;
  var utils = utils$m;
  var assert = utils.assert;
  function PresetCurve(options) {
    if (options.type === 'short')
      this.curve = new curve$1.short(options);
    else if (options.type === 'edwards')
      this.curve = new curve$1.edwards(options);
    else
      this.curve = new curve$1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), 'Invalid curve');
    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve,
        });
        return curve;
      },
    });
  }
  defineCurve('p192', {
    type: 'short',
    prime: 'p192',
    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    hash: hash.sha256,
    gRed: false,
    g: [
      '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
      '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
    ],
  });
  defineCurve('p224', {
    type: 'short',
    prime: 'p224',
    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    hash: hash.sha256,
    gRed: false,
    g: [
      'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
      'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
    ],
  });
  defineCurve('p256', {
    type: 'short',
    prime: null,
    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    hash: hash.sha256,
    gRed: false,
    g: [
      '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
      '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
    ],
  });
  defineCurve('p384', {
    type: 'short',
    prime: null,
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'fffffffe ffffffff 00000000 00000000 ffffffff',
    a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'fffffffe ffffffff 00000000 00000000 fffffffc',
    b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
       '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
    n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
       'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
    hash: hash.sha384,
    gRed: false,
    g: [
      'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
      '5502f25d bf55296c 3a545e38 72760ab7',
      '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
      '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
    ],
  });
  defineCurve('p521', {
    type: 'short',
    prime: null,
    p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff',
    a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff ffffffff ffffffff fffffffc',
    b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
       '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
       '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
    n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
       'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
       'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
    hash: hash.sha512,
    gRed: false,
    g: [
      '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
      '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
      'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
      '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
      '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
      '3fad0761 353c7086 a272c240 88be9476 9fd16650',
    ],
  });
  defineCurve('curve25519', {
    type: 'mont',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '76d06',
    b: '1',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: [
      '9',
    ],
  });
  defineCurve('ed25519', {
    type: 'edwards',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '-1',
    c: '1',
    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: hash.sha256,
    gRed: false,
    g: [
      '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
      '6666666666666666666666666666666666666666666666666666666666666658',
    ],
  });
  var pre;
  try {
    pre = require('./precomputed/secp256k1');
  } catch (e) {
    pre = undefined;
  }
  defineCurve('secp256k1', {
    type: 'short',
    prime: 'k256',
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    a: '0',
    b: '7',
    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    h: '1',
    hash: hash.sha256,
    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    basis: [
      {
        a: '3086d221a7d46bcde86c90e49284eb15',
        b: '-e4437ed6010e88286f547fa90abfe4c3',
      },
      {
        a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
        b: '3086d221a7d46bcde86c90e49284eb15',
      },
    ],
    gRed: false,
    g: [
      '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
      '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
      pre,
    ],
  });
  }(curves$2));

  var hash$1 = hash$2;
  var utils$6 = utils$l;
  var assert$6 = minimalisticAssert;
  function HmacDRBG$1(options) {
    if (!(this instanceof HmacDRBG$1))
      return new HmacDRBG$1(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils$6.toArray(options.entropy, options.entropyEnc || 'hex');
    var nonce = utils$6.toArray(options.nonce, options.nonceEnc || 'hex');
    var pers = utils$6.toArray(options.pers, options.persEnc || 'hex');
    assert$6(entropy.length >= (this.minEntropy / 8),
           'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._init(entropy, nonce, pers);
  }
  var hmacDrbg = HmacDRBG$1;
  HmacDRBG$1.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0; i < this.V.length; i++) {
      this.K[i] = 0x00;
      this.V[i] = 0x01;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 0x1000000000000;
  };
  HmacDRBG$1.prototype._hmac = function hmac() {
    return new hash$1.hmac(this.hash, this.K);
  };
  HmacDRBG$1.prototype._update = function update(seed) {
    var kmac = this._hmac()
                   .update(this.V)
                   .update([ 0x00 ]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac()
                 .update(this.V)
                 .update([ 0x01 ])
                 .update(seed)
                 .digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG$1.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    if (typeof entropyEnc !== 'string') {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils$6.toArray(entropy, entropyEnc);
    add = utils$6.toArray(add, addEnc);
    assert$6(entropy.length >= (this.minEntropy / 8),
           'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
    this._update(entropy.concat(add || []));
    this._reseed = 1;
  };
  HmacDRBG$1.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error('Reseed is required');
    if (typeof enc !== 'string') {
      addEnc = add;
      add = enc;
      enc = null;
    }
    if (add) {
      add = utils$6.toArray(add, addEnc || 'hex');
      this._update(add);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils$6.encode(res, enc);
  };

  var BN$3 = bn.exports;
  var utils$5 = utils$m;
  var assert$5 = utils$5.assert;
  function KeyPair$3(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  var key$1 = KeyPair$3;
  KeyPair$3.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair$3)
      return pub;
    return new KeyPair$3(ec, {
      pub: pub,
      pubEnc: enc,
    });
  };
  KeyPair$3.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair$3)
      return priv;
    return new KeyPair$3(ec, {
      priv: priv,
      privEnc: enc,
    });
  };
  KeyPair$3.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return { result: false, reason: 'Invalid public key' };
    if (!pub.validate())
      return { result: false, reason: 'Public key is not a point' };
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return { result: false, reason: 'Public key * N != O' };
    return { result: true, reason: null };
  };
  KeyPair$3.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === 'string') {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair$3.prototype.getPrivate = function getPrivate(enc) {
    if (enc === 'hex')
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair$3.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN$3(key, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair$3.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      if (this.ec.curve.type === 'mont') {
        assert$5(key.x, 'Need x coordinate');
      } else if (this.ec.curve.type === 'short' ||
                 this.ec.curve.type === 'edwards') {
        assert$5(key.x && key.y, 'Need both x and y coordinate');
      }
      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };
  KeyPair$3.prototype.derive = function derive(pub) {
    if(!pub.validate()) {
      assert$5(pub.validate(), 'public point not validated');
    }
    return pub.mul(this.priv).getX();
  };
  KeyPair$3.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair$3.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };
  KeyPair$3.prototype.inspect = function inspect() {
    return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
           ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
  };

  var BN$2 = bn.exports;
  var utils$4 = utils$m;
  var assert$4 = utils$4.assert;
  function Signature$3(options, enc) {
    if (options instanceof Signature$3)
      return options;
    if (this._importDER(options, enc))
      return;
    assert$4(options.r && options.s, 'Signature without r or s');
    this.r = new BN$2(options.r, 16);
    this.s = new BN$2(options.s, 16);
    if (options.recoveryParam === undefined)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  var signature$1 = Signature$3;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 0x80)) {
      return initial;
    }
    var octetLen = initial & 0xf;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    var val = 0;
    for (var i = 0, off = p.place; i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 0x7f) {
      return false;
    }
    p.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
      i++;
    }
    if (i === 0) {
      return buf;
    }
    return buf.slice(i);
  }
  Signature$3.prototype._importDER = function _importDER(data, enc) {
    data = utils$4.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 0x30) {
      return false;
    }
    var len = getLength(data, p);
    if (len === false) {
      return false;
    }
    if ((len + p.place) !== data.length) {
      return false;
    }
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var rlen = getLength(data, p);
    if (rlen === false) {
      return false;
    }
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 0x02) {
      return false;
    }
    var slen = getLength(data, p);
    if (slen === false) {
      return false;
    }
    if (data.length !== slen + p.place) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
      if (r[1] & 0x80) {
        r = r.slice(1);
      } else {
        return false;
      }
    }
    if (s[0] === 0) {
      if (s[1] & 0x80) {
        s = s.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN$2(r);
    this.s = new BN$2(s);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len) {
    if (len < 0x80) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 0x80);
    while (--octets) {
      arr.push((len >>> (octets << 3)) & 0xff);
    }
    arr.push(len);
  }
  Signature$3.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    if (r[0] & 0x80)
      r = [ 0 ].concat(r);
    if (s[0] & 0x80)
      s = [ 0 ].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while (!s[0] && !(s[1] & 0x80)) {
      s = s.slice(1);
    }
    var arr = [ 0x02 ];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(0x02);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [ 0x30 ];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils$4.encode(res, enc);
  };

  var BN$1 = bn.exports;
  var HmacDRBG = hmacDrbg;
  var utils$3 = utils$m;
  var curves$1 = curves$2;
  var rand = brorand.exports;
  var assert$3 = utils$3.assert;
  var KeyPair$2 = key$1;
  var Signature$2 = signature$1;
  function EC$1(options) {
    if (!(this instanceof EC$1))
      return new EC$1(options);
    if (typeof options === 'string') {
      assert$3(Object.prototype.hasOwnProperty.call(curves$1, options),
        'Unknown curve ' + options);
      options = curves$1[options];
    }
    if (options instanceof curves$1.PresetCurve)
      options = { curve: options };
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  var ec = EC$1;
  EC$1.prototype.keyPair = function keyPair(options) {
    return new KeyPair$2(this, options);
  };
  EC$1.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair$2.fromPrivate(this, priv, enc);
  };
  EC$1.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair$2.fromPublic(this, pub, enc);
  };
  EC$1.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || 'utf8',
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || 'utf8',
      nonce: this.n.toArray(),
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN$1(2));
    for (;;) {
      var priv = new BN$1(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    }
  };
  EC$1.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC$1.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === 'object') {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN$1(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray('be', bytes);
    var nonce = msg.toArray('be', bytes);
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce: nonce,
      pers: options.pers,
      persEnc: options.persEnc || 'utf8',
    });
    var ns1 = this.n.sub(new BN$1(1));
    for (var iter = 0; ; iter++) {
      var k = options.k ?
        options.k(iter) :
        new BN$1(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0)
        continue;
      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                          (kpX.cmp(r) !== 0 ? 2 : 0);
      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }
      return new Signature$2({ r: r, s: s, recoveryParam: recoveryParam });
    }
  };
  EC$1.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN$1(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature$2(signature, 'hex');
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    var p;
    if (!this.curve._maxwellTrick) {
      p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.getX().umod(this.n).cmp(r) === 0;
    }
    p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.eqXToP(r);
  };
  EC$1.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert$3((3 & j) === j, 'The recovery param is more than two bits');
    signature = new Signature$2(signature, enc);
    var n = this.n;
    var e = new BN$1(msg);
    var r = signature.r;
    var s = signature.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error('Unable to find sencond key candinate');
    if (isSecondKey)
      r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else
      r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    return this.g.mulAdd(s1, r, s2);
  };
  EC$1.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new Signature$2(signature, enc);
    if (signature.recoveryParam !== null)
      return signature.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e) {
        continue;
      }
      if (Qprime.eq(Q))
        return i;
    }
    throw new Error('Unable to find valid recovery factor');
  };

  var utils$2 = utils$m;
  var assert$2 = utils$2.assert;
  var parseBytes$2 = utils$2.parseBytes;
  var cachedProperty$1 = utils$2.cachedProperty;
  function KeyPair$1(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes$2(params.secret);
    if (eddsa.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes$2(params.pub);
  }
  KeyPair$1.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair$1)
      return pub;
    return new KeyPair$1(eddsa, { pub: pub });
  };
  KeyPair$1.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair$1)
      return secret;
    return new KeyPair$1(eddsa, { secret: secret });
  };
  KeyPair$1.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty$1(KeyPair$1, 'pubBytes', function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty$1(KeyPair$1, 'pub', function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty$1(KeyPair$1, 'privBytes', function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty$1(KeyPair$1, 'priv', function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty$1(KeyPair$1, 'hash', function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty$1(KeyPair$1, 'messagePrefix', function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair$1.prototype.sign = function sign(message) {
    assert$2(this._secret, 'KeyPair can only verify');
    return this.eddsa.sign(message, this);
  };
  KeyPair$1.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair$1.prototype.getSecret = function getSecret(enc) {
    assert$2(this._secret, 'KeyPair is public only');
    return utils$2.encode(this.secret(), enc);
  };
  KeyPair$1.prototype.getPublic = function getPublic(enc) {
    return utils$2.encode(this.pubBytes(), enc);
  };
  var key = KeyPair$1;

  var BN = bn.exports;
  var utils$1 = utils$m;
  var assert$1 = utils$1.assert;
  var cachedProperty = utils$1.cachedProperty;
  var parseBytes$1 = utils$1.parseBytes;
  function Signature$1(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== 'object')
      sig = parseBytes$1(sig);
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength),
      };
    }
    assert$1(sig.R && sig.S, 'Signature without R or S');
    if (eddsa.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty(Signature$1, 'S', function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature$1, 'R', function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature$1, 'Rencoded', function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature$1, 'Sencoded', function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature$1.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature$1.prototype.toHex = function toHex() {
    return utils$1.encode(this.toBytes(), 'hex').toUpperCase();
  };
  var signature = Signature$1;

  var hash = hash$2;
  var curves = curves$2;
  var utils = utils$m;
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var KeyPair = key;
  var Signature = signature;
  function EDDSA(curve) {
    assert(curve === 'ed25519', 'only tested with ed25519 so far');
    if (!(this instanceof EDDSA))
      return new EDDSA(curve);
    curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
  }
  var eddsa = EDDSA;
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
      .mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash = this.hash();
    for (var i = 0; i < arguments.length; i++)
      hash.update(arguments[i]);
    return utils.intFromLE(hash.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray('le', this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
    var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray('le', this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };

  (function (exports) {
  var elliptic = exports;
  elliptic.version = require$$0.version;
  elliptic.utils = utils$m;
  elliptic.rand = brorand.exports;
  elliptic.curve = curve;
  elliptic.curves = curves$2;
  elliptic.ec = ec;
  elliptic.eddsa = eddsa;
  }(elliptic));

  const EC = elliptic.ec;
  const secp256k1 = new EC('secp256k1');
  const EXPAND_OPT = {
    bitLength: 256,
    isLe: false
  };

  function base58Encode(value, ipfsCompat) {
    const out = bs58.encode(u8aToU8a(value));
    return ipfsCompat ? `z${out}` : out;
  }

  function encodeAddress(key, ss58Format = defaults.prefix) {
    const u8a = decodeAddress(key);
    assert$g(ss58Format >= 0 && ss58Format <= 16383 && ![46, 47].includes(ss58Format), 'Out of range ss58Format specified');
    assert$g(defaults.allowedDecodedLengths.includes(u8a.length), () => `Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(', ')}`);
    const input = u8aConcat(ss58Format < 64 ? [ss58Format] : [(ss58Format & 0b0000000011111100) >> 2 | 0b01000000, ss58Format >> 8 | (ss58Format & 0b0000000000000011) << 6], u8a);
    return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
  }

  var sha3 = {exports: {}};

  /**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   */
  (function (module) {
  (function () {
    var INPUT_ERROR = 'input is invalid type';
    var FINALIZE_ERROR = 'finalize already called';
    var WINDOW = typeof window === 'object';
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === 'object';
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
    if (NODE_JS) {
      root = commonjsGlobal;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && 'object' === 'object' && module.exports;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    var HEX_CHARS = '0123456789abcdef'.split('');
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
      0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
      2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
      2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
      2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
    var CSHAKE_BYTEPAD = {
      '128': 168,
      '256': 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function (obj) {
        return Object.prototype.toString.call(obj) === '[object Array]';
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function (obj) {
        return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function (bits, padding, outputType) {
      return function (message) {
        return new Keccak(bits, padding, bits).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function (bits, padding, outputType) {
      return function (message, outputBits) {
        return new Keccak(bits, padding, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function (bits, padding, outputType) {
      return function (message, outputBits, n, s) {
        return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
      };
    };
    var createKmacOutputMethod = function (bits, padding, outputType) {
      return function (key, message, outputBits, s) {
        return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
      };
    };
    var createOutputMethods = function (method, createMethod, bits, padding) {
      for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
        var type = OUTPUT_TYPES[i];
        method[type] = createMethod(bits, padding, type);
      }
      return method;
    };
    var createMethod = function (bits, padding) {
      var method = createOutputMethod(bits, padding, 'hex');
      method.create = function () {
        return new Keccak(bits, padding, bits);
      };
      method.update = function (message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits, padding);
    };
    var createShakeMethod = function (bits, padding) {
      var method = createShakeOutputMethod(bits, padding, 'hex');
      method.create = function (outputBits) {
        return new Keccak(bits, padding, outputBits);
      };
      method.update = function (message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits, padding);
    };
    var createCshakeMethod = function (bits, padding) {
      var w = CSHAKE_BYTEPAD[bits];
      var method = createCshakeOutputMethod(bits, padding, 'hex');
      method.create = function (outputBits, n, s) {
        if (!n && !s) {
          return methods['shake' + bits].create(outputBits);
        } else {
          return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
        }
      };
      method.update = function (message, outputBits, n, s) {
        return method.create(outputBits, n, s).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
    };
    var createKmacMethod = function (bits, padding) {
      var w = CSHAKE_BYTEPAD[bits];
      var method = createKmacOutputMethod(bits, padding, 'hex');
      method.create = function (key, outputBits, s) {
        return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
      };
      method.update = function (key, message, outputBits, s) {
        return method.create(key, outputBits, s).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits, padding);
    };
    var algorithms = [
      { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
      { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
      { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
      { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
      { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
    ];
    var methods = {}, methodNames = [];
    for (var i = 0; i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j = 0; j < bits.length; ++j) {
        var methodName = algorithm.name + '_' + bits[j];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== 'sha3') {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits, padding, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = (1600 - (bits << 1)) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i = 0; i < 50; ++i) {
        this.s[i] = 0;
      }
    }
    Keccak.prototype.update = function (message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== 'string') {
        if (type === 'object') {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
        blockCount = this.blockCount, index = 0, s = this.s, i, code;
      while (index < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i = 1; i < blockCount + 1; ++i) {
            blocks[i] = 0;
          }
        }
        if (notString) {
          for (i = this.start; index < length && i < byteCount; ++index) {
            blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
          }
        } else {
          for (i = this.start; index < length && i < byteCount; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              blocks[i >> 2] |= code << SHIFT[i++ & 3];
            } else if (code < 0x800) {
              blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else if (code < 0xd800 || code >= 0xe000) {
              blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            } else {
              code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
              blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
              blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
            }
          }
        }
        this.lastByteIndex = i;
        if (i >= byteCount) {
          this.start = i - byteCount;
          this.block = blocks[blockCount];
          for (i = 0; i < blockCount; ++i) {
            s[i] ^= blocks[i];
          }
          f(s);
          this.reset = true;
        } else {
          this.start = i;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function (x, right) {
      var o = x & 255, n = 1;
      var bytes = [o];
      x = x >> 8;
      o = x & 255;
      while (o > 0) {
        bytes.unshift(o);
        x = x >> 8;
        o = x & 255;
        ++n;
      }
      if (right) {
        bytes.push(n);
      } else {
        bytes.unshift(n);
      }
      this.update(bytes);
      return bytes.length;
    };
    Keccak.prototype.encodeString = function (str) {
      var notString, type = typeof str;
      if (type !== 'string') {
        if (type === 'object') {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes = 0, length = str.length;
      if (notString) {
        bytes = length;
      } else {
        for (var i = 0; i < str.length; ++i) {
          var code = str.charCodeAt(i);
          if (code < 0x80) {
            bytes += 1;
          } else if (code < 0x800) {
            bytes += 2;
          } else if (code < 0xd800 || code >= 0xe000) {
            bytes += 3;
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
            bytes += 4;
          }
        }
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };
    Keccak.prototype.bytepad = function (strs, w) {
      var bytes = this.encode(w);
      for (var i = 0; i < strs.length; ++i) {
        bytes += this.encodeString(strs[i]);
      }
      var paddingBytes = w - bytes % w;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };
    Keccak.prototype.finalize = function () {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
      blocks[i >> 2] |= this.padding[i & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      blocks[blockCount - 1] |= 0x80000000;
      for (i = 0; i < blockCount; ++i) {
        s[i] ^= blocks[i];
      }
      f(s);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function () {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
      var hex = '', block;
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          block = s[i];
          hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
            HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
            HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
            HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
        }
        if (j % blockCount === 0) {
          f(s);
          i = 0;
        }
      }
      if (extraBytes) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
        if (extraBytes > 1) {
          hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
        }
      }
      return hex;
    };
    Keccak.prototype.arrayBuffer = function () {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
      var bytes = this.outputBits >> 3;
      var buffer;
      if (extraBytes) {
        buffer = new ArrayBuffer((outputBlocks + 1) << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer);
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          array[j] = s[i];
        }
        if (j % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        array[i] = s[i];
        buffer = buffer.slice(0, bytes);
      }
      return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function () {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes, i = 0, j = 0;
      var array = [], offset, block;
      while (j < outputBlocks) {
        for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
          offset = j << 2;
          block = s[i];
          array[offset] = block & 0xFF;
          array[offset + 1] = (block >> 8) & 0xFF;
          array[offset + 2] = (block >> 16) & 0xFF;
          array[offset + 3] = (block >> 24) & 0xFF;
        }
        if (j % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        if (extraBytes > 1) {
          array[offset + 1] = (block >> 8) & 0xFF;
        }
        if (extraBytes > 2) {
          array[offset + 2] = (block >> 16) & 0xFF;
        }
      }
      return array;
    };
    function Kmac(bits, padding, outputBits) {
      Keccak.call(this, bits, padding, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function () {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f = function (s) {
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
        b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
        b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
        b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ ((c2 << 1) | (c3 >>> 31));
        l = c9 ^ ((c3 << 1) | (c2 >>> 31));
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ ((c4 << 1) | (c5 >>> 31));
        l = c1 ^ ((c5 << 1) | (c4 >>> 31));
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ ((c6 << 1) | (c7 >>> 31));
        l = c3 ^ ((c7 << 1) | (c6 >>> 31));
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ ((c8 << 1) | (c9 >>> 31));
        l = c5 ^ ((c9 << 1) | (c8 >>> 31));
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ ((c0 << 1) | (c1 >>> 31));
        l = c7 ^ ((c1 << 1) | (c0 >>> 31));
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = (s[11] << 4) | (s[10] >>> 28);
        b33 = (s[10] << 4) | (s[11] >>> 28);
        b14 = (s[20] << 3) | (s[21] >>> 29);
        b15 = (s[21] << 3) | (s[20] >>> 29);
        b46 = (s[31] << 9) | (s[30] >>> 23);
        b47 = (s[30] << 9) | (s[31] >>> 23);
        b28 = (s[40] << 18) | (s[41] >>> 14);
        b29 = (s[41] << 18) | (s[40] >>> 14);
        b20 = (s[2] << 1) | (s[3] >>> 31);
        b21 = (s[3] << 1) | (s[2] >>> 31);
        b2 = (s[13] << 12) | (s[12] >>> 20);
        b3 = (s[12] << 12) | (s[13] >>> 20);
        b34 = (s[22] << 10) | (s[23] >>> 22);
        b35 = (s[23] << 10) | (s[22] >>> 22);
        b16 = (s[33] << 13) | (s[32] >>> 19);
        b17 = (s[32] << 13) | (s[33] >>> 19);
        b48 = (s[42] << 2) | (s[43] >>> 30);
        b49 = (s[43] << 2) | (s[42] >>> 30);
        b40 = (s[5] << 30) | (s[4] >>> 2);
        b41 = (s[4] << 30) | (s[5] >>> 2);
        b22 = (s[14] << 6) | (s[15] >>> 26);
        b23 = (s[15] << 6) | (s[14] >>> 26);
        b4 = (s[25] << 11) | (s[24] >>> 21);
        b5 = (s[24] << 11) | (s[25] >>> 21);
        b36 = (s[34] << 15) | (s[35] >>> 17);
        b37 = (s[35] << 15) | (s[34] >>> 17);
        b18 = (s[45] << 29) | (s[44] >>> 3);
        b19 = (s[44] << 29) | (s[45] >>> 3);
        b10 = (s[6] << 28) | (s[7] >>> 4);
        b11 = (s[7] << 28) | (s[6] >>> 4);
        b42 = (s[17] << 23) | (s[16] >>> 9);
        b43 = (s[16] << 23) | (s[17] >>> 9);
        b24 = (s[26] << 25) | (s[27] >>> 7);
        b25 = (s[27] << 25) | (s[26] >>> 7);
        b6 = (s[36] << 21) | (s[37] >>> 11);
        b7 = (s[37] << 21) | (s[36] >>> 11);
        b38 = (s[47] << 24) | (s[46] >>> 8);
        b39 = (s[46] << 24) | (s[47] >>> 8);
        b30 = (s[8] << 27) | (s[9] >>> 5);
        b31 = (s[9] << 27) | (s[8] >>> 5);
        b12 = (s[18] << 20) | (s[19] >>> 12);
        b13 = (s[19] << 20) | (s[18] >>> 12);
        b44 = (s[29] << 7) | (s[28] >>> 25);
        b45 = (s[28] << 7) | (s[29] >>> 25);
        b26 = (s[38] << 8) | (s[39] >>> 24);
        b27 = (s[39] << 8) | (s[38] >>> 24);
        b8 = (s[48] << 14) | (s[49] >>> 18);
        b9 = (s[49] << 14) | (s[48] >>> 18);
        s[0] = b0 ^ (~b2 & b4);
        s[1] = b1 ^ (~b3 & b5);
        s[10] = b10 ^ (~b12 & b14);
        s[11] = b11 ^ (~b13 & b15);
        s[20] = b20 ^ (~b22 & b24);
        s[21] = b21 ^ (~b23 & b25);
        s[30] = b30 ^ (~b32 & b34);
        s[31] = b31 ^ (~b33 & b35);
        s[40] = b40 ^ (~b42 & b44);
        s[41] = b41 ^ (~b43 & b45);
        s[2] = b2 ^ (~b4 & b6);
        s[3] = b3 ^ (~b5 & b7);
        s[12] = b12 ^ (~b14 & b16);
        s[13] = b13 ^ (~b15 & b17);
        s[22] = b22 ^ (~b24 & b26);
        s[23] = b23 ^ (~b25 & b27);
        s[32] = b32 ^ (~b34 & b36);
        s[33] = b33 ^ (~b35 & b37);
        s[42] = b42 ^ (~b44 & b46);
        s[43] = b43 ^ (~b45 & b47);
        s[4] = b4 ^ (~b6 & b8);
        s[5] = b5 ^ (~b7 & b9);
        s[14] = b14 ^ (~b16 & b18);
        s[15] = b15 ^ (~b17 & b19);
        s[24] = b24 ^ (~b26 & b28);
        s[25] = b25 ^ (~b27 & b29);
        s[34] = b34 ^ (~b36 & b38);
        s[35] = b35 ^ (~b37 & b39);
        s[44] = b44 ^ (~b46 & b48);
        s[45] = b45 ^ (~b47 & b49);
        s[6] = b6 ^ (~b8 & b0);
        s[7] = b7 ^ (~b9 & b1);
        s[16] = b16 ^ (~b18 & b10);
        s[17] = b17 ^ (~b19 & b11);
        s[26] = b26 ^ (~b28 & b20);
        s[27] = b27 ^ (~b29 & b21);
        s[36] = b36 ^ (~b38 & b30);
        s[37] = b37 ^ (~b39 & b31);
        s[46] = b46 ^ (~b48 & b40);
        s[47] = b47 ^ (~b49 & b41);
        s[8] = b8 ^ (~b0 & b2);
        s[9] = b9 ^ (~b1 & b3);
        s[18] = b18 ^ (~b10 & b12);
        s[19] = b19 ^ (~b11 & b13);
        s[28] = b28 ^ (~b20 & b22);
        s[29] = b29 ^ (~b21 & b23);
        s[38] = b38 ^ (~b30 & b32);
        s[39] = b39 ^ (~b31 & b33);
        s[48] = b48 ^ (~b40 & b42);
        s[49] = b49 ^ (~b41 & b43);
        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
      }
    };
    if (COMMON_JS) {
      module.exports = methods;
    } else {
      for (i = 0; i < methodNames.length; ++i) {
        root[methodNames[i]] = methods[methodNames[i]];
      }
    }
  })();
  }(sha3));
  const js = sha3.exports;

  function keccakAsU8a(value, bitLength = 256, onlyJs = false) {
    const is256 = bitLength === 256;
    return isReady() && is256 && !onlyJs ? keccak256(u8aToU8a(value)) : new Uint8Array((is256 ? js.keccak256 : js.keccak512).update(u8aToU8a(value)).arrayBuffer());
  }

  function secp256k1Expand(publicKey) {
    assert$g([33, 65].includes(publicKey.length), 'Invalid publicKey provided');
    const expanded = secp256k1.keyFromPublic(publicKey).getPublic();
    return u8aConcat(bnToU8a(expanded.getX(), EXPAND_OPT), bnToU8a(expanded.getY(), EXPAND_OPT));
  }

  function getH160(u8a) {
    if ([33, 65].includes(u8a.length)) {
      u8a = keccakAsU8a(secp256k1Expand(u8a));
    }
    return u8a.slice(-20);
  }
  function ethereumEncode(addressOrPublic) {
    if (!addressOrPublic) {
      return '0x';
    }
    const u8aAddress = u8aToU8a(addressOrPublic);
    assert$g([20, 32, 33, 65].includes(u8aAddress.length), 'Invalid address or publicKey passed');
    const address = u8aToHex(getH160(u8aAddress), -1, false);
    const hash = u8aToHex(keccakAsU8a(address), -1, false);
    let result = '';
    for (let index = 0; index < 40; index++) {
      result = `${result}${parseInt(hash[index], 16) > 7 ? address[index].toUpperCase() : address[index]}`;
    }
    return `0x${result}`;
  }

  function isInvalidChar(char, byte) {
    return char !== (byte > 7 ? char.toUpperCase() : char.toLowerCase());
  }
  function isEthereumChecksum(_address) {
    const address = _address.replace('0x', '');
    const hash = u8aToHex(keccakAsU8a(address.toLowerCase()), -1, false);
    for (let index = 0; index < 40; index++) {
      if (isInvalidChar(address[index], parseInt(hash[index], 16))) {
        return false;
      }
    }
    return true;
  }

  function isEthereumAddress(address) {
    if (!address || address.length !== 42 || !isHex(address)) {
      return false;
    } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
      return true;
    }
    return isEthereumChecksum(address);
  }

  var cuint = {};

  var uint32 = {exports: {}};

  (function (module) {
  (function (root) {
  	({
  		36: UINT32( Math.pow(36, 5) )
  	,	16: UINT32( Math.pow(16, 7) )
  	,	10: UINT32( Math.pow(10, 9) )
  	,	2:  UINT32( Math.pow(2, 30) )
  	});
  	({
  		36: UINT32(36)
  	,	16: UINT32(16)
  	,	10: UINT32(10)
  	,	2:  UINT32(2)
  	});
  	function UINT32 (l, h) {
  		if ( !(this instanceof UINT32) )
  			return new UINT32(l, h)
  		this._low = 0;
  		this._high = 0;
  		this.remainder = null;
  		if (typeof h == 'undefined')
  			return fromNumber.call(this, l)
  		if (typeof l == 'string')
  			return fromString.call(this, l, h)
  		fromBits.call(this, l, h);
  	}
  	function fromBits (l, h) {
  		this._low = l | 0;
  		this._high = h | 0;
  		return this
  	}
  	UINT32.prototype.fromBits = fromBits;
  	function fromNumber (value) {
  		this._low = value & 0xFFFF;
  		this._high = value >>> 16;
  		return this
  	}
  	UINT32.prototype.fromNumber = fromNumber;
  	function fromString (s, radix) {
  		var value = parseInt(s, radix || 10);
  		this._low = value & 0xFFFF;
  		this._high = value >>> 16;
  		return this
  	}
  	UINT32.prototype.fromString = fromString;
  	UINT32.prototype.toNumber = function () {
  		return (this._high * 65536) + this._low
  	};
  	UINT32.prototype.toString = function (radix) {
  		return this.toNumber().toString(radix || 10)
  	};
  	UINT32.prototype.add = function (other) {
  		var a00 = this._low + other._low;
  		var a16 = a00 >>> 16;
  		a16 += this._high + other._high;
  		this._low = a00 & 0xFFFF;
  		this._high = a16 & 0xFFFF;
  		return this
  	};
  	UINT32.prototype.subtract = function (other) {
  		return this.add( other.clone().negate() )
  	};
  	UINT32.prototype.multiply = function (other) {
  		var a16 = this._high;
  		var a00 = this._low;
  		var b16 = other._high;
  		var b00 = other._low;
  		var c16, c00;
  		c00 = a00 * b00;
  		c16 = c00 >>> 16;
  		c16 += a16 * b00;
  		c16 &= 0xFFFF;
  		c16 += a00 * b16;
  		this._low = c00 & 0xFFFF;
  		this._high = c16 & 0xFFFF;
  		return this
  	};
  	UINT32.prototype.div = function (other) {
  		if ( (other._low == 0) && (other._high == 0) ) throw Error('division by zero')
  		if (other._high == 0 && other._low == 1) {
  			this.remainder = new UINT32(0);
  			return this
  		}
  		if ( other.gt(this) ) {
  			this.remainder = this.clone();
  			this._low = 0;
  			this._high = 0;
  			return this
  		}
  		if ( this.eq(other) ) {
  			this.remainder = new UINT32(0);
  			this._low = 1;
  			this._high = 0;
  			return this
  		}
  		var _other = other.clone();
  		var i = -1;
  		while ( !this.lt(_other) ) {
  			_other.shiftLeft(1, true);
  			i++;
  		}
  		this.remainder = this.clone();
  		this._low = 0;
  		this._high = 0;
  		for (; i >= 0; i--) {
  			_other.shiftRight(1);
  			if ( !this.remainder.lt(_other) ) {
  				this.remainder.subtract(_other);
  				if (i >= 16) {
  					this._high |= 1 << (i - 16);
  				} else {
  					this._low |= 1 << i;
  				}
  			}
  		}
  		return this
  	};
  	UINT32.prototype.negate = function () {
  		var v = ( ~this._low & 0xFFFF ) + 1;
  		this._low = v & 0xFFFF;
  		this._high = (~this._high + (v >>> 16)) & 0xFFFF;
  		return this
  	};
  	UINT32.prototype.equals = UINT32.prototype.eq = function (other) {
  		return (this._low == other._low) && (this._high == other._high)
  	};
  	UINT32.prototype.greaterThan = UINT32.prototype.gt = function (other) {
  		if (this._high > other._high) return true
  		if (this._high < other._high) return false
  		return this._low > other._low
  	};
  	UINT32.prototype.lessThan = UINT32.prototype.lt = function (other) {
  		if (this._high < other._high) return true
  		if (this._high > other._high) return false
  		return this._low < other._low
  	};
  	UINT32.prototype.or = function (other) {
  		this._low |= other._low;
  		this._high |= other._high;
  		return this
  	};
  	UINT32.prototype.and = function (other) {
  		this._low &= other._low;
  		this._high &= other._high;
  		return this
  	};
  	UINT32.prototype.not = function() {
  		this._low = ~this._low & 0xFFFF;
  		this._high = ~this._high & 0xFFFF;
  		return this
  	};
  	UINT32.prototype.xor = function (other) {
  		this._low ^= other._low;
  		this._high ^= other._high;
  		return this
  	};
  	UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function (n) {
  		if (n > 16) {
  			this._low = this._high >> (n - 16);
  			this._high = 0;
  		} else if (n == 16) {
  			this._low = this._high;
  			this._high = 0;
  		} else {
  			this._low = (this._low >> n) | ( (this._high << (16-n)) & 0xFFFF );
  			this._high >>= n;
  		}
  		return this
  	};
  	UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function (n, allowOverflow) {
  		if (n > 16) {
  			this._high = this._low << (n - 16);
  			this._low = 0;
  			if (!allowOverflow) {
  				this._high &= 0xFFFF;
  			}
  		} else if (n == 16) {
  			this._high = this._low;
  			this._low = 0;
  		} else {
  			this._high = (this._high << n) | (this._low >> (16-n));
  			this._low = (this._low << n) & 0xFFFF;
  			if (!allowOverflow) {
  				this._high &= 0xFFFF;
  			}
  		}
  		return this
  	};
  	UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function (n) {
  		var v = (this._high << 16) | this._low;
  		v = (v << n) | (v >>> (32 - n));
  		this._low = v & 0xFFFF;
  		this._high = v >>> 16;
  		return this
  	};
  	UINT32.prototype.rotateRight = UINT32.prototype.rotr = function (n) {
  		var v = (this._high << 16) | this._low;
  		v = (v >>> n) | (v << (32 - n));
  		this._low = v & 0xFFFF;
  		this._high = v >>> 16;
  		return this
  	};
  	UINT32.prototype.clone = function () {
  		return new UINT32(this._low, this._high)
  	};
  	if (module.exports) {
  		module.exports = UINT32;
  	} else {
  		root['UINT32'] = UINT32;
  	}
  })(commonjsGlobal);
  }(uint32));

  var uint64 = {exports: {}};

  (function (module) {
  (function (root) {
  	var radixPowerCache = {
  		16: UINT64( Math.pow(16, 5) )
  	,	10: UINT64( Math.pow(10, 5) )
  	,	2:  UINT64( Math.pow(2, 5) )
  	};
  	var radixCache = {
  		16: UINT64(16)
  	,	10: UINT64(10)
  	,	2:  UINT64(2)
  	};
  	function UINT64 (a00, a16, a32, a48) {
  		if ( !(this instanceof UINT64) )
  			return new UINT64(a00, a16, a32, a48)
  		this.remainder = null;
  		if (typeof a00 == 'string')
  			return fromString.call(this, a00, a16)
  		if (typeof a16 == 'undefined')
  			return fromNumber.call(this, a00)
  		fromBits.apply(this, arguments);
  	}
  	function fromBits (a00, a16, a32, a48) {
  		if (typeof a32 == 'undefined') {
  			this._a00 = a00 & 0xFFFF;
  			this._a16 = a00 >>> 16;
  			this._a32 = a16 & 0xFFFF;
  			this._a48 = a16 >>> 16;
  			return this
  		}
  		this._a00 = a00 | 0;
  		this._a16 = a16 | 0;
  		this._a32 = a32 | 0;
  		this._a48 = a48 | 0;
  		return this
  	}
  	UINT64.prototype.fromBits = fromBits;
  	function fromNumber (value) {
  		this._a00 = value & 0xFFFF;
  		this._a16 = value >>> 16;
  		this._a32 = 0;
  		this._a48 = 0;
  		return this
  	}
  	UINT64.prototype.fromNumber = fromNumber;
  	function fromString (s, radix) {
  		radix = radix || 10;
  		this._a00 = 0;
  		this._a16 = 0;
  		this._a32 = 0;
  		this._a48 = 0;
  		var radixUint = radixPowerCache[radix] || new UINT64( Math.pow(radix, 5) );
  		for (var i = 0, len = s.length; i < len; i += 5) {
  			var size = Math.min(5, len - i);
  			var value = parseInt( s.slice(i, i + size), radix );
  			this.multiply(
  					size < 5
  						? new UINT64( Math.pow(radix, size) )
  						: radixUint
  				)
  				.add( new UINT64(value) );
  		}
  		return this
  	}
  	UINT64.prototype.fromString = fromString;
  	UINT64.prototype.toNumber = function () {
  		return (this._a16 * 65536) + this._a00
  	};
  	UINT64.prototype.toString = function (radix) {
  		radix = radix || 10;
  		var radixUint = radixCache[radix] || new UINT64(radix);
  		if ( !this.gt(radixUint) ) return this.toNumber().toString(radix)
  		var self = this.clone();
  		var res = new Array(64);
  		for (var i = 63; i >= 0; i--) {
  			self.div(radixUint);
  			res[i] = self.remainder.toNumber().toString(radix);
  			if ( !self.gt(radixUint) ) break
  		}
  		res[i-1] = self.toNumber().toString(radix);
  		return res.join('')
  	};
  	UINT64.prototype.add = function (other) {
  		var a00 = this._a00 + other._a00;
  		var a16 = a00 >>> 16;
  		a16 += this._a16 + other._a16;
  		var a32 = a16 >>> 16;
  		a32 += this._a32 + other._a32;
  		var a48 = a32 >>> 16;
  		a48 += this._a48 + other._a48;
  		this._a00 = a00 & 0xFFFF;
  		this._a16 = a16 & 0xFFFF;
  		this._a32 = a32 & 0xFFFF;
  		this._a48 = a48 & 0xFFFF;
  		return this
  	};
  	UINT64.prototype.subtract = function (other) {
  		return this.add( other.clone().negate() )
  	};
  	UINT64.prototype.multiply = function (other) {
  		var a00 = this._a00;
  		var a16 = this._a16;
  		var a32 = this._a32;
  		var a48 = this._a48;
  		var b00 = other._a00;
  		var b16 = other._a16;
  		var b32 = other._a32;
  		var b48 = other._a48;
  		var c00 = a00 * b00;
  		var c16 = c00 >>> 16;
  		c16 += a00 * b16;
  		var c32 = c16 >>> 16;
  		c16 &= 0xFFFF;
  		c16 += a16 * b00;
  		c32 += c16 >>> 16;
  		c32 += a00 * b32;
  		var c48 = c32 >>> 16;
  		c32 &= 0xFFFF;
  		c32 += a16 * b16;
  		c48 += c32 >>> 16;
  		c32 &= 0xFFFF;
  		c32 += a32 * b00;
  		c48 += c32 >>> 16;
  		c48 += a00 * b48;
  		c48 &= 0xFFFF;
  		c48 += a16 * b32;
  		c48 &= 0xFFFF;
  		c48 += a32 * b16;
  		c48 &= 0xFFFF;
  		c48 += a48 * b00;
  		this._a00 = c00 & 0xFFFF;
  		this._a16 = c16 & 0xFFFF;
  		this._a32 = c32 & 0xFFFF;
  		this._a48 = c48 & 0xFFFF;
  		return this
  	};
  	UINT64.prototype.div = function (other) {
  		if ( (other._a16 == 0) && (other._a32 == 0) && (other._a48 == 0) ) {
  			if (other._a00 == 0) throw Error('division by zero')
  			if (other._a00 == 1) {
  				this.remainder = new UINT64(0);
  				return this
  			}
  		}
  		if ( other.gt(this) ) {
  			this.remainder = this.clone();
  			this._a00 = 0;
  			this._a16 = 0;
  			this._a32 = 0;
  			this._a48 = 0;
  			return this
  		}
  		if ( this.eq(other) ) {
  			this.remainder = new UINT64(0);
  			this._a00 = 1;
  			this._a16 = 0;
  			this._a32 = 0;
  			this._a48 = 0;
  			return this
  		}
  		var _other = other.clone();
  		var i = -1;
  		while ( !this.lt(_other) ) {
  			_other.shiftLeft(1, true);
  			i++;
  		}
  		this.remainder = this.clone();
  		this._a00 = 0;
  		this._a16 = 0;
  		this._a32 = 0;
  		this._a48 = 0;
  		for (; i >= 0; i--) {
  			_other.shiftRight(1);
  			if ( !this.remainder.lt(_other) ) {
  				this.remainder.subtract(_other);
  				if (i >= 48) {
  					this._a48 |= 1 << (i - 48);
  				} else if (i >= 32) {
  					this._a32 |= 1 << (i - 32);
  				} else if (i >= 16) {
  					this._a16 |= 1 << (i - 16);
  				} else {
  					this._a00 |= 1 << i;
  				}
  			}
  		}
  		return this
  	};
  	UINT64.prototype.negate = function () {
  		var v = ( ~this._a00 & 0xFFFF ) + 1;
  		this._a00 = v & 0xFFFF;
  		v = (~this._a16 & 0xFFFF) + (v >>> 16);
  		this._a16 = v & 0xFFFF;
  		v = (~this._a32 & 0xFFFF) + (v >>> 16);
  		this._a32 = v & 0xFFFF;
  		this._a48 = (~this._a48 + (v >>> 16)) & 0xFFFF;
  		return this
  	};
  	UINT64.prototype.equals = UINT64.prototype.eq = function (other) {
  		return (this._a48 == other._a48) && (this._a00 == other._a00)
  			 && (this._a32 == other._a32) && (this._a16 == other._a16)
  	};
  	UINT64.prototype.greaterThan = UINT64.prototype.gt = function (other) {
  		if (this._a48 > other._a48) return true
  		if (this._a48 < other._a48) return false
  		if (this._a32 > other._a32) return true
  		if (this._a32 < other._a32) return false
  		if (this._a16 > other._a16) return true
  		if (this._a16 < other._a16) return false
  		return this._a00 > other._a00
  	};
  	UINT64.prototype.lessThan = UINT64.prototype.lt = function (other) {
  		if (this._a48 < other._a48) return true
  		if (this._a48 > other._a48) return false
  		if (this._a32 < other._a32) return true
  		if (this._a32 > other._a32) return false
  		if (this._a16 < other._a16) return true
  		if (this._a16 > other._a16) return false
  		return this._a00 < other._a00
  	};
  	UINT64.prototype.or = function (other) {
  		this._a00 |= other._a00;
  		this._a16 |= other._a16;
  		this._a32 |= other._a32;
  		this._a48 |= other._a48;
  		return this
  	};
  	UINT64.prototype.and = function (other) {
  		this._a00 &= other._a00;
  		this._a16 &= other._a16;
  		this._a32 &= other._a32;
  		this._a48 &= other._a48;
  		return this
  	};
  	UINT64.prototype.xor = function (other) {
  		this._a00 ^= other._a00;
  		this._a16 ^= other._a16;
  		this._a32 ^= other._a32;
  		this._a48 ^= other._a48;
  		return this
  	};
  	UINT64.prototype.not = function() {
  		this._a00 = ~this._a00 & 0xFFFF;
  		this._a16 = ~this._a16 & 0xFFFF;
  		this._a32 = ~this._a32 & 0xFFFF;
  		this._a48 = ~this._a48 & 0xFFFF;
  		return this
  	};
  	UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function (n) {
  		n %= 64;
  		if (n >= 48) {
  			this._a00 = this._a48 >> (n - 48);
  			this._a16 = 0;
  			this._a32 = 0;
  			this._a48 = 0;
  		} else if (n >= 32) {
  			n -= 32;
  			this._a00 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF;
  			this._a16 = (this._a48 >> n) & 0xFFFF;
  			this._a32 = 0;
  			this._a48 = 0;
  		} else if (n >= 16) {
  			n -= 16;
  			this._a00 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF;
  			this._a16 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF;
  			this._a32 = (this._a48 >> n) & 0xFFFF;
  			this._a48 = 0;
  		} else {
  			this._a00 = ( (this._a00 >> n) | (this._a16 << (16-n)) ) & 0xFFFF;
  			this._a16 = ( (this._a16 >> n) | (this._a32 << (16-n)) ) & 0xFFFF;
  			this._a32 = ( (this._a32 >> n) | (this._a48 << (16-n)) ) & 0xFFFF;
  			this._a48 = (this._a48 >> n) & 0xFFFF;
  		}
  		return this
  	};
  	UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function (n, allowOverflow) {
  		n %= 64;
  		if (n >= 48) {
  			this._a48 = this._a00 << (n - 48);
  			this._a32 = 0;
  			this._a16 = 0;
  			this._a00 = 0;
  		} else if (n >= 32) {
  			n -= 32;
  			this._a48 = (this._a16 << n) | (this._a00 >> (16-n));
  			this._a32 = (this._a00 << n) & 0xFFFF;
  			this._a16 = 0;
  			this._a00 = 0;
  		} else if (n >= 16) {
  			n -= 16;
  			this._a48 = (this._a32 << n) | (this._a16 >> (16-n));
  			this._a32 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF;
  			this._a16 = (this._a00 << n) & 0xFFFF;
  			this._a00 = 0;
  		} else {
  			this._a48 = (this._a48 << n) | (this._a32 >> (16-n));
  			this._a32 = ( (this._a32 << n) | (this._a16 >> (16-n)) ) & 0xFFFF;
  			this._a16 = ( (this._a16 << n) | (this._a00 >> (16-n)) ) & 0xFFFF;
  			this._a00 = (this._a00 << n) & 0xFFFF;
  		}
  		if (!allowOverflow) {
  			this._a48 &= 0xFFFF;
  		}
  		return this
  	};
  	UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function (n) {
  		n %= 64;
  		if (n == 0) return this
  		if (n >= 32) {
  			var v = this._a00;
  			this._a00 = this._a32;
  			this._a32 = v;
  			v = this._a48;
  			this._a48 = this._a16;
  			this._a16 = v;
  			if (n == 32) return this
  			n -= 32;
  		}
  		var high = (this._a48 << 16) | this._a32;
  		var low = (this._a16 << 16) | this._a00;
  		var _high = (high << n) | (low >>> (32 - n));
  		var _low = (low << n) | (high >>> (32 - n));
  		this._a00 = _low & 0xFFFF;
  		this._a16 = _low >>> 16;
  		this._a32 = _high & 0xFFFF;
  		this._a48 = _high >>> 16;
  		return this
  	};
  	UINT64.prototype.rotateRight = UINT64.prototype.rotr = function (n) {
  		n %= 64;
  		if (n == 0) return this
  		if (n >= 32) {
  			var v = this._a00;
  			this._a00 = this._a32;
  			this._a32 = v;
  			v = this._a48;
  			this._a48 = this._a16;
  			this._a16 = v;
  			if (n == 32) return this
  			n -= 32;
  		}
  		var high = (this._a48 << 16) | this._a32;
  		var low = (this._a16 << 16) | this._a00;
  		var _high = (high >>> n) | (low << (32 - n));
  		var _low = (low >>> n) | (high << (32 - n));
  		this._a00 = _low & 0xFFFF;
  		this._a16 = _low >>> 16;
  		this._a32 = _high & 0xFFFF;
  		this._a48 = _high >>> 16;
  		return this
  	};
  	UINT64.prototype.clone = function () {
  		return new UINT64(this._a00, this._a16, this._a32, this._a48)
  	};
  	if (module.exports) {
  		module.exports = UINT64;
  	} else {
  		root['UINT64'] = UINT64;
  	}
  })(commonjsGlobal);
  }(uint64));

  cuint.UINT32 = uint32.exports;
  cuint.UINT64 = uint64.exports;

  var UINT32 = cuint.UINT32;
  UINT32.prototype.xxh_update = function (low, high) {
  	var b00 = PRIME32_2._low;
  	var b16 = PRIME32_2._high;
  	var c16, c00;
  	c00 = low * b00;
  	c16 = c00 >>> 16;
  	c16 += high * b00;
  	c16 &= 0xFFFF;
  	c16 += low * b16;
  	var a00 = this._low + (c00 & 0xFFFF);
  	var a16 = a00 >>> 16;
  	a16 += this._high + (c16 & 0xFFFF);
  	var v = (a16 << 16) | (a00 & 0xFFFF);
  	v = (v << 13) | (v >>> 19);
  	a00 = v & 0xFFFF;
  	a16 = v >>> 16;
  	b00 = PRIME32_1._low;
  	b16 = PRIME32_1._high;
  	c00 = a00 * b00;
  	c16 = c00 >>> 16;
  	c16 += a16 * b00;
  	c16 &= 0xFFFF;
  	c16 += a00 * b16;
  	this._low = c00 & 0xFFFF;
  	this._high = c16 & 0xFFFF;
  };
  var PRIME32_1 = UINT32( '2654435761' );
  var PRIME32_2 = UINT32( '2246822519' );
  var PRIME32_3 = UINT32( '3266489917' );
  var PRIME32_4 = UINT32(  '668265263' );
  var PRIME32_5 = UINT32(  '374761393' );
  function toUTF8Array$1 (str) {
  	var utf8 = [];
  	for (var i=0, n=str.length; i < n; i++) {
  		var charcode = str.charCodeAt(i);
  		if (charcode < 0x80) utf8.push(charcode);
  		else if (charcode < 0x800) {
  			utf8.push(0xc0 | (charcode >> 6),
  			0x80 | (charcode & 0x3f));
  		}
  		else if (charcode < 0xd800 || charcode >= 0xe000) {
  			utf8.push(0xe0 | (charcode >> 12),
  			0x80 | ((charcode>>6) & 0x3f),
  			0x80 | (charcode & 0x3f));
  		}
  		else {
  			i++;
  			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
  			| (str.charCodeAt(i) & 0x3ff));
  			utf8.push(0xf0 | (charcode >>18),
  			0x80 | ((charcode>>12) & 0x3f),
  			0x80 | ((charcode>>6) & 0x3f),
  			0x80 | (charcode & 0x3f));
  		}
  	}
  	return new Uint8Array(utf8)
  }
  function XXH () {
  	if (arguments.length == 2)
  		return new XXH( arguments[1] ).update( arguments[0] ).digest()
  	if (!(this instanceof XXH))
  		return new XXH( arguments[0] )
  	init$1.call(this, arguments[0]);
  }
   function init$1 (seed) {
  	this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed);
  	this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2);
  	this.v2 = this.seed.clone().add(PRIME32_2);
  	this.v3 = this.seed.clone();
  	this.v4 = this.seed.clone().subtract(PRIME32_1);
  	this.total_len = 0;
  	this.memsize = 0;
  	this.memory = null;
  	return this
  }
  XXH.prototype.init = init$1;
  XXH.prototype.update = function (input) {
  	var isString = typeof input == 'string';
  	var isArrayBuffer;
  	if (isString) {
  		input = toUTF8Array$1(input);
  		isString = false;
  		isArrayBuffer = true;
  	}
  	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
  	{
  		isArrayBuffer = true;
  		input = new Uint8Array(input);
  	}
  	var p = 0;
  	var len = input.length;
  	var bEnd = p + len;
  	if (len == 0) return this
  	this.total_len += len;
  	if (this.memsize == 0)
  	{
  		if (isString) {
  			this.memory = '';
  		} else if (isArrayBuffer) {
  			this.memory = new Uint8Array(16);
  		} else {
  			this.memory = new Buffer(16);
  		}
  	}
  	if (this.memsize + len < 16)
  	{
  		if (isString) {
  			this.memory += input;
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(0, len), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, 0, len );
  		}
  		this.memsize += len;
  		return this
  	}
  	if (this.memsize > 0)
  	{
  		if (isString) {
  			this.memory += input.slice(0, 16 - this.memsize);
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(0, 16 - this.memsize), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, 0, 16 - this.memsize );
  		}
  		var p32 = 0;
  		if (isString) {
  			this.v1.xxh_update(
  				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
  			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
  			);
  			p32 += 4;
  			this.v2.xxh_update(
  				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
  			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
  			);
  			p32 += 4;
  			this.v3.xxh_update(
  				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
  			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
  			);
  			p32 += 4;
  			this.v4.xxh_update(
  				(this.memory.charCodeAt(p32+1) << 8) | this.memory.charCodeAt(p32)
  			,	(this.memory.charCodeAt(p32+3) << 8) | this.memory.charCodeAt(p32+2)
  			);
  		} else {
  			this.v1.xxh_update(
  				(this.memory[p32+1] << 8) | this.memory[p32]
  			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
  			);
  			p32 += 4;
  			this.v2.xxh_update(
  				(this.memory[p32+1] << 8) | this.memory[p32]
  			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
  			);
  			p32 += 4;
  			this.v3.xxh_update(
  				(this.memory[p32+1] << 8) | this.memory[p32]
  			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
  			);
  			p32 += 4;
  			this.v4.xxh_update(
  				(this.memory[p32+1] << 8) | this.memory[p32]
  			,	(this.memory[p32+3] << 8) | this.memory[p32+2]
  			);
  		}
  		p += 16 - this.memsize;
  		this.memsize = 0;
  		if (isString) this.memory = '';
  	}
  	if (p <= bEnd - 16)
  	{
  		var limit = bEnd - 16;
  		do
  		{
  			if (isString) {
  				this.v1.xxh_update(
  					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  				);
  				p += 4;
  				this.v2.xxh_update(
  					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  				);
  				p += 4;
  				this.v3.xxh_update(
  					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  				);
  				p += 4;
  				this.v4.xxh_update(
  					(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  				,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  				);
  			} else {
  				this.v1.xxh_update(
  					(input[p+1] << 8) | input[p]
  				,	(input[p+3] << 8) | input[p+2]
  				);
  				p += 4;
  				this.v2.xxh_update(
  					(input[p+1] << 8) | input[p]
  				,	(input[p+3] << 8) | input[p+2]
  				);
  				p += 4;
  				this.v3.xxh_update(
  					(input[p+1] << 8) | input[p]
  				,	(input[p+3] << 8) | input[p+2]
  				);
  				p += 4;
  				this.v4.xxh_update(
  					(input[p+1] << 8) | input[p]
  				,	(input[p+3] << 8) | input[p+2]
  				);
  			}
  			p += 4;
  		} while (p <= limit)
  	}
  	if (p < bEnd)
  	{
  		if (isString) {
  			this.memory += input.slice(p);
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(p, bEnd), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, p, bEnd );
  		}
  		this.memsize = bEnd - p;
  	}
  	return this
  };
  XXH.prototype.digest = function () {
  	var input = this.memory;
  	var isString = typeof input == 'string';
  	var p = 0;
  	var bEnd = this.memsize;
  	var h32, h;
  	var u = new UINT32;
  	if (this.total_len >= 16)
  	{
  		h32 = this.v1.rotl(1).add( this.v2.rotl(7).add( this.v3.rotl(12).add( this.v4.rotl(18) ) ) );
  	}
  	else
  	{
  		h32  = this.seed.clone().add( PRIME32_5 );
  	}
  	h32.add( u.fromNumber(this.total_len) );
  	while (p <= bEnd - 4)
  	{
  		if (isString) {
  			u.fromBits(
  				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  			);
  		} else {
  			u.fromBits(
  				(input[p+1] << 8) | input[p]
  			,	(input[p+3] << 8) | input[p+2]
  			);
  		}
  		h32
  			.add( u.multiply(PRIME32_3) )
  			.rotl(17)
  			.multiply( PRIME32_4 );
  		p += 4;
  	}
  	while (p < bEnd)
  	{
  		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0 );
  		h32
  			.add( u.multiply(PRIME32_5) )
  			.rotl(11)
  			.multiply(PRIME32_1);
  	}
  	h = h32.clone().shiftRight(15);
  	h32.xor(h).multiply(PRIME32_2);
  	h = h32.clone().shiftRight(13);
  	h32.xor(h).multiply(PRIME32_3);
  	h = h32.clone().shiftRight(16);
  	h32.xor(h);
  	this.init( this.seed );
  	return h32
  };
  var xxhash = XXH;

  var UINT64 = cuint.UINT64;
  var PRIME64_1 = UINT64( '11400714785074694791' );
  var PRIME64_2 = UINT64( '14029467366897019727' );
  var PRIME64_3 = UINT64(  '1609587929392839161' );
  var PRIME64_4 = UINT64(  '9650029242287828579' );
  var PRIME64_5 = UINT64(  '2870177450012600261' );
  function toUTF8Array (str) {
  	var utf8 = [];
  	for (var i=0, n=str.length; i < n; i++) {
  		var charcode = str.charCodeAt(i);
  		if (charcode < 0x80) utf8.push(charcode);
  		else if (charcode < 0x800) {
  			utf8.push(0xc0 | (charcode >> 6),
  			0x80 | (charcode & 0x3f));
  		}
  		else if (charcode < 0xd800 || charcode >= 0xe000) {
  			utf8.push(0xe0 | (charcode >> 12),
  			0x80 | ((charcode>>6) & 0x3f),
  			0x80 | (charcode & 0x3f));
  		}
  		else {
  			i++;
  			charcode = 0x10000 + (((charcode & 0x3ff)<<10)
  			| (str.charCodeAt(i) & 0x3ff));
  			utf8.push(0xf0 | (charcode >>18),
  			0x80 | ((charcode>>12) & 0x3f),
  			0x80 | ((charcode>>6) & 0x3f),
  			0x80 | (charcode & 0x3f));
  		}
  	}
  	return new Uint8Array(utf8)
  }
  function XXH64 () {
  	if (arguments.length == 2)
  		return new XXH64( arguments[1] ).update( arguments[0] ).digest()
  	if (!(this instanceof XXH64))
  		return new XXH64( arguments[0] )
  	init.call(this, arguments[0]);
  }
   function init (seed) {
  	this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed);
  	this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2);
  	this.v2 = this.seed.clone().add(PRIME64_2);
  	this.v3 = this.seed.clone();
  	this.v4 = this.seed.clone().subtract(PRIME64_1);
  	this.total_len = 0;
  	this.memsize = 0;
  	this.memory = null;
  	return this
  }
  XXH64.prototype.init = init;
  XXH64.prototype.update = function (input) {
  	var isString = typeof input == 'string';
  	var isArrayBuffer;
  	if (isString) {
  		input = toUTF8Array(input);
  		isString = false;
  		isArrayBuffer = true;
  	}
  	if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer)
  	{
  		isArrayBuffer = true;
  		input = new Uint8Array(input);
  	}
  	var p = 0;
  	var len = input.length;
  	var bEnd = p + len;
  	if (len == 0) return this
  	this.total_len += len;
  	if (this.memsize == 0)
  	{
  		if (isString) {
  			this.memory = '';
  		} else if (isArrayBuffer) {
  			this.memory = new Uint8Array(32);
  		} else {
  			this.memory = new Buffer(32);
  		}
  	}
  	if (this.memsize + len < 32)
  	{
  		if (isString) {
  			this.memory += input;
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(0, len), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, 0, len );
  		}
  		this.memsize += len;
  		return this
  	}
  	if (this.memsize > 0)
  	{
  		if (isString) {
  			this.memory += input.slice(0, 32 - this.memsize);
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(0, 32 - this.memsize), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, 0, 32 - this.memsize );
  		}
  		var p64 = 0;
  		if (isString) {
  			var other;
  			other = UINT64(
  					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
  				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
  				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
  				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
  				);
  			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
  				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
  				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
  				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
  				);
  			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
  				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
  				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
  				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
  				);
  			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory.charCodeAt(p64+1) << 8) | this.memory.charCodeAt(p64)
  				,	(this.memory.charCodeAt(p64+3) << 8) | this.memory.charCodeAt(p64+2)
  				,	(this.memory.charCodeAt(p64+5) << 8) | this.memory.charCodeAt(p64+4)
  				,	(this.memory.charCodeAt(p64+7) << 8) | this.memory.charCodeAt(p64+6)
  				);
  			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  		} else {
  			var other;
  			other = UINT64(
  					(this.memory[p64+1] << 8) | this.memory[p64]
  				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
  				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
  				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
  				);
  			this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory[p64+1] << 8) | this.memory[p64]
  				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
  				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
  				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
  				);
  			this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory[p64+1] << 8) | this.memory[p64]
  				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
  				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
  				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
  				);
  			this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			p64 += 8;
  			other = UINT64(
  					(this.memory[p64+1] << 8) | this.memory[p64]
  				,	(this.memory[p64+3] << 8) | this.memory[p64+2]
  				,	(this.memory[p64+5] << 8) | this.memory[p64+4]
  				,	(this.memory[p64+7] << 8) | this.memory[p64+6]
  				);
  			this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  		}
  		p += 32 - this.memsize;
  		this.memsize = 0;
  		if (isString) this.memory = '';
  	}
  	if (p <= bEnd - 32)
  	{
  		var limit = bEnd - 32;
  		do
  		{
  			if (isString) {
  				var other;
  				other = UINT64(
  						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  					);
  				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  					);
  				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  					);
  				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  					,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  					,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  					,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  					);
  				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			} else {
  				var other;
  				other = UINT64(
  						(input[p+1] << 8) | input[p]
  					,	(input[p+3] << 8) | input[p+2]
  					,	(input[p+5] << 8) | input[p+4]
  					,	(input[p+7] << 8) | input[p+6]
  					);
  				this.v1.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input[p+1] << 8) | input[p]
  					,	(input[p+3] << 8) | input[p+2]
  					,	(input[p+5] << 8) | input[p+4]
  					,	(input[p+7] << 8) | input[p+6]
  					);
  				this.v2.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input[p+1] << 8) | input[p]
  					,	(input[p+3] << 8) | input[p+2]
  					,	(input[p+5] << 8) | input[p+4]
  					,	(input[p+7] << 8) | input[p+6]
  					);
  				this.v3.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  				p += 8;
  				other = UINT64(
  						(input[p+1] << 8) | input[p]
  					,	(input[p+3] << 8) | input[p+2]
  					,	(input[p+5] << 8) | input[p+4]
  					,	(input[p+7] << 8) | input[p+6]
  					);
  				this.v4.add( other.multiply(PRIME64_2) ).rotl(31).multiply(PRIME64_1);
  			}
  			p += 8;
  		} while (p <= limit)
  	}
  	if (p < bEnd)
  	{
  		if (isString) {
  			this.memory += input.slice(p);
  		} else if (isArrayBuffer) {
  			this.memory.set( input.subarray(p, bEnd), this.memsize );
  		} else {
  			input.copy( this.memory, this.memsize, p, bEnd );
  		}
  		this.memsize = bEnd - p;
  	}
  	return this
  };
  XXH64.prototype.digest = function () {
  	var input = this.memory;
  	var isString = typeof input == 'string';
  	var p = 0;
  	var bEnd = this.memsize;
  	var h64, h;
  	var u = new UINT64;
  	if (this.total_len >= 32)
  	{
  		h64 = this.v1.clone().rotl(1);
  		h64.add( this.v2.clone().rotl(7) );
  		h64.add( this.v3.clone().rotl(12) );
  		h64.add( this.v4.clone().rotl(18) );
  		h64.xor( this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) );
  		h64.multiply(PRIME64_1).add(PRIME64_4);
  		h64.xor( this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) );
  		h64.multiply(PRIME64_1).add(PRIME64_4);
  		h64.xor( this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) );
  		h64.multiply(PRIME64_1).add(PRIME64_4);
  		h64.xor( this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1) );
  		h64.multiply(PRIME64_1).add(PRIME64_4);
  	}
  	else
  	{
  		h64  = this.seed.clone().add( PRIME64_5 );
  	}
  	h64.add( u.fromNumber(this.total_len) );
  	while (p <= bEnd - 8)
  	{
  		if (isString) {
  			u.fromBits(
  				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  			,	(input.charCodeAt(p+5) << 8) | input.charCodeAt(p+4)
  			,	(input.charCodeAt(p+7) << 8) | input.charCodeAt(p+6)
  			);
  		} else {
  			u.fromBits(
  				(input[p+1] << 8) | input[p]
  			,	(input[p+3] << 8) | input[p+2]
  			,	(input[p+5] << 8) | input[p+4]
  			,	(input[p+7] << 8) | input[p+6]
  			);
  		}
  		u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1);
  		h64
  			.xor(u)
  			.rotl(27)
  			.multiply( PRIME64_1 )
  			.add( PRIME64_4 );
  		p += 8;
  	}
  	if (p + 4 <= bEnd) {
  		if (isString) {
  			u.fromBits(
  				(input.charCodeAt(p+1) << 8) | input.charCodeAt(p)
  			,	(input.charCodeAt(p+3) << 8) | input.charCodeAt(p+2)
  			,	0
  			,	0
  			);
  		} else {
  			u.fromBits(
  				(input[p+1] << 8) | input[p]
  			,	(input[p+3] << 8) | input[p+2]
  			,	0
  			,	0
  			);
  		}
  		h64
  			.xor( u.multiply(PRIME64_1) )
  			.rotl(23)
  			.multiply( PRIME64_2 )
  			.add( PRIME64_3 );
  		p += 4;
  	}
  	while (p < bEnd)
  	{
  		u.fromBits( isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0 );
  		h64
  			.xor( u.multiply(PRIME64_5) )
  			.rotl(11)
  			.multiply(PRIME64_1);
  	}
  	h = h64.clone().shiftRight(33);
  	h64.xor(h).multiply(PRIME64_2);
  	h = h64.clone().shiftRight(29);
  	h64.xor(h).multiply(PRIME64_3);
  	h = h64.clone().shiftRight(32);
  	h64.xor(h);
  	this.init( this.seed );
  	return h64
  };
  var xxhash64 = XXH64;

  var lib = {
  	h32: xxhash
  ,	h64: xxhash64
  };
  const xx = lib;

  function xxhash64AsValue(data, seed) {
    return xx.h64(u8aToU8a(data).buffer, seed);
  }

  function xxhash64AsRaw(data, seed) {
    return xxhash64AsValue(data, seed).toString(16);
  }

  function xxhash64AsBn(data, seed) {
    return new BN$8(xxhash64AsRaw(data, seed), 16);
  }

  function xxhashAsU8a(data, bitLength = 64, onlyJs = false) {
    const iterations = Math.ceil(bitLength / 64);
    const u8a = u8aToU8a(data);
    if (isReady() && !onlyJs) {
      return twox(u8a, iterations);
    }
    const result = new Uint8Array(Math.ceil(bitLength / 8));
    for (let seed = 0; seed < iterations; seed++) {
      result.set(xxhash64AsBn(u8a, seed).toArray('le', 8), seed * 8);
    }
    return result;
  }

  const emptyCheck = {
    extrinsic: {},
    payload: {}
  };

  const polkadot = {
    LimitParathreadCommits: emptyCheck,
    OnlyStakingAndClaims: emptyCheck,
    PrevalidateAttests: emptyCheck,
    RestrictFunctionality: emptyCheck,
    TransactionCallFilter: emptyCheck,
    ValidateDoubleVoteReports: emptyCheck
  };

  const shell = {
    DisallowSigned: emptyCheck
  };

  const statemint = {
    ChargeAssetTxPayment: {
      extrinsic: {
        tip: 'Compact<Balance>',
        assetId: 'Option<AssetId>'
      },
      payload: {}
    }
  };

  const CheckMortality = {
    extrinsic: {
      era: 'ExtrinsicEra'
    },
    payload: {
      blockHash: 'Hash'
    }
  };
  const substrate$1 = {
    ChargeTransactionPayment: {
      extrinsic: {
        tip: 'Compact<Balance>'
      },
      payload: {}
    },
    CheckBlockGasLimit: emptyCheck,
    CheckEra: CheckMortality,
    CheckGenesis: {
      extrinsic: {},
      payload: {
        genesisHash: 'Hash'
      }
    },
    CheckMortality,
    CheckNonce: {
      extrinsic: {
        nonce: 'Compact<Index>'
      },
      payload: {}
    },
    CheckSpecVersion: {
      extrinsic: {},
      payload: {
        specVersion: 'u32'
      }
    },
    CheckTxVersion: {
      extrinsic: {},
      payload: {
        transactionVersion: 'u32'
      }
    },
    CheckVersion: {
      extrinsic: {},
      payload: {
        specVersion: 'u32'
      }
    },
    CheckWeight: emptyCheck,
    LockStakingStatus: emptyCheck,
    ValidateEquivocationReport: emptyCheck
  };

  const allExtensions = objectSpread$1({}, substrate$1, polkadot, shell, statemint);
  const fallbackExtensions = ['CheckVersion', 'CheckGenesis', 'CheckEra', 'CheckNonce', 'CheckWeight', 'ChargeTransactionPayment', 'CheckBlockGasLimit'];
  function findUnknownExtensions(extensions, userExtensions = {}) {
    const names = [...Object.keys(allExtensions), ...Object.keys(userExtensions)];
    return extensions.filter(k => !names.includes(k));
  }
  function expandExtensionTypes(extensions, type, userExtensions = {}) {
    return extensions
    .map(key => userExtensions[key] || allExtensions[key]).filter(info => !!info).reduce((result, info) => objectSpread$1(result, info[type]), {});
  }

  function decodeEvent(registry, value) {
    if (!value || !value.length) {
      return {
        DataType: Null
      };
    }
    const index = value.subarray(0, 2);
    return {
      DataType: registry.findMetaEvent(index),
      value: {
        data: value.subarray(2),
        index
      }
    };
  }
  var _meta = _classPrivateFieldKey("meta");
  var _method = _classPrivateFieldKey("method");
  var _section = _classPrivateFieldKey("section");
  var _typeDef = _classPrivateFieldKey("typeDef");
  class GenericEventData extends Tuple {
    constructor(registry, value, meta, section = '<unknown>', method = '<unknown>') {
      const fields = (meta === null || meta === void 0 ? void 0 : meta.fields) || [];
      super(registry, fields.map(({
        type
      }) => registry.createLookupType(type)), value);
      Object.defineProperty(this, _meta, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _method, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _section, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _typeDef, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldBase(this, _meta)[_meta] = meta;
      _classPrivateFieldBase(this, _method)[_method] = method;
      _classPrivateFieldBase(this, _section)[_section] = section;
      _classPrivateFieldBase(this, _typeDef)[_typeDef] = fields.map(({
        type
      }) => registry.lookup.getTypeDef(type));
    }
    get meta() {
      return _classPrivateFieldBase(this, _meta)[_meta];
    }
    get method() {
      return _classPrivateFieldBase(this, _method)[_method];
    }
    get section() {
      return _classPrivateFieldBase(this, _section)[_section];
    }
    get typeDef() {
      return _classPrivateFieldBase(this, _typeDef)[_typeDef];
    }
  }
  class GenericEvent extends Struct {
    constructor(registry, _value) {
      const {
        DataType,
        value
      } = decodeEvent(registry, _value);
      super(registry, {
        index: 'EventId',
        data: DataType
      }, value);
    }
    get data() {
      return this.get('data');
    }
    get index() {
      return this.get('index');
    }
    get meta() {
      return this.data.meta;
    }
    get method() {
      return this.data.method;
    }
    get section() {
      return this.data.section;
    }
    get typeDef() {
      return this.data.typeDef;
    }
    toHuman(isExpanded) {
      return objectSpread$1({
        method: this.method,
        section: this.section
      }, isExpanded ? {
        docs: this.meta.docs.map(d => d.toString())
      } : null, super.toHuman(isExpanded));
    }
  }

  const BIT_SIGNED = 0b10000000;
  const BIT_UNSIGNED = 0;
  const EMPTY_U8A$1 = new Uint8Array();
  const DEFAULT_VERSION = 4;
  const IMMORTAL_ERA = new Uint8Array([0]);
  const UNMASK_VERSION = 0b01111111;

  const EXTRINSIC_VERSION = 4;
  class GenericExtrinsicV4 extends Struct {
    constructor(registry, value, {
      isSigned
    } = {}) {
      super(registry, {
        signature: 'ExtrinsicSignatureV4',
        method: 'Call'
      }, GenericExtrinsicV4.decodeExtrinsic(registry, value, isSigned));
    }
    static decodeExtrinsic(registry, value, isSigned = false) {
      if (value instanceof GenericExtrinsicV4) {
        return value;
      } else if (value instanceof registry.createClass('Call')) {
        return {
          method: value
        };
      } else if (isU8a$1(value)) {
        const signature = registry.createType('ExtrinsicSignatureV4', value, {
          isSigned
        });
        const method = registry.createType('Call', value.subarray(signature.encodedLength));
        return {
          method,
          signature
        };
      }
      return value || {};
    }
    get encodedLength() {
      return this.toU8a().length;
    }
    get method() {
      return this.get('method');
    }
    get signature() {
      return this.get('signature');
    }
    get version() {
      return EXTRINSIC_VERSION;
    }
    addSignature(signer, signature, payload) {
      this.signature.addSignature(signer, signature, payload);
      return this;
    }
    sign(account, options) {
      this.signature.sign(this.method, account, options);
      return this;
    }
    signFake(signer, options) {
      this.signature.signFake(this.method, signer, options);
      return this;
    }
  }

  const VERSIONS$1 = ['ExtrinsicUnknown',
  'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicUnknown', 'ExtrinsicV4'];
  class ExtrinsicBase extends Base$3 {
    constructor(registry, value, initialU8aLength) {
      super(registry, value, initialU8aLength);
      const signKeys = Object.keys(registry.getSignedExtensionTypes());
      const getter = key => this._raw.signature[key];
      for (let i = 0; i < signKeys.length; i++) {
        objectProperty(this, signKeys[i], getter);
      }
    }
    get args() {
      return this.method.args;
    }
    get argsDef() {
      return this.method.argsDef;
    }
    get callIndex() {
      return this.method.callIndex;
    }
    get data() {
      return this.method.data;
    }
    get era() {
      return this._raw.signature.era;
    }
    get encodedLength() {
      return this.toU8a().length;
    }
    get isSigned() {
      return this._raw.signature.isSigned;
    }
    get length() {
      return this.toU8a(true).length;
    }
    get meta() {
      return this.method.meta;
    }
    get method() {
      return this._raw.method;
    }
    get nonce() {
      return this._raw.signature.nonce;
    }
    get signature() {
      return this._raw.signature.signature;
    }
    get signer() {
      return this._raw.signature.signer;
    }
    get tip() {
      return this._raw.signature.tip;
    }
    get type() {
      return this._raw.version;
    }
    get version() {
      return this.type | (this.isSigned ? BIT_SIGNED : BIT_UNSIGNED);
    }
    is(other) {
      return this.method.is(other);
    }
  }
  var _hashCache = _classPrivateFieldKey("hashCache");
  class GenericExtrinsic extends ExtrinsicBase {
    constructor(registry, value, {
      version
    } = {}) {
      super(registry, GenericExtrinsic._decodeExtrinsic(registry, value, version));
      Object.defineProperty(this, _hashCache, {
        writable: true,
        value: void 0
      });
    }
    static _newFromValue(registry, value, version) {
      if (value instanceof GenericExtrinsic) {
        return value._raw;
      }
      const isSigned = (version & BIT_SIGNED) === BIT_SIGNED;
      const type = VERSIONS$1[version & UNMASK_VERSION] || VERSIONS$1[0];
      return registry.createType(type, value, {
        isSigned,
        version
      });
    }
    static _decodeExtrinsic(registry, value, version = DEFAULT_VERSION) {
      if (isU8a$1(value) || Array.isArray(value) || isHex$1(value)) {
        return GenericExtrinsic._decodeU8a(registry, u8aToU8a$1(value), version);
      } else if (value instanceof registry.createClass('Call')) {
        return GenericExtrinsic._newFromValue(registry, {
          method: value
        }, version);
      }
      return GenericExtrinsic._newFromValue(registry, value, version);
    }
    static _decodeU8a(registry, value, version) {
      if (!value.length) {
        return GenericExtrinsic._newFromValue(registry, new Uint8Array(), version);
      }
      const [offset, length] = compactFromU8a(value);
      const total = offset + length.toNumber();
      assert$h(total <= value.length, () => `Extrinsic: length less than remainder, expected at least ${total}, found ${value.length}`);
      const data = value.subarray(offset, total);
      return GenericExtrinsic._newFromValue(registry, data.subarray(1), data[0]);
    }
    get hash() {
      if (!_classPrivateFieldBase(this, _hashCache)[_hashCache]) {
        _classPrivateFieldBase(this, _hashCache)[_hashCache] = super.hash;
      }
      return _classPrivateFieldBase(this, _hashCache)[_hashCache];
    }
    addSignature(signer, signature, payload) {
      this._raw.addSignature(signer, signature, payload);
      _classPrivateFieldBase(this, _hashCache)[_hashCache] = undefined;
      return this;
    }
    sign(account, options) {
      this._raw.sign(account, options);
      _classPrivateFieldBase(this, _hashCache)[_hashCache] = undefined;
      return this;
    }
    signFake(signer, options) {
      this._raw.signFake(signer, options);
      _classPrivateFieldBase(this, _hashCache)[_hashCache] = undefined;
      return this;
    }
    toHex(isBare) {
      return u8aToHex$1(this.toU8a(isBare));
    }
    toHuman(isExpanded) {
      return objectSpread$1({}, {
        isSigned: this.isSigned,
        method: this.method.toHuman(isExpanded)
      }, this.isSigned ? {
        era: this.era.toHuman(isExpanded),
        nonce: this.nonce.toHuman(isExpanded),
        signature: this.signature.toHex(),
        signer: this.signer.toHuman(isExpanded),
        tip: this.tip.toHuman(isExpanded)
      } : null);
    }
    toJSON() {
      return this.toHex();
    }
    toRawType() {
      return 'Extrinsic';
    }
    toU8a(isBare) {
      const encoded = u8aConcat$1(new Uint8Array([this.version]), this._raw.toU8a());
      return isBare ? encoded : compactAddLength(encoded);
    }
  }

  function getTrailingZeros(period) {
    const binary = period.toString(2);
    let index = 0;
    while (binary[binary.length - 1 - index] === '0') {
      index++;
    }
    return index;
  }
  class ImmortalEra extends Raw {
    constructor(registry, value) {
      super(registry, IMMORTAL_ERA);
    }
  }
  class MortalEra extends Tuple {
    constructor(registry, value) {
      super(registry, {
        period: u64,
        phase: u64
      }, MortalEra._decodeMortalEra(registry, value));
    }
    static _decodeMortalEra(registry, value) {
      if (isU8a$1(value) || isHex$1(value) || Array.isArray(value)) {
        return MortalEra._decodeMortalU8a(registry, u8aToU8a$1(value));
      } else if (!value) {
        return [new u64(registry), new u64(registry)];
      } else if (isObject(value)) {
        return MortalEra._decodeMortalObject(registry, value);
      }
      throw new Error('Invalid data passed to Mortal era');
    }
    static _decodeMortalObject(registry, value) {
      const {
        current,
        period
      } = value;
      let calPeriod = Math.pow(2, Math.ceil(Math.log2(period)));
      calPeriod = Math.min(Math.max(calPeriod, 4), 1 << 16);
      const phase = current % calPeriod;
      const quantizeFactor = Math.max(calPeriod >> 12, 1);
      const quantizedPhase = phase / quantizeFactor * quantizeFactor;
      return [new u64(registry, calPeriod), new u64(registry, quantizedPhase)];
    }
    static _decodeMortalU8a(registry, value) {
      if (value.length === 0) {
        return [new u64(registry), new u64(registry)];
      }
      const first = u8aToBn(value.subarray(0, 1)).toNumber();
      const second = u8aToBn(value.subarray(1, 2)).toNumber();
      const encoded = first + (second << 8);
      const period = 2 << encoded % (1 << 4);
      const quantizeFactor = Math.max(period >> 12, 1);
      const phase = (encoded >> 4) * quantizeFactor;
      assert$h(period >= 4 && phase < period, 'Invalid data passed to Mortal era');
      return [new u64(registry, period), new u64(registry, phase)];
    }
    get encodedLength() {
      return 2;
    }
    get period() {
      return this[0];
    }
    get phase() {
      return this[1];
    }
    toHuman() {
      return {
        period: formatNumber(this.period),
        phase: formatNumber(this.phase)
      };
    }
    toJSON() {
      return this.toHex();
    }
    toU8a(isBare) {
      const period = this.period.toNumber();
      const phase = this.phase.toNumber();
      const quantizeFactor = Math.max(period >> 12, 1);
      const trailingZeros = getTrailingZeros(period);
      const encoded = Math.min(15, Math.max(1, trailingZeros - 1)) + (phase / quantizeFactor << 4);
      const first = encoded >> 8;
      const second = encoded & 0xff;
      return new Uint8Array([second, first]);
    }
    birth(current) {
      return Math.floor((Math.max(bnToBn$1(current).toNumber(), this.phase.toNumber()) - this.phase.toNumber()) / this.period.toNumber()) * this.period.toNumber() + this.phase.toNumber();
    }
    death(current) {
      return this.birth(current) + this.period.toNumber();
    }
  }
  class GenericExtrinsicEra extends Enum {
    constructor(registry, value) {
      super(registry, {
        ImmortalEra,
        MortalEra
      }, GenericExtrinsicEra._decodeExtrinsicEra(value));
    }
    static _decodeExtrinsicEra(value = new Uint8Array()) {
      if (isU8a$1(value)) {
        return !value.length || value[0] === 0 ? new Uint8Array([0]) : new Uint8Array([1, value[0], value[1]]);
      } else if (!value) {
        return new Uint8Array([0]);
      } else if (value instanceof GenericExtrinsicEra) {
        return GenericExtrinsicEra._decodeExtrinsicEra(value.toU8a());
      } else if (isHex$1(value)) {
        return GenericExtrinsicEra._decodeExtrinsicEra(hexToU8a$1(value));
      } else if (isObject(value)) {
        const entries = Object.entries(value).map(([k, v]) => [k.toLowerCase(), v]);
        const mortal = entries.find(([k]) => k.toLowerCase() === 'mortalera');
        const immortal = entries.find(([k]) => k.toLowerCase() === 'immortalera');
        return mortal ? {
          MortalEra: mortal[1]
        } : immortal ? {
          ImmortalEra: immortal[1]
        } : {
          MortalEra: value
        };
      }
      throw new Error('Invalid data passed to Era');
    }
    get encodedLength() {
      return this.isImmortalEra ? this.asImmortalEra.encodedLength : this.asMortalEra.encodedLength;
    }
    get asImmortalEra() {
      assert$h(this.isImmortalEra, () => `Cannot convert '${this.type}' via asImmortalEra`);
      return this.value;
    }
    get asMortalEra() {
      assert$h(this.isMortalEra, () => `Cannot convert '${this.type}' via asMortalEra`);
      return this.value;
    }
    get isImmortalEra() {
      return this.index === 0;
    }
    get isMortalEra() {
      return this.index > 0;
    }
    toU8a(isBare) {
      return this.isMortalEra ? this.asMortalEra.toU8a(isBare) : this.asImmortalEra.toU8a(isBare);
    }
  }

  const VERSIONS = ['ExtrinsicPayloadUnknown',
  'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadUnknown', 'ExtrinsicPayloadV4'];
  class GenericExtrinsicPayload extends Base$3 {
    constructor(registry, value, {
      version
    } = {}) {
      super(registry, GenericExtrinsicPayload.decodeExtrinsicPayload(registry, value, version));
    }
    static decodeExtrinsicPayload(registry, value, version = DEFAULT_VERSION) {
      if (value instanceof GenericExtrinsicPayload) {
        return value._raw;
      }
      return registry.createType(VERSIONS[version] || VERSIONS[0], value, {
        version
      });
    }
    get blockHash() {
      return this._raw.blockHash;
    }
    get era() {
      return this._raw.era;
    }
    get genesisHash() {
      return this._raw.genesisHash || this.registry.createType('Hash');
    }
    get method() {
      return this._raw.method;
    }
    get nonce() {
      return this._raw.nonce;
    }
    get specVersion() {
      return this._raw.specVersion || this.registry.createType('u32');
    }
    get tip() {
      return this._raw.tip || this.registry.createType('Compact<Balance>');
    }
    get transactionVersion() {
      return this._raw.transactionVersion || this.registry.createType('u32');
    }
    eq(other) {
      return this._raw.eq(other);
    }
    sign(signerPair) {
      const signature = this._raw.sign(signerPair);
      return {
        signature: u8aToHex$1(signature)
      };
    }
    toHuman(isExtended) {
      return this._raw.toHuman(isExtended);
    }
    toJSON() {
      return this.toHex();
    }
    toString() {
      return this.toHex();
    }
    toU8a(isBare) {
      return super.toU8a(isBare ? {
        method: true
      } : false);
    }
  }

  class GenericExtrinsicPayloadUnknown extends Struct {
    constructor(registry, value, {
      version = 0
    } = {}) {
      super(registry, {});
      throw new Error(`Unsupported extrinsic payload version ${version}`);
    }
  }

  class GenericExtrinsicUnknown extends Struct {
    constructor(registry, value, {
      isSigned = false,
      version = 0
    } = {}) {
      super(registry, {});
      throw new Error(`Unsupported ${isSigned ? '' : 'un'}signed extrinsic version ${version & UNMASK_VERSION}`);
    }
  }

  const knownTypes = {
    address: 'Address',
    blockHash: 'Hash',
    blockNumber: 'BlockNumber',
    era: 'ExtrinsicEra',
    genesisHash: 'Hash',
    method: 'Call',
    nonce: 'Compact<Index>',
    runtimeVersion: 'RuntimeVersion',
    signedExtensions: 'Vec<Text>',
    tip: 'Compact<Balance>',
    version: 'u8'
  };
  class GenericSignerPayload extends Struct {
    constructor(registry, value) {
      const extensionTypes = objectSpread$1({}, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra());
      super(registry, objectSpread$1({}, extensionTypes, knownTypes), value);
      this._extraTypes = void 0;
      this._extraTypes = {};
      const getter = key => this.get(key);
      for (const [key, type] of Object.entries(extensionTypes)) {
        if (!knownTypes[key]) {
          this._extraTypes[key] = type;
        }
        objectProperty(this, key, getter);
      }
    }
    get address() {
      return this.get('address');
    }
    get blockHash() {
      return this.get('blockHash');
    }
    get blockNumber() {
      return this.get('blockNumber');
    }
    get era() {
      return this.get('era');
    }
    get genesisHash() {
      return this.get('genesisHash');
    }
    get method() {
      return this.get('method');
    }
    get nonce() {
      return this.get('nonce');
    }
    get runtimeVersion() {
      return this.get('runtimeVersion');
    }
    get signedExtensions() {
      return this.get('signedExtensions');
    }
    get tip() {
      return this.get('tip');
    }
    get version() {
      return this.get('version');
    }
    toPayload() {
      const result = {};
      const keys = Object.keys(this._extraTypes);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = this.get(key);
        const isOption = value instanceof Option;
        if (!isOption || value.isSome) {
          result[key] = value.toHex();
        }
      }
      return objectSpread$1(result, {
        address: this.address.toString(),
        blockHash: this.blockHash.toHex(),
        blockNumber: this.blockNumber.toHex(),
        era: this.era.toHex(),
        genesisHash: this.genesisHash.toHex(),
        method: this.method.toHex(),
        nonce: this.nonce.toHex(),
        signedExtensions: this.signedExtensions.map(e => e.toString()),
        specVersion: this.runtimeVersion.specVersion.toHex(),
        tip: this.tip.toHex(),
        transactionVersion: this.runtimeVersion.transactionVersion.toHex(),
        version: this.version.toNumber()
      });
    }
    toRaw() {
      const payload = this.toPayload();
      const data = u8aToHex$1(this.registry.createType('ExtrinsicPayload', payload, {
        version: payload.version
      })
      .toU8a({
        method: true
      }));
      return {
        address: payload.address,
        data,
        type: 'payload'
      };
    }
  }

  function sign(registry, signerPair, u8a, options) {
    const encoded = u8a.length > 256 ? registry.hash(u8a) : u8a;
    return signerPair.sign(encoded, options);
  }

  var _signOptions = _classPrivateFieldKey("signOptions");
  class GenericExtrinsicPayloadV4 extends Struct {
    constructor(registry, value) {
      super(registry, objectSpread$1({
        method: 'Bytes'
      }, registry.getSignedExtensionTypes(), registry.getSignedExtensionExtra()), value);
      Object.defineProperty(this, _signOptions, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldBase(this, _signOptions)[_signOptions] = {
        withType: registry.createType('ExtrinsicSignature') instanceof Enum
      };
    }
    get blockHash() {
      return this.get('blockHash');
    }
    get era() {
      return this.get('era');
    }
    get genesisHash() {
      return this.get('genesisHash');
    }
    get method() {
      return this.get('method');
    }
    get nonce() {
      return this.get('nonce');
    }
    get specVersion() {
      return this.get('specVersion');
    }
    get tip() {
      return this.get('tip');
    }
    get transactionVersion() {
      return this.get('transactionVersion');
    }
    get assetId() {
      return this.get('assetId');
    }
    sign(signerPair) {
      return sign(this.registry, signerPair, this.toU8a({
        method: true
      }), _classPrivateFieldBase(this, _signOptions)[_signOptions]);
    }
  }

  const FAKE_NONE = new Uint8Array();
  const FAKE_SOME = new Uint8Array([1]);
  function toAddress(registry, address) {
    return registry.createType('Address', isU8a$1(address) ? u8aToHex$1(address) : address);
  }
  var _fakePrefix = _classPrivateFieldKey("fakePrefix");
  var _signKeys = _classPrivateFieldKey("signKeys");
  class GenericExtrinsicSignatureV4 extends Struct {
    constructor(registry, value, {
      isSigned
    } = {}) {
      const signTypes = registry.getSignedExtensionTypes();
      super(registry, objectSpread$1(
      {
        signer: 'Address',
        signature: 'ExtrinsicSignature'
      }, signTypes), GenericExtrinsicSignatureV4.decodeExtrinsicSignature(value, isSigned));
      Object.defineProperty(this, _fakePrefix, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _signKeys, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldBase(this, _fakePrefix)[_fakePrefix] = registry.createType('ExtrinsicSignature') instanceof Enum ? FAKE_SOME : FAKE_NONE;
      _classPrivateFieldBase(this, _signKeys)[_signKeys] = Object.keys(signTypes);
      objectProperties(this, _classPrivateFieldBase(this, _signKeys)[_signKeys], k => this.get(k));
    }
    static decodeExtrinsicSignature(value, isSigned = false) {
      if (!value) {
        return EMPTY_U8A$1;
      } else if (value instanceof GenericExtrinsicSignatureV4) {
        return value;
      }
      return isSigned ? value : EMPTY_U8A$1;
    }
    get encodedLength() {
      return this.isSigned ? super.encodedLength : 0;
    }
    get isSigned() {
      return !this.signature.isEmpty;
    }
    get era() {
      return this.get('era');
    }
    get nonce() {
      return this.get('nonce');
    }
    get signature() {
      return this.multiSignature.value || this.multiSignature;
    }
    get multiSignature() {
      return this.get('signature');
    }
    get signer() {
      return this.get('signer');
    }
    get tip() {
      return this.get('tip');
    }
    _injectSignature(signer, signature, payload) {
      for (let i = 0; i < _classPrivateFieldBase(this, _signKeys)[_signKeys].length; i++) {
        const k = _classPrivateFieldBase(this, _signKeys)[_signKeys][i];
        const v = payload.get(k);
        if (!isUndefined(v)) {
          this.set(k, v);
        }
      }
      this.set('signer', signer);
      this.set('signature', signature);
      return this;
    }
    addSignature(signer, signature, payload) {
      return this._injectSignature(toAddress(this.registry, signer), this.registry.createType('ExtrinsicSignature', signature), new GenericExtrinsicPayloadV4(this.registry, payload));
    }
    createPayload(method, options) {
      const {
        era,
        runtimeVersion: {
          specVersion,
          transactionVersion
        }
      } = options;
      return new GenericExtrinsicPayloadV4(this.registry, objectSpread$1({}, options, {
        era: era || IMMORTAL_ERA,
        method: method.toHex(),
        specVersion,
        transactionVersion
      }));
    }
    sign(method, account, options) {
      assert$h(account && account.addressRaw, () => `Expected a valid keypair for signing, found ${stringify(account)}`);
      const signer = toAddress(this.registry, account.addressRaw);
      const payload = this.createPayload(method, options);
      const signature = this.registry.createType('ExtrinsicSignature', payload.sign(account));
      return this._injectSignature(signer, signature, payload);
    }
    signFake(method, address, options) {
      assert$h(address, () => `Expected a valid address for signing, found ${stringify(address)}`);
      const signer = toAddress(this.registry, address);
      const payload = this.createPayload(method, options);
      const signature = this.registry.createType('ExtrinsicSignature', u8aConcat$1(_classPrivateFieldBase(this, _fakePrefix)[_fakePrefix], new Uint8Array(64).fill(0x42)));
      return this._injectSignature(signer, signature, payload);
    }
    toU8a(isBare) {
      return this.isSigned ? super.toU8a(isBare) : EMPTY_U8A$1;
    }
  }

  function decodeAccountId$1(value) {
    if (isU8a$1(value) || Array.isArray(value)) {
      return u8aToU8a$1(value);
    } else if (isHex$1(value) || isEthereumAddress(value)) {
      return hexToU8a$1(value);
    } else if (isString$1(value)) {
      return u8aToU8a$1(value);
    }
    return value;
  }
  class GenericEthereumAccountId extends U8aFixed {
    constructor(registry, value = new Uint8Array()) {
      super(registry, decodeAccountId$1(value), 160);
    }
    static encode(value) {
      return ethereumEncode(value);
    }
    eq(other) {
      return super.eq(decodeAccountId$1(other));
    }
    toHuman() {
      return this.toJSON();
    }
    toJSON() {
      return this.toString();
    }
    toString() {
      return GenericEthereumAccountId.encode(this);
    }
    toRawType() {
      return 'AccountId';
    }
  }

  const PREFIX_1BYTE = 0xef;
  const PREFIX_2BYTE = 0xfc;
  const PREFIX_4BYTE = 0xfd;
  const PREFIX_8BYTE = 0xfe;
  const MAX_1BYTE = new BN$8(PREFIX_1BYTE);
  const MAX_2BYTE = new BN$8(1).shln(16);
  const MAX_4BYTE = new BN$8(1).shln(32);
  function decodeAccountIndex(value) {
    if (value instanceof GenericAccountIndex) {
      return value.toBn();
    } else if (isBn(value) || isNumber$1(value) || isHex$1(value) || isU8a$1(value) || isBigInt$1(value)) {
      return value;
    }
    return decodeAccountIndex(decodeAddress(value));
  }
  class GenericAccountIndex extends u32$1 {
    constructor(registry, value = new BN$8(0)) {
      super(registry, decodeAccountIndex(value));
    }
    static calcLength(_value) {
      const value = bnToBn$1(_value);
      if (value.lte(MAX_1BYTE)) {
        return 1;
      } else if (value.lt(MAX_2BYTE)) {
        return 2;
      } else if (value.lt(MAX_4BYTE)) {
        return 4;
      }
      return 8;
    }
    static readLength(input) {
      const first = input[0];
      if (first === PREFIX_2BYTE) {
        return [1, 2];
      } else if (first === PREFIX_4BYTE) {
        return [1, 4];
      } else if (first === PREFIX_8BYTE) {
        return [1, 8];
      }
      return [0, 1];
    }
    static writeLength(input) {
      switch (input.length) {
        case 2:
          return new Uint8Array([PREFIX_2BYTE]);
        case 4:
          return new Uint8Array([PREFIX_4BYTE]);
        case 8:
          return new Uint8Array([PREFIX_8BYTE]);
        default:
          return new Uint8Array([]);
      }
    }
    eq(other) {
      if (isBn(other) || isNumber$1(other)) {
        return super.eq(other);
      }
      return super.eq(this.registry.createType('AccountIndex', other));
    }
    toHuman() {
      return this.toJSON();
    }
    toJSON() {
      return this.toString();
    }
    toString() {
      const length = GenericAccountIndex.calcLength(this);
      return encodeAddress(this.toU8a().subarray(0, length), this.registry.chainSS58);
    }
    toRawType() {
      return 'AccountIndex';
    }
  }

  const ACCOUNT_ID_PREFIX$1 = new Uint8Array([0xff]);
  function decodeString$1(registry, value) {
    const decoded = decodeAddress(value);
    return decoded.length === 20 ? registry.createType('EthereumAccountId', decoded) : registry.createType('AccountIndex', u8aToBn(decoded, true));
  }
  function decodeU8a$2(registry, value) {
    if (value.length === 20) {
      return registry.createType('EthereumAccountId', value);
    } else if (value[0] === 0xff) {
      return registry.createType('EthereumAccountId', value.subarray(1));
    }
    const [offset, length] = GenericAccountIndex.readLength(value);
    return registry.createType('AccountIndex', u8aToBn(value.subarray(offset, offset + length), true));
  }
  class GenericEthereumLookupSource extends Base$3 {
    constructor(registry, value = new Uint8Array()) {
      super(registry, GenericEthereumLookupSource._decodeAddress(registry, value));
    }
    static _decodeAddress(registry, value) {
      return value instanceof GenericEthereumLookupSource ? value._raw : value instanceof GenericEthereumAccountId || value instanceof GenericAccountIndex ? value : isU8a$1(value) || Array.isArray(value) || isHex$1(value) ? decodeU8a$2(registry, u8aToU8a$1(value)) : isBn(value) || isNumber$1(value) || isBigInt$1(value) ? registry.createType('AccountIndex', value) : decodeString$1(registry, value);
    }
    get encodedLength() {
      const rawLength = this._rawLength;
      return rawLength + (
      rawLength > 1 ? 1 : 0);
    }
    get _rawLength() {
      return this._raw instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this._raw) : this._raw.encodedLength;
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toRawType() {
      return 'Address';
    }
    toU8a(isBare) {
      const encoded = this._raw.toU8a().subarray(0, this._rawLength);
      return isBare ? encoded : u8aConcat$1(this._raw instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX$1, encoded);
    }
  }

  function decodeAccountId(value) {
    if (isU8a$1(value) || Array.isArray(value)) {
      return u8aToU8a$1(value);
    } else if (!value) {
      return new Uint8Array();
    } else if (isHex$1(value)) {
      return hexToU8a$1(value);
    } else if (isString$1(value)) {
      return decodeAddress(value);
    }
    throw new Error(`Unknown type passed to AccountId constructor, found typeof ${typeof value}`);
  }
  class GenericAccountId extends U8aFixed {
    constructor(registry, value) {
      const decoded = decodeAccountId(value);
      assert$h(decoded.length >= 32 || !decoded.some(b => b), () => `Invalid AccountId provided, expected 32 bytes, found ${decoded.length}`);
      super(registry, decoded, 256);
    }
    eq(other) {
      return super.eq(decodeAccountId(other));
    }
    toHuman() {
      return this.toJSON();
    }
    toJSON() {
      return this.toString();
    }
    toString() {
      return encodeAddress(this, this.registry.chainSS58);
    }
    toRawType() {
      return 'AccountId';
    }
  }

  class GenericBlock extends Struct {
    constructor(registry, value) {
      super(registry, {
        header: 'Header',
        extrinsics: 'Vec<Extrinsic>'
      }, value);
    }
    get contentHash() {
      return this.registry.hash(this.toU8a());
    }
    get extrinsics() {
      return this.get('extrinsics');
    }
    get hash() {
      return this.header.hash;
    }
    get header() {
      return this.get('header');
    }
  }

  function getArgsDef(registry, meta) {
    return meta.fields.reduce((result, {
      name,
      type
    }, index) => {
      result[name.unwrapOr(`param${index}`).toString()] = registry.createLookupType(type);
      return result;
    }, {});
  }
  function decodeCallViaObject(registry, value, _meta) {
    const {
      args,
      callIndex
    } = value;
    const lookupIndex = callIndex instanceof GenericCallIndex ? callIndex.toU8a() : callIndex;
    const meta = _meta || registry.findMetaCall(lookupIndex).meta;
    return {
      args,
      argsDef: getArgsDef(registry, meta),
      callIndex,
      meta
    };
  }
  function decodeCallViaU8a(registry, value, _meta) {
    const callIndex = new Uint8Array(2);
    callIndex.set(value.subarray(0, 2), 0);
    const meta = _meta || registry.findMetaCall(callIndex).meta;
    return {
      args: value.subarray(2),
      argsDef: getArgsDef(registry, meta),
      callIndex,
      meta
    };
  }
  function decodeCall(registry, value = new Uint8Array(), _meta) {
    if (isU8a$1(value) || isHex$1(value)) {
      return decodeCallViaU8a(registry, u8aToU8a$1(value), _meta);
    } else if (isObject(value) && value.callIndex && value.args) {
      return decodeCallViaObject(registry, value, _meta);
    }
    throw new Error(`Call: Cannot decode value '${value}' of type ${typeof value}`);
  }
  class GenericCallIndex extends U8aFixed {
    constructor(registry, value) {
      super(registry, value, 16);
    }
  }
  class GenericCall extends Struct {
    constructor(registry, value, meta) {
      const decoded = decodeCall(registry, value, meta);
      try {
        super(registry, {
          callIndex: GenericCallIndex,
          args: Struct.with(decoded.argsDef)
        }, decoded);
        this._meta = void 0;
      } catch (error) {
        let method = 'unknown.unknown';
        try {
          const c = registry.findMetaCall(decoded.callIndex);
          method = `${c.section}.${c.method}`;
        } catch (error) {
        }
        throw new Error(`Call: failed decoding ${method}:: ${error.message}`);
      }
      this._meta = decoded.meta;
    }
    get args() {
      return [...this.get('args').values()];
    }
    get argsDef() {
      return getArgsDef(this.registry, this.meta);
    }
    get argsEntries() {
      return [...this.get('args').entries()];
    }
    get callIndex() {
      return this.get('callIndex').toU8a();
    }
    get data() {
      return this.get('args').toU8a();
    }
    get meta() {
      return this._meta;
    }
    get method() {
      return this.registry.findMetaCall(this.callIndex).method;
    }
    get section() {
      return this.registry.findMetaCall(this.callIndex).section;
    }
    is(other) {
      return other.callIndex[0] === this.callIndex[0] && other.callIndex[1] === this.callIndex[1];
    }
    toHuman(isExpanded) {
      var _call, _call2;
      let call;
      try {
        call = this.registry.findMetaCall(this.callIndex);
      } catch (error) {
      }
      return objectSpread$1({
        args: this.argsEntries.reduce((args, [n, a]) => objectSpread$1(args, {
          [n]: a.toHuman(isExpanded)
        }), {}),
        method: (_call = call) === null || _call === void 0 ? void 0 : _call.method,
        section: (_call2 = call) === null || _call2 === void 0 ? void 0 : _call2.section
      }, isExpanded && call ? {
        docs: call.meta.docs.map(d => d.toString())
      } : null);
    }
    toRawType() {
      return 'Call';
    }
  }

  function createValue(registry, type, value, asArray = true) {
    if (value && isFunction$1(value.unwrapOrDefault)) {
      return value;
    }
    return registry.createType(type, asArray ? isNull(value) || isUndefined(value) ? null : Array.isArray(value) ? value : [value] : value);
  }
  function decodeValue(registry, key, value) {
    return key === 'ss58Format' ? createValue(registry, 'Option<u32>', value, false) : key === 'tokenDecimals' ? createValue(registry, 'Option<Vec<u32>>', value) : key === 'tokenSymbol' ? createValue(registry, 'Option<Vec<Text>>', value) : value;
  }
  function decode(registry, value) {
    return (
    value && isFunction$1(value.entries) ? [...value.entries()] : Object.entries(value || {})).reduce((all, [key, value]) => {
      all[key] = decodeValue(registry, key, value);
      return all;
    }, {
      ss58Format: registry.createType('Option<u32>'),
      tokenDecimals: registry.createType('Option<Vec<u32>>'),
      tokenSymbol: registry.createType('Option<Vec<Text>>')
    });
  }
  class GenericChainProperties extends Json {
    constructor(registry, value) {
      super(registry, decode(registry, value));
    }
    get ss58Format() {
      return this.get('ss58Format');
    }
    get tokenDecimals() {
      return this.get('tokenDecimals');
    }
    get tokenSymbol() {
      return this.get('tokenSymbol');
    }
  }

  const CID_AURA = stringToU8a$1('aura');
  const CID_BABE = stringToU8a$1('BABE');
  const CID_GRPA = stringToU8a$1('FRNK');
  const CID_POW = stringToU8a$1('pow_');
  class GenericConsensusEngineId extends U8aFixed {
    constructor(registry, value) {
      super(registry, isNumber$1(value) ? bnToU8a$1(value, {
        isLe: false
      }) : value, 32);
    }
    get isAura() {
      return this.eq(CID_AURA);
    }
    get isBabe() {
      return this.eq(CID_BABE);
    }
    get isGrandpa() {
      return this.eq(CID_GRPA);
    }
    get isPow() {
      return this.eq(CID_POW);
    }
    _getAuraAuthor(bytes, sessionValidators) {
      return sessionValidators[this.registry.createType('RawAuraPreDigest', bytes.toU8a(true)).slotNumber.mod(new BN$8(sessionValidators.length)).toNumber()];
    }
    _getBabeAuthor(bytes, sessionValidators) {
      const digest = this.registry.createType('RawBabePreDigestCompat', bytes.toU8a(true));
      return sessionValidators[digest.value.toNumber()];
    }
    _getBytesAsAuthor(bytes) {
      return this.registry.createType('AccountId', bytes);
    }
    extractAuthor(bytes, sessionValidators) {
      if (sessionValidators !== null && sessionValidators !== void 0 && sessionValidators.length) {
        if (this.isAura) {
          return this._getAuraAuthor(bytes, sessionValidators);
        } else if (this.isBabe) {
          return this._getBabeAuthor(bytes, sessionValidators);
        }
      }
      if (this.isPow || bytes.length === 20) {
        return this._getBytesAsAuthor(bytes);
      }
      return undefined;
    }
    toHuman() {
      return this.toString();
    }
    toRawType() {
      return 'ConsensusEngineId';
    }
    toString() {
      return this.isAscii ? u8aToString$1(this) : u8aToHex$1(this);
    }
  }

  const ACCOUNT_ID_PREFIX = new Uint8Array([0xff]);
  function decodeString(registry, value) {
    const decoded = decodeAddress(value);
    return decoded.length === 32 ? registry.createType('AccountId', decoded) : registry.createType('AccountIndex', u8aToBn(decoded, true));
  }
  function decodeU8a$1(registry, value) {
    if (value.length === 32) {
      return registry.createType('AccountId', value);
    } else if (value[0] === 0xff) {
      return registry.createType('AccountId', value.subarray(1));
    }
    const [offset, length] = GenericAccountIndex.readLength(value);
    return registry.createType('AccountIndex', u8aToBn(value.subarray(offset, offset + length), true));
  }
  class GenericLookupSource extends Base$3 {
    constructor(registry, value = new Uint8Array()) {
      super(registry, GenericLookupSource._decodeAddress(registry, value));
    }
    static _decodeAddress(registry, value) {
      return value instanceof GenericLookupSource ? value._raw : value instanceof GenericAccountId || value instanceof GenericAccountIndex ? value : isBn(value) || isNumber$1(value) || isBigInt$1(value) ? registry.createType('AccountIndex', value) : Array.isArray(value) || isHex$1(value) || isU8a$1(value) ? decodeU8a$1(registry, u8aToU8a$1(value)) : decodeString(registry, value);
    }
    get encodedLength() {
      const rawLength = this._rawLength;
      return rawLength + (
      rawLength > 1 ? 1 : 0);
    }
    get _rawLength() {
      return this._raw instanceof GenericAccountIndex ? GenericAccountIndex.calcLength(this._raw) : this._raw.encodedLength;
    }
    toHex() {
      return u8aToHex$1(this.toU8a());
    }
    toRawType() {
      return 'Address';
    }
    toU8a(isBare) {
      const encoded = this._raw.toU8a().subarray(0, this._rawLength);
      return isBare ? encoded : u8aConcat$1(this._raw instanceof GenericAccountIndex ? GenericAccountIndex.writeLength(encoded) : ACCOUNT_ID_PREFIX, encoded);
    }
  }

  function decodeU8a(registry, u8a) {
    if ([0, 32].includes(u8a.length)) {
      return {
        Id: u8a
      };
    } else if (u8a.length === 20) {
      return {
        Address20: u8a
      };
    } else if (u8a.length <= 8) {
      return {
        Index: registry.createType('AccountIndex', u8a).toNumber()
      };
    }
    return u8a;
  }
  function decodeMultiAny(registry, value) {
    if (value instanceof GenericAccountId) {
      return {
        Id: value
      };
    } else if (isU8a$1(value)) {
      return decodeU8a(registry, value);
    } else if (value instanceof GenericMultiAddress) {
      return value;
    } else if (value instanceof GenericAccountIndex || isBn(value) || isNumber$1(value)) {
      return {
        Index: isNumber$1(value) ? value : value.toNumber()
      };
    } else if (isString$1(value)) {
      return decodeU8a(registry, decodeAddress(value.toString()));
    }
    return value;
  }
  class GenericMultiAddress extends Enum {
    constructor(registry, value) {
      super(registry, {
        Id: 'AccountId',
        Index: 'Compact<AccountIndex>',
        Raw: 'Bytes',
        Address32: 'H256',
        Address20: 'H160'
      }, decodeMultiAny(registry, value));
    }
    toString() {
      return this.value.toString();
    }
  }

  const AYE_BITS = 0b10000000;
  const NAY_BITS = 0b00000000;
  const CON_MASK = 0b01111111;
  const DEF_CONV = 0b00000000;
  function decodeVoteBool(value) {
    return value ? new Uint8Array([AYE_BITS | DEF_CONV]) : new Uint8Array([NAY_BITS]);
  }
  function decodeVoteU8a(value) {
    return value.length ? value.subarray(0, 1) : new Uint8Array([NAY_BITS]);
  }
  function decodeVoteType(registry, value) {
    const vote = new bool(registry, value.aye).isTrue ? AYE_BITS : NAY_BITS;
    const conviction = registry.createType('Conviction', value.conviction || DEF_CONV);
    return new Uint8Array([vote | conviction.index]);
  }
  function decodeVote(registry, value) {
    if (isU8a$1(value)) {
      return decodeVoteU8a(value);
    } else if (isUndefined(value) || value instanceof Boolean || isBoolean$1(value)) {
      return decodeVoteBool(new bool(registry, value).isTrue);
    } else if (isNumber$1(value)) {
      return decodeVoteBool(value < 0);
    }
    return decodeVoteType(registry, value);
  }
  class GenericVote extends U8aFixed {
    constructor(registry, value) {
      const decoded = decodeVote(registry, value);
      super(registry, decoded, 8);
      this._aye = void 0;
      this._conviction = void 0;
      this._aye = (decoded[0] & AYE_BITS) === AYE_BITS;
      this._conviction = this.registry.createType('Conviction', decoded[0] & CON_MASK);
    }
    get conviction() {
      return this._conviction;
    }
    get isAye() {
      return this._aye;
    }
    get isNay() {
      return !this.isAye;
    }
    toHuman(isExpanded) {
      return {
        conviction: this.conviction.toHuman(isExpanded),
        vote: this.isAye ? 'Aye' : 'Nay'
      };
    }
    toRawType() {
      return 'Vote';
    }
  }

  const baseTypes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    GenericExtrinsic: GenericExtrinsic,
    GenericExtrinsicEra: GenericExtrinsicEra,
    GenericMortalEra: MortalEra,
    GenericImmortalEra: ImmortalEra,
    GenericExtrinsicPayload: GenericExtrinsicPayload,
    GenericExtrinsicPayloadUnknown: GenericExtrinsicPayloadUnknown,
    GenericExtrinsicUnknown: GenericExtrinsicUnknown,
    GenericSignerPayload: GenericSignerPayload,
    GenericExtrinsicV4: GenericExtrinsicV4,
    GenericExtrinsicPayloadV4: GenericExtrinsicPayloadV4,
    GenericExtrinsicSignatureV4: GenericExtrinsicSignatureV4,
    GenericAccountId: GenericAccountId,
    GenericAccountIndex: GenericAccountIndex,
    GenericBlock: GenericBlock,
    GenericCall: GenericCall,
    GenericChainProperties: GenericChainProperties,
    GenericConsensusEngineId: GenericConsensusEngineId,
    GenericEvent: GenericEvent,
    GenericEventData: GenericEventData,
    GenericLookupSource: GenericLookupSource,
    GenericMultiAddress: GenericMultiAddress,
    GenericAddress: GenericMultiAddress,
    GenericVote: GenericVote,
    GenericEthereumAccountId: GenericEthereumAccountId,
    GenericEthereumLookupSource: GenericEthereumLookupSource,
    BitVec: BitVec,
    bool: bool,
    Bool: bool,
    Bytes: Bytes,
    Data: Data,
    i8: i8,
    I8: i8,
    i16: i16,
    I16: i16,
    i32: i32,
    I32: i32,
    i64: i64,
    I64: i64,
    i128: i128,
    I128: i128,
    i256: i256,
    I256: i256,
    Null: Null,
    StorageKey: StorageKey,
    Text: Text,
    Type: Type,
    u8: u8$1,
    U8: u8$1,
    u16: u16$1,
    U16: u16$1,
    u32: u32$1,
    U32: u32$1,
    u64: u64,
    U64: u64,
    u128: u128,
    U128: u128,
    u256: u256,
    U256: u256,
    usize: usize,
    USize: usize
  });

  function createStorageHasher(registry, hasher) {
    if (hasher.toNumber() >= 2) {
      return registry.createType('StorageHasherV10', hasher.toNumber() + 1);
    }
    return registry.createType('StorageHasherV10', hasher);
  }
  function createStorageType(registry, entryType) {
    if (entryType.isMap) {
      return [{ ...entryType.asMap,
        hasher: createStorageHasher(registry, entryType.asMap.hasher)
      }, 1];
    }
    if (entryType.isDoubleMap) {
      return [{ ...entryType.asDoubleMap,
        hasher: createStorageHasher(registry, entryType.asDoubleMap.hasher),
        key2Hasher: createStorageHasher(registry, entryType.asDoubleMap.key2Hasher)
      }, 2];
    }
    return [entryType.asPlain, 0];
  }
  function convertModule(registry, mod) {
    const storage = mod.storage.unwrapOr(null);
    return registry.createType('ModuleMetadataV10', { ...mod,
      storage: storage ? { ...storage,
        items: storage.items.map(item => ({ ...item,
          type: registry.createType('StorageEntryTypeV10', ...createStorageType(registry, item.type))
        }))
      } : null
    });
  }
  function toV10(registry, {
    modules
  }) {
    return registry.createType('MetadataV10', {
      modules: modules.map(mod => convertModule(registry, mod))
    });
  }

  function toV11(registry, {
    modules
  }) {
    return registry.createType('MetadataV11', {
      extrinsic: {
        signedExtensions: [],
        version: 0
      },
      modules
    });
  }

  function toV12(registry, {
    extrinsic,
    modules
  }) {
    return registry.createType('MetadataV12', {
      extrinsic,
      modules: modules.map(mod => registry.createType('ModuleMetadataV12', { ...mod,
        index: 255
      }))
    });
  }

  function toV13(registry, metadata) {
    return registry.createType('MetadataV13', metadata);
  }

  const BOXES = [['<', '>'], ['<', ','], [',', '>'], ['(', ')'], ['(', ','], [',', ','], [',', ')']];
  function compatType(compatTypes, _type) {
    const type = _type.toString();
    const index = compatTypes.findIndex(({
      def
    }) => def.HistoricMetaCompat === type);
    if (index !== -1) {
      return index;
    }
    return compatTypes.push({
      def: {
        HistoricMetaCompat: type
      }
    }) - 1;
  }
  function makeTupleType(compatTypes, entries) {
    return compatTypes.push({
      def: {
        Tuple: entries
      }
    }) - 1;
  }
  function makeVariantType(modName, variantType, compatTypes, variants) {
    return compatTypes.push({
      def: {
        Variant: {
          variants
        }
      },
      path: [`pallet_${modName.toString()}`, 'pallet', variantType]
    }) - 1;
  }
  function registerOriginCaller(registry, modules, metaVersion) {
    registry.register({
      OriginCaller: {
        _enum: modules.map((mod, index) => [mod.name.toString(), metaVersion >= 12 ? mod.index.toNumber() : index]).sort((a, b) => a[1] - b[1]).reduce((result, [name, index]) => {
          for (let i = Object.keys(result).length; i < index; i++) {
            result[`Empty${i}`] = 'Null';
          }
          result[name] = typesKnown.knownOrigins[name] || 'Null';
          return result;
        }, {})
      }
    });
  }
  function setTypeOverride(sectionTypes, types) {
    types.forEach(type => {
      const override = Object.keys(sectionTypes).find(aliased => type.eq(aliased));
      if (override) {
        type.setOverride(sectionTypes[override]);
      } else {
        const orig = type.toString();
        const alias = Object.entries(sectionTypes).reduce((result, [src, dst]) => BOXES.reduce((result, [a, z]) => result.replace(`${a}${src}${z}`, `${a}${dst}${z}`), result), orig);
        if (orig !== alias) {
          type.setOverride(alias);
        }
      }
    });
  }
  function convertCalls(compatTypes, registry, modName, calls, sectionTypes) {
    const variants = calls.map(({
      args,
      docs,
      name
    }, index) => {
      setTypeOverride(sectionTypes, args.map(({
        type
      }) => type));
      return registry.createType('SiVariant', {
        docs,
        fields: args.map(({
          name,
          type
        }) => registry.createType('SiField', {
          name,
          type: compatType(compatTypes, type)
        })),
        index,
        name
      });
    });
    return registry.createType('PalletCallMetadataV14', {
      type: makeVariantType(modName, 'Call', compatTypes, variants)
    });
  }
  function convertConstants(compatTypes, registry, constants, sectionTypes) {
    return constants.map(({
      docs,
      name,
      type,
      value
    }) => {
      setTypeOverride(sectionTypes, [type]);
      return registry.createType('PalletConstantMetadataV14', {
        docs,
        name,
        type: compatType(compatTypes, type),
        value
      });
    });
  }
  function convertErrors(compatTypes, registry, modName, errors, _sectionTypes) {
    const variants = errors.map(({
      docs,
      name
    }, index) => registry.createType('SiVariant', {
      docs,
      fields: [],
      index,
      name
    }));
    return registry.createType('PalletErrorMetadataV14', {
      type: makeVariantType(modName, 'Error', compatTypes, variants)
    });
  }
  function convertEvents(compatTypes, registry, modName, events, sectionTypes) {
    const variants = events.map(({
      args,
      docs,
      name
    }, index) => {
      setTypeOverride(sectionTypes, args);
      return registry.createType('SiVariant', {
        docs,
        fields: args.map(t => registry.createType('SiField', {
          type: compatType(compatTypes, t)
        })),
        index,
        name
      });
    });
    return registry.createType('PalletEventMetadataV14', {
      type: makeVariantType(modName, 'Event', compatTypes, variants)
    });
  }
  function createMapEntry(compatTypes, registry, sectionTypes, {
    hashers,
    keys,
    value
  }) {
    setTypeOverride(sectionTypes, [value, ...(Array.isArray(keys) ? keys : [keys])]);
    return registry.createType('StorageEntryTypeV14', {
      Map: {
        hashers,
        key: hashers.length === 1 ? compatType(compatTypes, keys[0]) : makeTupleType(compatTypes, keys.map(t => compatType(compatTypes, t))),
        value: compatType(compatTypes, value)
      }
    });
  }
  function convertStorage(compatTypes, registry, {
    items,
    prefix
  }, sectionTypes) {
    return registry.createType('PalletStorageMetadataV14', {
      items: items.map(({
        docs,
        fallback,
        modifier,
        name,
        type
      }) => {
        let entryType;
        if (type.isPlain) {
          const plain = type.asPlain;
          setTypeOverride(sectionTypes, [plain]);
          entryType = registry.createType('StorageEntryTypeV14', {
            Plain: compatType(compatTypes, plain)
          });
        } else if (type.isMap) {
          const map = type.asMap;
          entryType = createMapEntry(compatTypes, registry, sectionTypes, {
            hashers: [map.hasher],
            keys: [map.key],
            value: map.value
          });
        } else if (type.isDoubleMap) {
          const dm = type.asDoubleMap;
          entryType = createMapEntry(compatTypes, registry, sectionTypes, {
            hashers: [dm.hasher, dm.key2Hasher],
            keys: [dm.key1, dm.key2],
            value: dm.value
          });
        } else {
          const nm = type.asNMap;
          entryType = createMapEntry(compatTypes, registry, sectionTypes, {
            hashers: nm.hashers,
            keys: nm.keyVec,
            value: nm.value
          });
        }
        return registry.createType('StorageEntryMetadataV14', {
          docs,
          fallback,
          modifier,
          name,
          type: entryType
        });
      }),
      prefix
    });
  }
  function convertExtrinsic(registry, {
    signedExtensions,
    version
  }) {
    return registry.createType('ExtrinsicMetadataV14', {
      signedExtensions: signedExtensions.map(identifier => ({
        identifier,
        type: 0
      })),
      type: 0,
      version: version
    });
  }
  function createPallet(compatTypes, registry, mod, {
    calls,
    constants,
    errors,
    events,
    storage
  }) {
    const sectionTypes = typesKnown.getModuleTypes(registry, stringCamelCase(mod.name));
    return registry.createType('PalletMetadataV14', {
      calls: calls && convertCalls(compatTypes, registry, mod.name, calls, sectionTypes),
      constants: convertConstants(compatTypes, registry, constants, sectionTypes),
      errors: errors && convertErrors(compatTypes, registry, mod.name, errors, sectionTypes),
      events: events && convertEvents(compatTypes, registry, mod.name, events, sectionTypes),
      index: mod.index,
      name: mod.name,
      storage: storage && convertStorage(compatTypes, registry, storage, sectionTypes)
    });
  }
  function toV14(registry, v13, metaVersion) {
    const compatTypes = [];
    compatType(compatTypes, 'Null');
    registerOriginCaller(registry, v13.modules, metaVersion);
    const extrinsic = convertExtrinsic(registry, v13.extrinsic);
    const pallets = v13.modules.map(mod => createPallet(compatTypes, registry, mod, {
      calls: mod.calls.unwrapOr(null),
      constants: mod.constants,
      errors: mod.errors.length ? mod.errors : null,
      events: mod.events.unwrapOr(null),
      storage: mod.storage.unwrapOr(null)
    }));
    return registry.createType('MetadataV14', {
      extrinsic,
      lookup: {
        types: compatTypes.map((type, id) => registry.createType('PortableType', {
          id,
          type
        }))
      },
      pallets
    });
  }

  function toLatest(registry, v14, _metaVersion) {
    return v14;
  }

  const MAGIC_NUMBER = 0x6174656d;
  class MagicNumber extends u32$1 {
    constructor(registry, value) {
      super(registry, value);
      if (!this.isEmpty) {
        assert$h(this.eq(MAGIC_NUMBER), () => `MagicNumber mismatch: expected ${registry.createType('u32', MAGIC_NUMBER).toHex()}, found ${this.toHex()}`);
      }
    }
  }

  const LATEST_VERSION = 14;
  var _converted = _classPrivateFieldKey("converted");
  var _assertVersion = _classPrivateFieldKey("assertVersion");
  var _getVersion = _classPrivateFieldKey("getVersion");
  var _metadata$1 = _classPrivateFieldKey("metadata");
  class MetadataVersioned extends Struct {
    constructor(registry, value) {
      super(registry, {
        magicNumber: MagicNumber,
        metadata: 'MetadataAll'
      }, value);
      Object.defineProperty(this, _converted, {
        writable: true,
        value: new Map()
      });
      Object.defineProperty(this, _assertVersion, {
        writable: true,
        value: version => {
          assert$h(this.version <= version, () => `Cannot convert metadata from version ${this.version} to ${version}`);
          return this.version === version;
        }
      });
      Object.defineProperty(this, _getVersion, {
        writable: true,
        value: (version, fromPrev) => {
          const asCurr = `asV${version}`;
          const asPrev = version === 'latest' ? `asV${LATEST_VERSION}` : `asV${version - 1}`;
          if (version !== 'latest' && _classPrivateFieldBase(this, _assertVersion)[_assertVersion](version)) {
            return _classPrivateFieldBase(this, _metadata$1)[_metadata$1]()[asCurr];
          }
          if (!_classPrivateFieldBase(this, _converted)[_converted].has(version)) {
            _classPrivateFieldBase(this, _converted)[_converted].set(version, fromPrev(this.registry, this[asPrev], this.version));
          }
          return _classPrivateFieldBase(this, _converted)[_converted].get(version);
        }
      });
      Object.defineProperty(this, _metadata$1, {
        writable: true,
        value: () => {
          return this.get('metadata');
        }
      });
    }
    get asCallsOnly() {
      return new MetadataVersioned(this.registry, {
        magicNumber: this.magicNumber,
        metadata: this.registry.createType('MetadataAll', toCallsOnly(this.registry, this.asLatest), LATEST_VERSION)
      });
    }
    get asV9() {
      _classPrivateFieldBase(this, _assertVersion)[_assertVersion](9);
      return _classPrivateFieldBase(this, _metadata$1)[_metadata$1]().asV9;
    }
    get asV10() {
      return _classPrivateFieldBase(this, _getVersion)[_getVersion](10, toV10);
    }
    get asV11() {
      return _classPrivateFieldBase(this, _getVersion)[_getVersion](11, toV11);
    }
    get asV12() {
      return _classPrivateFieldBase(this, _getVersion)[_getVersion](12, toV12);
    }
    get asV13() {
      return _classPrivateFieldBase(this, _getVersion)[_getVersion](13, toV13);
    }
    get asV14() {
      return _classPrivateFieldBase(this, _getVersion)[_getVersion](14, toV14);
    }
    get asLatest() {
      return _classPrivateFieldBase(this, _getVersion)[_getVersion]('latest', toLatest);
    }
    get magicNumber() {
      return this.get('magicNumber');
    }
    get version() {
      return _classPrivateFieldBase(this, _metadata$1)[_metadata$1]().index;
    }
    getUniqTypes(throwError) {
      return getUniqTypes(this.registry, this.asLatest, throwError);
    }
    toJSON() {
      this.asLatest;
      return super.toJSON();
    }
  }

  const VERSION_IDX = 4;
  const EMPTY_METADATA = new Uint8Array([0x6d, 0x65, 0x74, 0x61, 9]);
  const EMPTY_U8A = new Uint8Array();
  function toU8a(value = EMPTY_U8A) {
    if (isHex$1(value)) {
      return toU8a(u8aToU8a$1(value));
    } else if (isU8a$1(value)) {
      return value.length === 0 ? EMPTY_METADATA : value;
    }
    throw new Error('Invalid type passed to Metadata constructor');
  }
  function decodeMetadata(registry, _value) {
    if (isU8a$1(_value) || !_value || isHex$1(_value)) {
      const value = toU8a(_value);
      const version = value[VERSION_IDX];
      try {
        return new MetadataVersioned(registry, value);
      } catch (error) {
        if (version === 9) {
          value[VERSION_IDX] = 10;
          return decodeMetadata(registry, value);
        }
        throw error;
      }
    }
    return new MetadataVersioned(registry, _value);
  }
  class Metadata extends MetadataVersioned {
    constructor(registry, value) {
      super(registry, decodeMetadata(registry, value));
    }
  }

  function objectNameFirstLower({
    name
  }) {
    return stringLowerFirst(name);
  }
  function objectNameToCamel({
    name
  }) {
    return stringCamelCase(name);
  }
  function objectNameToString({
    name
  }) {
    return name.toString();
  }

  function decorateConstants(registry, {
    pallets
  }, _version) {
    const result = {};
    for (let i = 0; i < pallets.length; i++) {
      const {
        constants,
        name
      } = pallets[i];
      if (!constants.isEmpty) {
        lazyMethod(result, stringCamelCase(name), () => lazyMethods({}, constants, constant => {
          const codec = registry.createTypeUnsafe(registry.createLookupType(constant.type), [hexToU8a$1(constant.value.toHex())]);
          codec.meta = constant;
          return codec;
        }, objectNameToCamel));
      }
    }
    return result;
  }

  function variantToMeta(lookup, variant) {
    return objectSpread$1({
      args: variant.fields.map(({
        type
      }) => lookup.getTypeDef(type).type)
    }, variant);
  }
  function decorateErrors(registry, {
    lookup,
    pallets
  }, version) {
    const result = {};
    for (let i = 0; i < pallets.length; i++) {
      const {
        errors,
        index,
        name
      } = pallets[i];
      if (errors.isSome) {
        const sectionIndex = version >= 12 ? index.toNumber() : i;
        lazyMethod(result, stringCamelCase(name), () => lazyVariants(lookup, errors.unwrap(), objectNameToString, variant => ({
          is: ({
            error,
            index
          }) => index.eq(sectionIndex) && error.eq(variant.index),
          meta: registry.createType('ErrorMetadataLatest', variantToMeta(lookup, variant))
        })));
      }
    }
    return result;
  }

  function filterEventsSome({
    events
  }) {
    return events.isSome;
  }
  function decorateEvents(registry, {
    lookup,
    pallets
  }, version) {
    const result = {};
    const filtered = pallets.filter(filterEventsSome);
    for (let i = 0; i < filtered.length; i++) {
      const {
        events,
        index,
        name
      } = filtered[i];
      const sectionIndex = version >= 12 ? index.toNumber() : i;
      lazyMethod(result, stringCamelCase(name), () => lazyVariants(lookup, events.unwrap(), objectNameToString, variant => ({
        is: eventRecord => sectionIndex === eventRecord.index[0] && variant.index.eq(eventRecord.index[1]),
        meta: registry.createType('EventMetadataLatest', variantToMeta(lookup, variant))
      })));
    }
    return result;
  }

  function isTx(tx, callIndex) {
    return tx.callIndex[0] === callIndex[0] && tx.callIndex[1] === callIndex[1];
  }
  function createUnchecked(registry, section, callIndex, callMetadata) {
    const expectedArgs = callMetadata.fields;
    const funcName = stringCamelCase(callMetadata.name);
    const extrinsicFn = (...args) => {
      assert$h(expectedArgs.length === args.length, () => `Extrinsic ${section}.${funcName} expects ${expectedArgs.length} arguments, got ${args.length}.`);
      return registry.createType('Call', {
        args,
        callIndex
      }, callMetadata);
    };
    extrinsicFn.is = tx => isTx(tx, callIndex);
    extrinsicFn.callIndex = callIndex;
    extrinsicFn.meta = callMetadata;
    extrinsicFn.method = funcName;
    extrinsicFn.section = section;
    extrinsicFn.toJSON = () => callMetadata.toJSON();
    return extrinsicFn;
  }

  function filterCallsSome({
    calls
  }) {
    return calls.isSome;
  }
  function createCallFunction(registry, lookup, variant, sectionName, sectionIndex) {
    const {
      fields,
      index
    } = variant;
    const args = new Array(fields.length);
    for (let a = 0; a < fields.length; a++) {
      const {
        name,
        type,
        typeName
      } = fields[a];
      args[a] = objectSpread$1({
        name: stringCamelCase(name.unwrapOr(`param${a}`)),
        type: getSiName(lookup, type)
      }, typeName.isSome ? {
        typeName: typeName.unwrap()
      } : null);
    }
    return createUnchecked(registry, sectionName, new Uint8Array([sectionIndex, index.toNumber()]), registry.createType('FunctionMetadataLatest', objectSpread$1({
      args
    }, variant)));
  }
  function decorateExtrinsics(registry, {
    lookup,
    pallets
  }, version) {
    const result = {};
    const filtered = pallets.filter(filterCallsSome);
    for (let i = 0; i < filtered.length; i++) {
      const {
        calls,
        index,
        name
      } = filtered[i];
      const sectionName = stringCamelCase(name);
      const sectionIndex = version >= 12 ? index.toNumber() : i;
      lazyMethod(result, sectionName, () => lazyVariants(lookup, calls.unwrap(), objectNameToCamel, variant => createCallFunction(registry, lookup, variant, sectionName, sectionIndex)));
    }
    return result;
  }

  const DEFAULT_FN = data => xxhashAsU8a(data, 128);
  const HASHERS = {
    Blake2_128: data =>
    blake2AsU8a(data, 128),
    Blake2_128Concat: data =>
    u8aConcat$1(blake2AsU8a(data, 128), u8aToU8a$1(data)),
    Blake2_256: data =>
    blake2AsU8a(data, 256),
    Identity: data => u8aToU8a$1(data),
    Twox128: data => xxhashAsU8a(data, 128),
    Twox256: data => xxhashAsU8a(data, 256),
    Twox64Concat: data => u8aConcat$1(xxhashAsU8a(data, 64), u8aToU8a$1(data))
  };
  function getHasher(hasher) {
    return HASHERS[hasher.type] || DEFAULT_FN;
  }

  function createKeyRaw(registry, itemFn, keys, hashers, args) {
    const extra = new Array(keys.length);
    for (let i = 0; i < keys.length; i++) {
      extra[i] = getHasher(hashers[i])(registry.createType(registry.createLookupType(keys[i]), args[i]).toU8a());
    }
    return u8aConcat$1(xxhashAsU8a(itemFn.prefix, 128), xxhashAsU8a(itemFn.method, 128), ...extra);
  }
  function filterDefined(a) {
    return !isUndefined(a);
  }
  function createKey(registry, itemFn, keys, hashers, args) {
    const {
      method,
      section
    } = itemFn;
    assert$h(Array.isArray(args), () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments`);
    assert$h(args.filter(filterDefined).length === keys.length, () => `Call to ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs ${keys.length} arguments, found [${args.join(', ')}]`);
    return compactAddLength(createKeyRaw(registry, itemFn, keys, hashers, args));
  }
  function expandWithMeta({
    meta,
    method,
    prefix,
    section
  }, _storageFn) {
    const storageFn = _storageFn;
    storageFn.meta = meta;
    storageFn.method = stringLowerFirst(method);
    storageFn.prefix = prefix;
    storageFn.section = section;
    storageFn.toJSON = () => objectSpread$1({
      storage: {
        method,
        prefix,
        section
      }
    }, meta.toJSON());
    return storageFn;
  }
  function extendHeadMeta(registry, {
    meta: {
      docs,
      name,
      type
    },
    section
  }, {
    method
  }, iterFn) {
    const outputType = registry.createLookupType(type.asMap.key);
    iterFn.meta = registry.createType('StorageEntryMetadataLatest', {
      docs,
      fallback: registry.createType('Bytes'),
      modifier: registry.createType('StorageEntryModifierLatest', 1),
      name,
      type: registry.createType('StorageEntryTypeLatest', outputType, 0)
    });
    return (...args) => registry.createType('StorageKey', iterFn(...args), {
      method,
      section
    });
  }
  function extendPrefixedMap(registry, itemFn, storageFn) {
    const {
      meta: {
        type
      },
      method,
      section
    } = itemFn;
    storageFn.iterKey = extendHeadMeta(registry, itemFn, storageFn, (...args) => {
      assert$h(args.length === 0 || type.isMap && args.length < type.asMap.hashers.length, () => `Iteration ${stringCamelCase(section || 'unknown')}.${stringCamelCase(method || 'unknown')} needs arguments to be at least one less than the full arguments, found [${args.join(', ')}]`);
      if (args.length) {
        if (type.isMap) {
          const {
            hashers,
            key
          } = type.asMap;
          const keysVec = hashers.length === 1 ? [key] : registry.lookup.getSiType(key).def.asTuple;
          return new Raw(registry, createKeyRaw(registry, itemFn, keysVec.slice(0, args.length), hashers.slice(0, args.length), args));
        }
      }
      return new Raw(registry, createKeyRaw(registry, itemFn, [], [], []));
    });
    return storageFn;
  }
  function createFunction(registry, itemFn, options) {
    const {
      meta: {
        type
      }
    } = itemFn;
    let cacheKey = null;
    const storageFn = expandWithMeta(itemFn, (...args) => {
      if (type.isPlain) {
        if (!cacheKey) {
          cacheKey = options.skipHashing ? compactAddLength(u8aToU8a$1(options.key)) : createKey(registry, itemFn, [], [], []);
        }
        return cacheKey;
      }
      const {
        hashers,
        key
      } = type.asMap;
      return hashers.length === 1 ? createKey(registry, itemFn, [key], hashers, args) : createKey(registry, itemFn, registry.lookup.getSiType(key).def.asTuple, hashers, args);
    });
    if (type.isMap) {
      extendPrefixedMap(registry, itemFn, storageFn);
    }
    storageFn.keyPrefix = (...args) => storageFn.iterKey && storageFn.iterKey(...args) || compactStripLength(storageFn())[1];
    return storageFn;
  }

  function findSiPrimitive(registry, _prim) {
    const prim = _prim.toLowerCase();
    return registry.lookup.types.find(t => t.type.def.isPrimitive && t.type.def.asPrimitive.toString().toLowerCase() === prim || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.toString().toLowerCase() === prim);
  }
  function findSiType(registry, orig) {
    let portable = findSiPrimitive(registry, orig);
    if (!portable && orig === 'Bytes') {
      const u8 = findSiPrimitive(registry, 'u8');
      if (u8) {
        portable = registry.lookup.types.find(t => t.type.def.isSequence && t.type.def.asSequence.type.eq(u8.id) || t.type.def.isHistoricMetaCompat && t.type.def.asHistoricMetaCompat.eq(orig));
      }
    }
    if (!portable) {
      console.warn(`Unable to map ${orig} to a lookup index`);
    }
    return portable;
  }
  function createRuntimeFunction({
    method,
    prefix,
    section
  }, key, {
    docs,
    type
  }) {
    return registry => {
      var _findSiType;
      return createFunction(registry, {
        meta: registry.createType('StorageEntryMetadataLatest', {
          docs: registry.createType('Vec<Text>', [docs]),
          modifier: registry.createType('StorageEntryModifierLatest', 'Required'),
          name: registry.createType('Text', method),
          toJSON: () => key,
          type: registry.createType('StorageEntryTypeLatest', {
            Plain: ((_findSiType = findSiType(registry, type)) === null || _findSiType === void 0 ? void 0 : _findSiType.id) || 0
          })
        }),
        method,
        prefix,
        section
      }, {
        key,
        skipHashing: true
      });
    };
  }

  const prefix = 'Substrate';
  const section = 'substrate';
  function createSubstrateFn(method, key, meta) {
    return createRuntimeFunction({
      method,
      prefix,
      section
    }, key, meta);
  }
  const substrate = {
    changesTrieConfig: createSubstrateFn('changesTrieConfig', ':changes_trie', {
      docs: 'Changes trie configuration is stored under this key.',
      type: 'u32'
    }),
    childStorageKeyPrefix: createSubstrateFn('childStorageKeyPrefix', ':child_storage:', {
      docs: 'Prefix of child storage keys.',
      type: 'u32'
    }),
    code: createSubstrateFn('code', ':code', {
      docs: 'Wasm code of the runtime.',
      type: 'Bytes'
    }),
    extrinsicIndex: createSubstrateFn('extrinsicIndex', ':extrinsic_index', {
      docs: 'Current extrinsic index (u32) is stored under this key.',
      type: 'u32'
    }),
    heapPages: createSubstrateFn('heapPages', ':heappages', {
      docs: 'Number of wasm linear memory pages required for execution of the runtime.',
      type: 'u64'
    })
  };

  function getStorage(registry) {
    const storage = {};
    const entries = Object.entries(substrate);
    for (let e = 0; e < entries.length; e++) {
      storage[entries[e][0]] = entries[e][1](registry);
    }
    return {
      substrate: storage
    };
  }

  const VERSION_NAME = 'palletVersion';
  const VERSION_KEY = ':__STORAGE_VERSION__:';
  const VERSION_DOCS = {
    docs: 'Returns the current pallet version from storage',
    type: 'u16'
  };
  function decorateStorage(registry, {
    pallets
  }, _metaVersion) {
    const result = getStorage(registry);
    for (let i = 0; i < pallets.length; i++) {
      const {
        name,
        storage
      } = pallets[i];
      if (storage.isSome) {
        const section = stringCamelCase(name);
        const {
          items,
          prefix: _prefix
        } = storage.unwrap();
        const prefix = _prefix.toString();
        lazyMethod(result, section, () => lazyMethods({
          palletVersion: createRuntimeFunction({
            method: VERSION_NAME,
            prefix,
            section
          }, createKeyRaw(registry, {
            method: VERSION_KEY,
            prefix: name.toString()
          }, [], [], []), VERSION_DOCS)(registry)
        }, items, meta => createFunction(registry, {
          meta,
          method: meta.name.toString(),
          prefix,
          section
        }, {}), objectNameFirstLower));
      }
    }
    return result;
  }

  function expandMetadata(registry, metadata) {
    assert$h(metadata instanceof Metadata, 'You need to pass a valid Metadata instance to Decorated');
    const latest = metadata.asLatest;
    const version = metadata.version;
    return {
      consts: decorateConstants(registry, latest),
      errors: decorateErrors(registry, latest, version),
      events: decorateEvents(registry, latest, version),
      query: decorateStorage(registry, latest),
      registry,
      tx: decorateExtrinsics(registry, latest, version)
    };
  }

  const TYPE_UNWRAP = {
    toNumber: () => -1
  };
  const PRIMITIVE_ALIAS = {
    Char: 'u32',
    Str: 'Text'
  };
  const PATHS_ALIAS = splitNamespace([
  '*_runtime::Call', '*_runtime::Event',
  'pallet_democracy::vote::Vote', 'pallet_identity::types::Data',
  'sp_core::crypto::AccountId32', 'sp_runtime::generic::era::Era', 'sp_runtime::multiaddress::MultiAddress',
  'account::AccountId20', 'polkadot_runtime_common::claims::EthereumAddress',
  'primitive_types::*', 'sp_arithmetic::per_things::*',
  'ink_env::types::*']);
  const PATHS_SET = splitNamespace(['pallet_identity::types::BitFlags']);
  const WRAPPERS = ['BoundedBTreeMap', 'BoundedVec', 'Box', 'BTreeMap', 'Cow', 'Result', 'Option', 'WeakBoundedVec', 'WrapperOpaque'];
  const RESERVED = ['entries', 'hash', 'keys', 'new', 'size'];
  function splitNamespace(values) {
    return values.map(v => v.split('::'));
  }
  function createNamespace({
    path
  }) {
    return sanitizeDocs(path).join('::');
  }
  function sanitizeDocs(docs) {
    return docs.map(d => d.toString());
  }
  function matchParts(first, second) {
    return first.length === second.length && first.every((a, index) => {
      const b = second[index].toString();
      if (a === '*' || a === b) {
        return true;
      }
      if (a.includes('*') && a.includes('_') && b.includes('_')) {
        const suba = a.split('_');
        const subb = b.split('_');
        if (suba[0] === '*') {
          while (suba.length < subb.length) {
            subb.shift();
          }
        }
        return matchParts(suba, subb);
      }
      return false;
    });
  }
  function getAliasPath(path) {
    return path.length && PATHS_ALIAS.some(p => matchParts(p, path)) ? path[path.length - 1].toString() : null;
  }
  function removeDuplicateNames(lookup, names) {
    const rewrite = {};
    return names.map(([lookupIndex, name, params]) => {
      if (!name) {
        return [lookupIndex, null, params];
      }
      const allSame = names.filter(([, oName]) => name === oName);
      const anyDiff = allSame.some(([oIndex,, oParams]) => lookupIndex !== oIndex && (params.length !== oParams.length || params.some((p, index) => !p.name.eq(oParams[index].name) || p.type.unwrapOr(TYPE_UNWRAP).toNumber() !== oParams[index].type.unwrapOr(TYPE_UNWRAP).toNumber())));
      if (!anyDiff || !allSame[0][2].length) {
        return [lookupIndex, name, params];
      }
      const paramIdx = allSame[0][2].findIndex(({
        type
      }, index) => allSame.every(([,, params]) => params[index].type.isSome) && allSame.every(([,, params], aIndex) => aIndex === 0 || !params[index].type.eq(type)));
      if (paramIdx === -1) {
        return [lookupIndex, name, params];
      }
      const adjusted = allSame.map(([oIndex, oName, oParams]) => {
        const {
          def,
          path
        } = lookup.getSiType(oParams[paramIdx].type.unwrap());
        if (!def.isPrimitive && !path.length) {
          return [oIndex, null, params];
        }
        return [oIndex, def.isPrimitive ? `${oName}${def.asPrimitive.toString()}` : `${oName}${path[path.length - 1].toString()}`, params];
      });
      const noDupes = adjusted.every(([i, n]) => !!n && !adjusted.some(([ai, an]) => i !== ai && n === an));
      if (noDupes) {
        adjusted.forEach(([index, name]) => {
          rewrite[index] = name;
        });
      }
      return noDupes ? [lookupIndex, name, params] : [lookupIndex, null, params];
    }).filter(n => !!n[1]).map(([lookupIndex, name, params]) => [lookupIndex, rewrite[lookupIndex] || name, params]);
  }
  function extractName(types, {
    id,
    type: {
      params,
      path
    }
  }) {
    const lookupIndex = id.toNumber();
    if (!path.length || WRAPPERS.includes(path[path.length - 1].toString())) {
      return [lookupIndex, null, []];
    }
    const parts = path.map(p => stringUpperFirst(stringCamelCase(p))).filter((p, index) => (
    index !== 1 || !['Generic', 'Misc', 'Pallet', 'Traits', 'Types'].includes(p.toString())) && (
    index === path.length - 1 || p.toLowerCase() !== path[index + 1].toLowerCase()));
    let typeName = parts.join('');
    if (parts.length === 2 && parts[parts.length - 1] === 'RawOrigin' && params.length === 2 && params[1].type.isSome) {
      const instanceType = types[params[1].type.unwrap().toNumber()];
      if (instanceType.type.path.length === 2) {
        typeName = `${typeName}${instanceType.type.path[1].toString()}`;
      }
    }
    return [lookupIndex, typeName, params];
  }
  function registerTypes(lookup, lookups, names, params) {
    lookup.registry.register(lookups);
    if (params.SpRuntimeUncheckedExtrinsic) {
      const [addrParam,, sigParam] = params.SpRuntimeUncheckedExtrinsic;
      const siAddress = lookup.getSiType(addrParam.type.unwrap());
      const siSignature = lookup.getSiType(sigParam.type.unwrap());
      const nsSignature = createNamespace(siSignature);
      let nsAccountId = createNamespace(siAddress);
      const isMultiAddress = nsAccountId === 'sp_runtime::multiaddress::MultiAddress';
      if (isMultiAddress) {
        const [idParam] = siAddress.params;
        nsAccountId = createNamespace(lookup.getSiType(idParam.type.unwrap()));
      }
      lookup.registry.register({
        AccountId: ['sp_core::crypto::AccountId32'].includes(nsAccountId) ? 'AccountId32' : ['account::AccountId20', 'primitive_types::H160'].includes(nsAccountId) ? 'AccountId20' : 'AccountId32',
        Address: isMultiAddress ? 'MultiAddress' : 'AccountId',
        ExtrinsicSignature: ['sp_runtime::MultiSignature'].includes(nsSignature) ? 'MultiSignature' : names[sigParam.type.unwrap().toNumber()] || 'MultiSignature'
      });
    }
  }
  function extractNames(lookup, types) {
    const dedup = removeDuplicateNames(lookup, types.map(t => extractName(types, t)));
    const lookups = {};
    const names = {};
    const params = {};
    for (let i = 0; i < dedup.length; i++) {
      const [lookupIndex, name, p] = dedup[i];
      names[lookupIndex] = name;
      lookups[name] = lookup.registry.createLookupType(lookupIndex);
      params[name] = p;
    }
    registerTypes(lookup, lookups, names, params);
    return names;
  }
  function extractTypeMap(types) {
    const result = {};
    for (let i = 0; i < types.length; i++) {
      const p = types[i];
      result[p.id.toNumber()] = p;
    }
    return result;
  }
  var _names = _classPrivateFieldKey("names");
  var _typeDefs = _classPrivateFieldKey("typeDefs");
  var _types = _classPrivateFieldKey("types");
  var _createSiDef = _classPrivateFieldKey("createSiDef");
  var _getLookupId = _classPrivateFieldKey("getLookupId");
  var _extract = _classPrivateFieldKey("extract");
  var _extractArray = _classPrivateFieldKey("extractArray");
  var _extractBitSequence = _classPrivateFieldKey("extractBitSequence");
  var _extractCompact = _classPrivateFieldKey("extractCompact");
  var _extractComposite = _classPrivateFieldKey("extractComposite");
  var _extractCompositeSet = _classPrivateFieldKey("extractCompositeSet");
  var _extractFields = _classPrivateFieldKey("extractFields");
  var _extractFieldsAlias = _classPrivateFieldKey("extractFieldsAlias");
  var _extractHistoric = _classPrivateFieldKey("extractHistoric");
  var _extractPrimitive = _classPrivateFieldKey("extractPrimitive");
  var _extractAliasPath = _classPrivateFieldKey("extractAliasPath");
  var _extractSequence = _classPrivateFieldKey("extractSequence");
  var _extractTuple = _classPrivateFieldKey("extractTuple");
  var _extractVariant = _classPrivateFieldKey("extractVariant");
  var _extractVariantEnum = _classPrivateFieldKey("extractVariantEnum");
  class PortableRegistry extends Struct {
    constructor(registry, value) {
      super(registry, {
        types: 'Vec<PortableType>'
      }, value);
      Object.defineProperty(this, _extractVariantEnum, {
        value: _extractVariantEnum2
      });
      Object.defineProperty(this, _extractVariant, {
        value: _extractVariant2
      });
      Object.defineProperty(this, _extractTuple, {
        value: _extractTuple2
      });
      Object.defineProperty(this, _extractSequence, {
        value: _extractSequence2
      });
      Object.defineProperty(this, _extractAliasPath, {
        value: _extractAliasPath2
      });
      Object.defineProperty(this, _extractPrimitive, {
        value: _extractPrimitive2
      });
      Object.defineProperty(this, _extractHistoric, {
        value: _extractHistoric2
      });
      Object.defineProperty(this, _extractFieldsAlias, {
        value: _extractFieldsAlias2
      });
      Object.defineProperty(this, _extractFields, {
        value: _extractFields2
      });
      Object.defineProperty(this, _extractCompositeSet, {
        value: _extractCompositeSet2
      });
      Object.defineProperty(this, _extractComposite, {
        value: _extractComposite2
      });
      Object.defineProperty(this, _extractCompact, {
        value: _extractCompact2
      });
      Object.defineProperty(this, _extractBitSequence, {
        value: _extractBitSequence2
      });
      Object.defineProperty(this, _extractArray, {
        value: _extractArray2
      });
      Object.defineProperty(this, _extract, {
        value: _extract2
      });
      Object.defineProperty(this, _getLookupId, {
        value: _getLookupId2
      });
      Object.defineProperty(this, _createSiDef, {
        value: _createSiDef2
      });
      Object.defineProperty(this, _names, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _typeDefs, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _types, {
        writable: true,
        value: void 0
      });
      _classPrivateFieldBase(this, _names)[_names] = extractNames(this, this.types);
      _classPrivateFieldBase(this, _types)[_types] = extractTypeMap(this.types);
    }
    get names() {
      return Object.values(_classPrivateFieldBase(this, _names)[_names]);
    }
    get types() {
      return this.get('types');
    }
    getName(lookupId) {
      return _classPrivateFieldBase(this, _names)[_names][_classPrivateFieldBase(this, _getLookupId)[_getLookupId](lookupId)];
    }
    getSiType(lookupId) {
      const found = (_classPrivateFieldBase(this, _types)[_types] || this.types)[_classPrivateFieldBase(this, _getLookupId)[_getLookupId](lookupId)];
      assert$h(found, () => `PortableRegistry: Unable to find type with lookupId ${lookupId.toString()}`);
      return found.type;
    }
    getTypeDef(lookupId) {
      const lookupIndex = _classPrivateFieldBase(this, _getLookupId)[_getLookupId](lookupId);
      if (!_classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex]) {
        const lookupName = _classPrivateFieldBase(this, _names)[_names][lookupIndex];
        const empty = {
          info: exports.TypeDefInfo.DoNotConstruct,
          lookupIndex,
          lookupName,
          type: this.registry.createLookupType(lookupIndex)
        };
        if (lookupName) {
          _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;
        }
        const extracted = _classPrivateFieldBase(this, _extract)[_extract](this.getSiType(lookupId), lookupIndex);
        if (!lookupName) {
          _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex] = empty;
        }
        Object.keys(extracted).forEach(k => {
          if (k !== 'lookupName' || extracted[k]) {
            _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex][k] = extracted[k];
          }
        });
        if (extracted.info === exports.TypeDefInfo.Plain) {
          _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupNameRoot = _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;
          delete _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex].lookupName;
        }
      }
      return _classPrivateFieldBase(this, _typeDefs)[_typeDefs][lookupIndex];
    }
  }
  function _createSiDef2(lookupId) {
    const typeDef = this.getTypeDef(lookupId);
    const lookupIndex = lookupId.toNumber();
    return [exports.TypeDefInfo.DoNotConstruct, exports.TypeDefInfo.Enum, exports.TypeDefInfo.Struct].includes(typeDef.info) && typeDef.lookupName ? {
      docs: typeDef.docs,
      info: exports.TypeDefInfo.Si,
      lookupIndex,
      lookupName: _classPrivateFieldBase(this, _names)[_names][lookupIndex],
      type: this.registry.createLookupType(lookupId)
    } : typeDef;
  }
  function _getLookupId2(lookupId) {
    if (isString$1(lookupId)) {
      assert$h(this.registry.isLookupType(lookupId), () => `PortableRegistry: Expected a lookup string type, found ${lookupId}`);
      return parseInt(lookupId.replace('Lookup', ''), 10);
    } else if (isNumber$1(lookupId)) {
      return lookupId;
    }
    return lookupId.toNumber();
  }
  function _extract2(type, lookupIndex) {
    const namespace = [...type.path].join('::');
    let typeDef;
    const aliasType = getAliasPath(type.path);
    try {
      if (aliasType) {
        typeDef = _classPrivateFieldBase(this, _extractAliasPath)[_extractAliasPath](lookupIndex, aliasType);
      } else if (type.def.isArray) {
        typeDef = _classPrivateFieldBase(this, _extractArray)[_extractArray](lookupIndex, type.def.asArray);
      } else if (type.def.isBitSequence) {
        typeDef = _classPrivateFieldBase(this, _extractBitSequence)[_extractBitSequence](lookupIndex, type.def.asBitSequence);
      } else if (type.def.isCompact) {
        typeDef = _classPrivateFieldBase(this, _extractCompact)[_extractCompact](lookupIndex, type.def.asCompact);
      } else if (type.def.isComposite) {
        typeDef = _classPrivateFieldBase(this, _extractComposite)[_extractComposite](lookupIndex, type, type.def.asComposite);
      } else if (type.def.isHistoricMetaCompat) {
        typeDef = _classPrivateFieldBase(this, _extractHistoric)[_extractHistoric](lookupIndex, type.def.asHistoricMetaCompat);
      } else if (type.def.isPrimitive) {
        typeDef = _classPrivateFieldBase(this, _extractPrimitive)[_extractPrimitive](lookupIndex, type);
      } else if (type.def.isSequence) {
        typeDef = _classPrivateFieldBase(this, _extractSequence)[_extractSequence](lookupIndex, type.def.asSequence);
      } else if (type.def.isTuple) {
        typeDef = _classPrivateFieldBase(this, _extractTuple)[_extractTuple](lookupIndex, type.def.asTuple);
      } else if (type.def.isVariant) {
        typeDef = _classPrivateFieldBase(this, _extractVariant)[_extractVariant](lookupIndex, type, type.def.asVariant);
      } else {
        throw new Error(`No SiTypeDef handler for ${type.def.toString()}`);
      }
    } catch (error) {
      throw new Error(`PortableRegistry: ${lookupIndex}${namespace ? ` (${namespace})` : ''}: Error extracting ${stringify(type)}: ${error.message}`);
    }
    return objectSpread$1({
      docs: sanitizeDocs(type.docs),
      namespace
    }, typeDef);
  }
  function _extractArray2(_, {
    len: length,
    type
  }) {
    assert$h(!length || length.toNumber() <= 256, 'Only support for [Type; <length>], where length <= 256');
    return withTypeString(this.registry, {
      info: exports.TypeDefInfo.VecFixed,
      length: length.toNumber(),
      sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type)
    });
  }
  function _extractBitSequence2(_, {
    bitOrderType,
    bitStoreType
  }) {
    const bitOrder = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](bitOrderType);
    const bitStore = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](bitStoreType);
    assert$h(['bitvec::order::Lsb0', 'bitvec::order::Msb0'].includes(bitOrder.namespace || ''), () => `Unexpected bitOrder found as ${bitOrder.namespace || '<unknown>'}`);
    assert$h(bitStore.info === exports.TypeDefInfo.Plain && bitStore.type === 'u8', () => `Only u8 bitStore is currently supported, found ${bitStore.type}`);
    return {
      info: exports.TypeDefInfo.Plain,
      type: 'BitVec'
    };
  }
  function _extractCompact2(_, {
    type
  }) {
    return withTypeString(this.registry, {
      info: exports.TypeDefInfo.Compact,
      sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type)
    });
  }
  function _extractComposite2(lookupIndex, {
    params,
    path
  }, {
    fields
  }) {
    const specialVariant = path[0].toString();
    if (path.length === 1 && specialVariant === 'BTreeMap') {
      return withTypeString(this.registry, {
        info: exports.TypeDefInfo.BTreeMap,
        sub: params.map(({
          type
        }) => _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type.unwrap()))
      });
    } else if (['Range', 'RangeInclusive'].includes(specialVariant)) {
      return withTypeString(this.registry, {
        info: exports.TypeDefInfo.Range,
        sub: fields.map(({
          name,
          type,
          typeName
        }, index) => objectSpread$1({
          name: name.isSome ? name.unwrap().toString() : ['start', 'end'][index]
        }, _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type), typeName.isSome ? {
          typeName: sanitize(typeName.unwrap())
        } : null))
      });
    } else if (path.length) {
      if (path[path.length - 1].toString() === 'WrapperOpaque') {
        return withTypeString(this.registry, {
          info: exports.TypeDefInfo.WrapperOpaque,
          sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())
        });
      } else if (path[path.length - 1].toString() === 'WrapperKeepOpaque') {
        return {
          info: exports.TypeDefInfo.Plain,
          type: 'Bytes'
        };
      }
    }
    return PATHS_SET.some(p => matchParts(p, path)) ? _classPrivateFieldBase(this, _extractCompositeSet)[_extractCompositeSet](lookupIndex, params, fields) : _classPrivateFieldBase(this, _extractFields)[_extractFields](lookupIndex, fields);
  }
  function _extractCompositeSet2(_, params, fields) {
    assert$h(params.length === 1 && fields.length === 1, 'Set handling expects param/field as single entries');
    return withTypeString(this.registry, {
      info: exports.TypeDefInfo.Set,
      length: this.registry.createType(this.registry.createLookupType(fields[0].type)).bitLength(),
      sub: this.getSiType(params[0].type.unwrap()).def.asVariant.variants.map(({
        index,
        name
      }) => ({
        index: index.toNumber(),
        info: exports.TypeDefInfo.Plain,
        name: name.toString(),
        type: 'Null'
      }))
    });
  }
  function _extractFields2(lookupIndex, fields) {
    let isStruct = true;
    let isTuple = true;
    for (let f = 0; f < fields.length; f++) {
      const {
        name
      } = fields[f];
      isStruct = isStruct && name.isSome;
      isTuple = isTuple && name.isNone;
    }
    assert$h(isTuple || isStruct, 'Invalid fields type detected, expected either Tuple (all unnamed) or Struct (all named)');
    if (fields.length === 0) {
      return {
        info: exports.TypeDefInfo.Null,
        type: 'Null'
      };
    } else if (isTuple && fields.length === 1) {
      const typeDef = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](fields[0].type);
      return objectSpread$1({}, typeDef, lookupIndex === -1 ? {} : {
        lookupIndex,
        lookupName: _classPrivateFieldBase(this, _names)[_names][lookupIndex],
        lookupNameRoot: typeDef.lookupName
      }, fields[0].typeName.isSome ? {
        typeName: sanitize(fields[0].typeName.unwrap())
      } : null);
    }
    const [sub, alias] = _classPrivateFieldBase(this, _extractFieldsAlias)[_extractFieldsAlias](fields);
    return withTypeString(this.registry, objectSpread$1({
      info: isTuple
      ? exports.TypeDefInfo.Tuple : exports.TypeDefInfo.Struct
    }, alias.size ? {
      alias
    } : null, lookupIndex === -1 ? {} : {
      lookupIndex,
      lookupName: _classPrivateFieldBase(this, _names)[_names][lookupIndex]
    }, {
      sub
    }));
  }
  function _extractFieldsAlias2(fields) {
    const alias = new Map();
    const sub = new Array(fields.length);
    for (let i = 0; i < fields.length; i++) {
      const {
        docs,
        name,
        type,
        typeName
      } = fields[i];
      const typeDef = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type);
      if (name.isNone) {
        sub[i] = typeDef;
      } else {
        let nameField = stringCamelCase(name.unwrap());
        let nameOrig = null;
        if (nameField.includes('#')) {
          nameOrig = nameField;
          nameField = nameOrig.replace(/#/g, '_');
        } else if (RESERVED.includes(nameField)) {
          nameOrig = nameField;
          nameField = `${nameField}_`;
        }
        if (nameOrig) {
          alias.set(nameField, nameOrig);
        }
        sub[i] = objectSpread$1({}, typeDef, {
          docs: sanitizeDocs(docs),
          name: nameField
        }, typeName.isSome ? {
          typeName: sanitize(typeName.unwrap())
        } : null);
      }
    }
    return [sub, alias];
  }
  function _extractHistoric2(_, type) {
    return objectSpread$1({}, getTypeDef(type), {
      displayName: type.toString(),
      isFromSi: true
    });
  }
  function _extractPrimitive2(_, type) {
    const typeStr = type.def.asPrimitive.type.toString();
    return {
      info: exports.TypeDefInfo.Plain,
      type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()
    };
  }
  function _extractAliasPath2(_, type) {
    return {
      info: exports.TypeDefInfo.Plain,
      type
    };
  }
  function _extractSequence2(lookupIndex, {
    type
  }) {
    const sub = _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type);
    if (sub.type === 'u8') {
      return {
        info: exports.TypeDefInfo.Plain,
        type: 'Bytes'
      };
    }
    return withTypeString(this.registry, {
      info: exports.TypeDefInfo.Vec,
      lookupIndex,
      lookupName: _classPrivateFieldBase(this, _names)[_names][lookupIndex],
      sub
    });
  }
  function _extractTuple2(lookupIndex, ids) {
    if (ids.length === 0) {
      return {
        info: exports.TypeDefInfo.Null,
        type: 'Null'
      };
    } else if (ids.length === 1) {
      return this.getTypeDef(ids[0]);
    }
    const sub = ids.map(type => _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type));
    return withTypeString(this.registry, {
      info: exports.TypeDefInfo.Tuple,
      lookupIndex,
      lookupName: _classPrivateFieldBase(this, _names)[_names][lookupIndex],
      sub
    });
  }
  function _extractVariant2(lookupIndex, {
    params,
    path
  }, {
    variants
  }) {
    const specialVariant = path[0].toString();
    if (specialVariant === 'Option') {
      return withTypeString(this.registry, {
        info: exports.TypeDefInfo.Option,
        sub: _classPrivateFieldBase(this, _createSiDef)[_createSiDef](params[0].type.unwrap())
      });
    } else if (specialVariant === 'Result') {
      return withTypeString(this.registry, {
        info: exports.TypeDefInfo.Result,
        sub: params.map(({
          type
        }, index) => objectSpread$1({
          name: ['Ok', 'Error'][index]
        }, _classPrivateFieldBase(this, _createSiDef)[_createSiDef](type.unwrap())))
      });
    } else if (variants.length === 0) {
      return {
        info: exports.TypeDefInfo.Null,
        type: 'Null'
      };
    }
    return _classPrivateFieldBase(this, _extractVariantEnum)[_extractVariantEnum](lookupIndex, variants);
  }
  function _extractVariantEnum2(lookupIndex, variants) {
    const sub = [];
    [...variants].sort((a, b) => a.index.cmp(b.index)).forEach(({
      fields,
      index,
      name
    }) => {
      const desired = index.toNumber();
      while (sub.length !== desired) {
        sub.push({
          index: sub.length,
          info: exports.TypeDefInfo.Null,
          name: `__Unused${sub.length}`,
          type: 'Null'
        });
      }
      sub.push(objectSpread$1(_classPrivateFieldBase(this, _extractFields)[_extractFields](-1, fields), {
        index: index.toNumber(),
        name: name.toString()
      }));
    });
    return withTypeString(this.registry, {
      info: exports.TypeDefInfo.Enum,
      lookupIndex,
      lookupName: _classPrivateFieldBase(this, _names)[_names][lookupIndex],
      sub
    });
  }

  function convertArray(registry, {
    len,
    type
  }) {
    return registry.createType('Si1TypeDef', {
      Array: {
        len,
        type: type.toNumber()
      }
    });
  }
  function convertBitSequence(registry, {
    bitOrderType,
    bitStoreType
  }) {
    return registry.createType('Si1TypeDef', {
      BitSequence: {
        bitOrderType: bitOrderType.toNumber(),
        bitStoreType: bitStoreType.toNumber()
      }
    });
  }
  function convertCompact(registry, {
    type
  }) {
    return registry.createType('Si1TypeDef', {
      Compact: {
        type: type.toNumber()
      }
    });
  }
  function convertComposite(registry, {
    fields
  }) {
    return registry.createType('Si1TypeDef', {
      Composite: {
        fields: convertFields(registry, fields)
      }
    });
  }
  function convertFields(registry, fields) {
    return fields.map(({
      docs,
      name,
      type,
      typeName
    }) => registry.createType('Si1Field', {
      docs,
      name,
      type: type.toNumber(),
      typeName
    }));
  }
  function convertPhantom(registry, path) {
    console.warn(`Converting phantom type ${path.map(p => p.toString()).join('::')} to empty tuple`);
    return registry.createType('Si1TypeDef', {
      Tuple: []
    });
  }
  function convertPrimitive(registry, prim) {
    return registry.createType('Si1TypeDef', {
      Primitive: prim.toString()
    });
  }
  function convertSequence(registry, {
    type
  }) {
    return registry.createType('Si1TypeDef', {
      Sequence: {
        type: type.toNumber()
      }
    });
  }
  function convertTuple(registry, types) {
    return registry.createType('Si1TypeDef', {
      Tuple: types.map(t => t.toNumber())
    });
  }
  function convertVariant(registry, {
    variants
  }) {
    return registry.createType('Si1TypeDef', {
      Variant: {
        variants: variants.map(({
          discriminant,
          docs,
          fields,
          name
        }, index) => registry.createType('Si1Variant', {
          docs,
          fields: convertFields(registry, fields),
          index: discriminant.isSome ? discriminant.unwrap().toNumber() : index,
          name
        }))
      }
    });
  }
  function convertDef(registry, {
    def,
    path
  }) {
    if (def.isArray) {
      return convertArray(registry, def.asArray);
    } else if (def.isBitSequence) {
      return convertBitSequence(registry, def.asBitSequence);
    } else if (def.isCompact) {
      return convertCompact(registry, def.asCompact);
    } else if (def.isComposite) {
      return convertComposite(registry, def.asComposite);
    } else if (def.isPhantom) {
      return convertPhantom(registry, path);
    } else if (def.isPrimitive) {
      return convertPrimitive(registry, def.asPrimitive);
    } else if (def.isSequence) {
      return convertSequence(registry, def.asSequence);
    } else if (def.isTuple) {
      return convertTuple(registry, def.asTuple);
    } else if (def.isVariant) {
      return convertVariant(registry, def.asVariant);
    }
    throw new Error(`Cannot convert type ${def.toString()}`);
  }
  function toV1(registry, types) {
    return types.map((t, index) => registry.createType('PortableType', {
      id: index + 1,
      type: {
        def: convertDef(registry, t),
        docs: [],
        params: t.params.map(p => registry.createType('Si1TypeParameter', {
          type: p.toNumber()
        })),
        path: t.path.map(p => p.toString())
      }
    }));
  }

  const l = logger('registry');
  function valueToString(v) {
    return v.toString();
  }
  function getFieldArgs(lookup, fields) {
    const args = new Array(fields.length);
    for (let i = 0; i < fields.length; i++) {
      args[i] = lookup.getTypeDef(fields[i].type).type;
    }
    return args;
  }
  function clearRecord(record) {
    const keys = Object.keys(record);
    for (let i = 0; i < keys.length; i++) {
      delete record[keys[i]];
    }
  }
  function getVariantStringIdx({
    index
  }) {
    return index.toString();
  }
  function injectErrors(_, {
    lookup,
    pallets
  }, version, result) {
    clearRecord(result);
    for (let i = 0; i < pallets.length; i++) {
      const {
        errors,
        index,
        name
      } = pallets[i];
      if (errors.isSome) {
        const sectionName = stringCamelCase(name);
        lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, errors.unwrap(), getVariantStringIdx, ({
          docs,
          fields,
          index,
          name
        }) => ({
          args: getFieldArgs(lookup, fields),
          docs: docs.map(valueToString),
          fields,
          index: index.toNumber(),
          method: name.toString(),
          name: name.toString(),
          section: sectionName
        })));
      }
    }
  }
  function injectEvents(registry, {
    lookup,
    pallets
  }, version, result) {
    const filtered = pallets.filter(filterEventsSome);
    clearRecord(result);
    for (let i = 0; i < filtered.length; i++) {
      const {
        events,
        index,
        name
      } = filtered[i];
      lazyMethod(result, version >= 12 ? index.toNumber() : i, () => lazyVariants(lookup, events.unwrap(), getVariantStringIdx, variant => {
        const meta = registry.createType('EventMetadataLatest', objectSpread$1({}, variant, {
          args: getFieldArgs(lookup, variant.fields)
        }));
        return class extends GenericEventData {
          constructor(registry, value) {
            super(registry, value, meta, stringCamelCase(name), variant.name.toString());
          }
        };
      }));
    }
  }
  function injectExtrinsics(registry, {
    lookup,
    pallets
  }, version, result) {
    const filtered = pallets.filter(filterCallsSome);
    clearRecord(result);
    for (let i = 0; i < filtered.length; i++) {
      const {
        calls,
        index,
        name
      } = filtered[i];
      const sectionIndex = version >= 12 ? index.toNumber() : i;
      lazyMethod(result, sectionIndex, () => lazyVariants(lookup, calls.unwrap(), getVariantStringIdx, variant => createCallFunction(registry, lookup, variant, stringCamelCase(name), sectionIndex)));
    }
  }
  function extractProperties(registry, metadata) {
    var _constants$system;
    const original = registry.getChainProperties();
    const constants = decorateConstants(registry, metadata.asLatest, metadata.version);
    const ss58Format = (_constants$system = constants.system) === null || _constants$system === void 0 ? void 0 : _constants$system.ss58Prefix;
    if (!ss58Format) {
      return original;
    }
    const {
      tokenDecimals,
      tokenSymbol
    } = original || {};
    return registry.createType('ChainProperties', {
      ss58Format,
      tokenDecimals,
      tokenSymbol
    });
  }
  var _classes = _classPrivateFieldKey("classes");
  var _definitions = _classPrivateFieldKey("definitions");
  var _lookup = _classPrivateFieldKey("lookup");
  var _metadata = _classPrivateFieldKey("metadata");
  var _metadataVersion = _classPrivateFieldKey("metadataVersion");
  var _metadataCalls = _classPrivateFieldKey("metadataCalls");
  var _metadataErrors = _classPrivateFieldKey("metadataErrors");
  var _metadataEvents = _classPrivateFieldKey("metadataEvents");
  var _unknownTypes = _classPrivateFieldKey("unknownTypes");
  var _chainProperties = _classPrivateFieldKey("chainProperties");
  var _hasher = _classPrivateFieldKey("hasher");
  var _knownDefaults = _classPrivateFieldKey("knownDefaults");
  var _knownDefinitions = _classPrivateFieldKey("knownDefinitions");
  var _knownTypes = _classPrivateFieldKey("knownTypes");
  var _signedExtensions = _classPrivateFieldKey("signedExtensions");
  var _userExtensions = _classPrivateFieldKey("userExtensions");
  class TypeRegistry {
    constructor(createdAtHash) {
      Object.defineProperty(this, _classes, {
        writable: true,
        value: new Map()
      });
      Object.defineProperty(this, _definitions, {
        writable: true,
        value: new Map()
      });
      Object.defineProperty(this, _lookup, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _metadata, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _metadataVersion, {
        writable: true,
        value: 0
      });
      Object.defineProperty(this, _metadataCalls, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _metadataErrors, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _metadataEvents, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _unknownTypes, {
        writable: true,
        value: new Map()
      });
      Object.defineProperty(this, _chainProperties, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _hasher, {
        writable: true,
        value: blake2AsU8a
      });
      Object.defineProperty(this, _knownDefaults, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _knownDefinitions, {
        writable: true,
        value: void 0
      });
      Object.defineProperty(this, _knownTypes, {
        writable: true,
        value: {}
      });
      Object.defineProperty(this, _signedExtensions, {
        writable: true,
        value: fallbackExtensions
      });
      Object.defineProperty(this, _userExtensions, {
        writable: true,
        value: void 0
      });
      this.createdAtHash = void 0;
      _classPrivateFieldBase(this, _knownDefaults)[_knownDefaults] = objectSpread$1({
        Json,
        Metadata,
        PortableRegistry,
        Raw
      }, baseTypes);
      _classPrivateFieldBase(this, _knownDefinitions)[_knownDefinitions] = definitions;
      this.init();
      if (createdAtHash) {
        this.createdAtHash = this.createType('Hash', createdAtHash);
      }
    }
    init() {
      _classPrivateFieldBase(this, _classes)[_classes] = new Map();
      _classPrivateFieldBase(this, _definitions)[_definitions] = new Map();
      _classPrivateFieldBase(this, _unknownTypes)[_unknownTypes] = new Map();
      _classPrivateFieldBase(this, _knownTypes)[_knownTypes] = {};
      this.register(_classPrivateFieldBase(this, _knownDefaults)[_knownDefaults]);
      const allKnown = Object.values(_classPrivateFieldBase(this, _knownDefinitions)[_knownDefinitions]);
      for (let i = 0; i < allKnown.length; i++) {
        this.register(allKnown[i].types);
      }
      return this;
    }
    get chainDecimals() {
      var _classPrivateFieldLoo;
      if ((_classPrivateFieldLoo = _classPrivateFieldBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo !== void 0 && _classPrivateFieldLoo.tokenDecimals.isSome) {
        const allDecimals = _classPrivateFieldBase(this, _chainProperties)[_chainProperties].tokenDecimals.unwrap();
        if (allDecimals.length) {
          return allDecimals.map(b => b.toNumber());
        }
      }
      return [12];
    }
    get chainSS58() {
      var _classPrivateFieldLoo2;
      return (_classPrivateFieldLoo2 = _classPrivateFieldBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo2 !== void 0 && _classPrivateFieldLoo2.ss58Format.isSome ? _classPrivateFieldBase(this, _chainProperties)[_chainProperties].ss58Format.unwrap().toNumber() : undefined;
    }
    get chainTokens() {
      var _classPrivateFieldLoo3;
      if ((_classPrivateFieldLoo3 = _classPrivateFieldBase(this, _chainProperties)[_chainProperties]) !== null && _classPrivateFieldLoo3 !== void 0 && _classPrivateFieldLoo3.tokenSymbol.isSome) {
        const allTokens = _classPrivateFieldBase(this, _chainProperties)[_chainProperties].tokenSymbol.unwrap();
        if (allTokens.length) {
          return allTokens.map(valueToString);
        }
      }
      return [formatBalance.getDefaults().unit];
    }
    isLookupType(value) {
      return /Lookup\d+$/.test(value);
    }
    createLookupType(lookupId) {
      return `Lookup${lookupId.toString()}`;
    }
    get knownTypes() {
      return _classPrivateFieldBase(this, _knownTypes)[_knownTypes];
    }
    get lookup() {
      return _classPrivateFieldBase(this, _lookup)[_lookup] || this.metadata.lookup;
    }
    get metadata() {
      assert$h(_classPrivateFieldBase(this, _metadata)[_metadata], 'Metadata has not been set on this registry');
      return _classPrivateFieldBase(this, _metadata)[_metadata];
    }
    get unknownTypes() {
      return [..._classPrivateFieldBase(this, _unknownTypes)[_unknownTypes].keys()];
    }
    get signedExtensions() {
      return _classPrivateFieldBase(this, _signedExtensions)[_signedExtensions];
    }
    createClass(type) {
      return createClass(this, type);
    }
    createType(type, ...params) {
      return this.createTypeUnsafe(type, params);
    }
    createTypeUnsafe(type, params, options) {
      return createTypeUnsafe(this, type, params, options);
    }
    findMetaCall(callIndex) {
      const [section, method] = [callIndex[0], callIndex[1]];
      return assertReturn(_classPrivateFieldBase(this, _metadataCalls)[_metadataCalls][`${section}`] && _classPrivateFieldBase(this, _metadataCalls)[_metadataCalls][`${section}`][`${method}`], () => `findMetaCall: Unable to find Call with index [${section}, ${method}]/[${callIndex.toString()}]`);
    }
    findMetaError(errorIndex) {
      const [section, method] = isU8a$1(errorIndex) ? [errorIndex[0], errorIndex[1]] : [errorIndex.index.toNumber(), errorIndex.error.toNumber()];
      return assertReturn(_classPrivateFieldBase(this, _metadataErrors)[_metadataErrors][`${section}`] && _classPrivateFieldBase(this, _metadataErrors)[_metadataErrors][`${section}`][`${method}`], () => `findMetaError: Unable to find Error with index [${section}, ${method}]/[${errorIndex.toString()}]`);
    }
    findMetaEvent(eventIndex) {
      const [section, method] = [eventIndex[0], eventIndex[1]];
      return assertReturn(_classPrivateFieldBase(this, _metadataEvents)[_metadataEvents][`${section}`] && _classPrivateFieldBase(this, _metadataEvents)[_metadataEvents][`${section}`][`${method}`], () => `findMetaEvent: Unable to find Event with index [${section}, ${method}]/[${eventIndex.toString()}]`);
    }
    get(name, withUnknown, knownTypeDef) {
      let Type = _classPrivateFieldBase(this, _classes)[_classes].get(name);
      if (!Type) {
        const definition = _classPrivateFieldBase(this, _definitions)[_definitions].get(name);
        let BaseType;
        if (definition) {
          BaseType = createClass(this, definition);
        } else if (knownTypeDef) {
          BaseType = constructTypeClass(this, knownTypeDef);
        } else if (withUnknown) {
          l.warn(`Unable to resolve type ${name}, it will fail on construction`);
          _classPrivateFieldBase(this, _unknownTypes)[_unknownTypes].set(name, true);
          BaseType = DoNotConstruct.with(name);
        }
        if (BaseType) {
          Type = class extends BaseType {};
          _classPrivateFieldBase(this, _classes)[_classes].set(name, Type);
        }
      }
      return Type;
    }
    getChainProperties() {
      return _classPrivateFieldBase(this, _chainProperties)[_chainProperties];
    }
    getClassName(Type) {
      const names = [];
      for (const [name, Clazz] of _classPrivateFieldBase(this, _classes)[_classes].entries()) {
        if (Type === Clazz) {
          names.push(name);
        }
      }
      names.sort().reverse();
      return names.length ? names[0] : undefined;
    }
    getDefinition(typeName) {
      return _classPrivateFieldBase(this, _definitions)[_definitions].get(typeName);
    }
    getModuleInstances(specName, moduleName) {
      var _classPrivateFieldLoo4, _classPrivateFieldLoo5, _classPrivateFieldLoo6, _classPrivateFieldLoo7, _classPrivateFieldLoo8;
      return (_classPrivateFieldLoo4 = _classPrivateFieldBase(this, _knownTypes)[_knownTypes]) === null || _classPrivateFieldLoo4 === void 0 ? void 0 : (_classPrivateFieldLoo5 = _classPrivateFieldLoo4.typesBundle) === null || _classPrivateFieldLoo5 === void 0 ? void 0 : (_classPrivateFieldLoo6 = _classPrivateFieldLoo5.spec) === null || _classPrivateFieldLoo6 === void 0 ? void 0 : (_classPrivateFieldLoo7 = _classPrivateFieldLoo6[specName]) === null || _classPrivateFieldLoo7 === void 0 ? void 0 : (_classPrivateFieldLoo8 = _classPrivateFieldLoo7.instances) === null || _classPrivateFieldLoo8 === void 0 ? void 0 : _classPrivateFieldLoo8[moduleName];
    }
    getOrThrow(name, msg) {
      const Clazz = this.get(name);
      assert$h(Clazz, msg || `type ${name} not found`);
      return Clazz;
    }
    getOrUnknown(name) {
      return this.get(name, true);
    }
    getSignedExtensionExtra() {
      return expandExtensionTypes(_classPrivateFieldBase(this, _signedExtensions)[_signedExtensions], 'payload', _classPrivateFieldBase(this, _userExtensions)[_userExtensions]);
    }
    getSignedExtensionTypes() {
      return expandExtensionTypes(_classPrivateFieldBase(this, _signedExtensions)[_signedExtensions], 'extrinsic', _classPrivateFieldBase(this, _userExtensions)[_userExtensions]);
    }
    hasClass(name) {
      return _classPrivateFieldBase(this, _classes)[_classes].has(name);
    }
    hasDef(name) {
      return _classPrivateFieldBase(this, _definitions)[_definitions].has(name);
    }
    hasType(name) {
      return !_classPrivateFieldBase(this, _unknownTypes)[_unknownTypes].get(name) && (this.hasClass(name) || this.hasDef(name));
    }
    hash(data) {
      return this.createType('CodecHash', _classPrivateFieldBase(this, _hasher)[_hasher](data));
    }
    register(arg1, arg2) {
      if (isFunction$1(arg1)) {
        _classPrivateFieldBase(this, _classes)[_classes].set(arg1.name, arg1);
      } else if (isString$1(arg1)) {
        assert$h(isFunction$1(arg2), () => `Expected class definition passed to '${arg1}' registration`);
        assert$h(arg1 !== arg2.toString(), () => `Unable to register circular ${arg1} === ${arg1}`);
        _classPrivateFieldBase(this, _classes)[_classes].set(arg1, arg2);
      } else {
        this._registerObject(arg1);
      }
    }
    _registerObject(obj) {
      const entries = Object.entries(obj);
      for (let e = 0; e < entries.length; e++) {
        const [name, type] = entries[e];
        if (isFunction$1(type)) {
          _classPrivateFieldBase(this, _classes)[_classes].set(name, type);
        } else {
          const def = isString$1(type) ? type : stringify(type);
          assert$h(name !== def, () => `Unable to register circular ${name} === ${def}`);
          if (_classPrivateFieldBase(this, _classes)[_classes].has(name)) {
            _classPrivateFieldBase(this, _classes)[_classes].delete(name);
          }
          _classPrivateFieldBase(this, _definitions)[_definitions].set(name, def);
        }
      }
    }
    setChainProperties(properties) {
      if (properties) {
        _classPrivateFieldBase(this, _chainProperties)[_chainProperties] = properties;
      }
    }
    setHasher(hasher) {
      _classPrivateFieldBase(this, _hasher)[_hasher] = hasher || blake2AsU8a;
    }
    setKnownTypes(knownTypes) {
      _classPrivateFieldBase(this, _knownTypes)[_knownTypes] = knownTypes;
    }
    setLookup(lookup) {
      _classPrivateFieldBase(this, _lookup)[_lookup] = lookup;
    }
    setMetadata(metadata, signedExtensions, userExtensions) {
      _classPrivateFieldBase(this, _metadata)[_metadata] = metadata.asLatest;
      _classPrivateFieldBase(this, _metadataVersion)[_metadataVersion] = metadata.version;
      injectExtrinsics(this, _classPrivateFieldBase(this, _metadata)[_metadata], _classPrivateFieldBase(this, _metadataVersion)[_metadataVersion], _classPrivateFieldBase(this, _metadataCalls)[_metadataCalls]);
      injectErrors(this, _classPrivateFieldBase(this, _metadata)[_metadata], _classPrivateFieldBase(this, _metadataVersion)[_metadataVersion], _classPrivateFieldBase(this, _metadataErrors)[_metadataErrors]);
      injectEvents(this, _classPrivateFieldBase(this, _metadata)[_metadata], _classPrivateFieldBase(this, _metadataVersion)[_metadataVersion], _classPrivateFieldBase(this, _metadataEvents)[_metadataEvents]);
      this.setSignedExtensions(signedExtensions || (_classPrivateFieldBase(this, _metadata)[_metadata].extrinsic.version.gt(BN_ZERO)
      ? _classPrivateFieldBase(this, _metadata)[_metadata].extrinsic.signedExtensions.map(({
        identifier
      }) => identifier.toString()) : fallbackExtensions), userExtensions);
      this.setChainProperties(extractProperties(this, metadata));
    }
    setSignedExtensions(signedExtensions = fallbackExtensions, userExtensions) {
      _classPrivateFieldBase(this, _signedExtensions)[_signedExtensions] = signedExtensions;
      _classPrivateFieldBase(this, _userExtensions)[_userExtensions] = userExtensions;
      const unknown = findUnknownExtensions(_classPrivateFieldBase(this, _signedExtensions)[_signedExtensions], _classPrivateFieldBase(this, _userExtensions)[_userExtensions]);
      if (unknown.length) {
        l.warn(`Unknown signed extensions ${unknown.join(', ')} found, treating them as no-effect`);
      }
    }
  }

  const packageInfo = {
    name: '@5ire/types',
    version: '0.2.2'
  };

  exports.BTreeMap = BTreeMap;
  exports.BTreeSet = BTreeSet;
  exports.BitVec = BitVec;
  exports.Bool = bool;
  exports.Bytes = Bytes;
  exports.CodecMap = CodecMap;
  exports.CodecSet = CodecSet;
  exports.Compact = Compact;
  exports.Data = Data;
  exports.DoNotConstruct = DoNotConstruct;
  exports.Enum = Enum;
  exports.GenericAccountId = GenericAccountId;
  exports.GenericAccountIndex = GenericAccountIndex;
  exports.GenericAddress = GenericMultiAddress;
  exports.GenericBlock = GenericBlock;
  exports.GenericCall = GenericCall;
  exports.GenericChainProperties = GenericChainProperties;
  exports.GenericConsensusEngineId = GenericConsensusEngineId;
  exports.GenericEthereumAccountId = GenericEthereumAccountId;
  exports.GenericEthereumLookupSource = GenericEthereumLookupSource;
  exports.GenericEvent = GenericEvent;
  exports.GenericEventData = GenericEventData;
  exports.GenericExtrinsic = GenericExtrinsic;
  exports.GenericExtrinsicEra = GenericExtrinsicEra;
  exports.GenericExtrinsicPayload = GenericExtrinsicPayload;
  exports.GenericExtrinsicPayloadUnknown = GenericExtrinsicPayloadUnknown;
  exports.GenericExtrinsicPayloadV4 = GenericExtrinsicPayloadV4;
  exports.GenericExtrinsicSignatureV4 = GenericExtrinsicSignatureV4;
  exports.GenericExtrinsicUnknown = GenericExtrinsicUnknown;
  exports.GenericExtrinsicV4 = GenericExtrinsicV4;
  exports.GenericImmortalEra = ImmortalEra;
  exports.GenericLookupSource = GenericLookupSource;
  exports.GenericMortalEra = MortalEra;
  exports.GenericMultiAddress = GenericMultiAddress;
  exports.GenericSignerPayload = GenericSignerPayload;
  exports.GenericVote = GenericVote;
  exports.HashMap = HashMap;
  exports.I128 = i128;
  exports.I16 = i16;
  exports.I256 = i256;
  exports.I32 = i32;
  exports.I64 = i64;
  exports.I8 = i8;
  exports.Int = Int;
  exports.Json = Json;
  exports.Linkage = Linkage;
  exports.Map = CodecMap;
  exports.Metadata = Metadata;
  exports.Null = Null;
  exports.Option = Option;
  exports.PortableRegistry = PortableRegistry;
  exports.Range = Range;
  exports.RangeInclusive = RangeInclusive;
  exports.Raw = Raw;
  exports.Result = Result;
  exports.Set = CodecSet;
  exports.StorageKey = StorageKey;
  exports.Struct = Struct;
  exports.Text = Text;
  exports.Tuple = Tuple;
  exports.Type = Type;
  exports.TypeRegistry = TypeRegistry;
  exports.U128 = u128;
  exports.U16 = u16$1;
  exports.U256 = u256;
  exports.U32 = u32$1;
  exports.U64 = u64;
  exports.U8 = u8$1;
  exports.U8aFixed = U8aFixed;
  exports.UInt = UInt;
  exports.USize = usize;
  exports.Vec = Vec;
  exports.VecFixed = VecFixed;
  exports.WrapperOpaque = WrapperOpaque;
  exports.bool = bool;
  exports.constructTypeClass = constructTypeClass;
  exports.convertSiV0toV1 = toV1;
  exports.createClass = createClass;
  exports.createType = createType;
  exports.createTypeUnsafe = createTypeUnsafe;
  exports.decorateConstants = decorateConstants;
  exports.decorateExtrinsics = decorateExtrinsics;
  exports.decorateStorage = decorateStorage;
  exports.encodeTypeDef = encodeTypeDef;
  exports.expandMetadata = expandMetadata;
  exports.getTypeClass = getTypeClass;
  exports.getTypeDef = getTypeDef;
  exports.i128 = i128;
  exports.i16 = i16;
  exports.i256 = i256;
  exports.i32 = i32;
  exports.i64 = i64;
  exports.i8 = i8;
  exports.lazyVariants = lazyVariants;
  exports.packageInfo = packageInfo;
  exports.paramsNotation = paramsNotation;
  exports.rpcDefinitions = jsonrpc$1;
  exports.typeDefinitions = definitions;
  exports.typeSplit = typeSplit;
  exports.u128 = u128;
  exports.u16 = u16$1;
  exports.u256 = u256;
  exports.u32 = u32$1;
  exports.u64 = u64;
  exports.u8 = u8$1;
  exports.unwrapStorageType = unwrapStorageType;
  exports.usize = usize;
  exports.withTypeString = withTypeString;

  Object.defineProperty(exports, '__esModule', { value: true });

  return exports;

})({}, typesKnown, require$$0$1);
